--- util-linux-2.12r.orig/debian/README.Debian.hwclock
+++ util-linux-2.12r/debian/README.Debian.hwclock
@@ -0,0 +1,65 @@
+hwclock and Debian:
+
+A Debian installation will, by default, call hwclock --hctosys during system
+startup and hwclock --systohc during system shutdown.
+
+To set the date/time of the system, just use the standard UNIX date facilities
+(such as date) or any of the advanced timekeeping utilities (ntp, ntpdate,
+chrony). Other methods of setting the clock (such as hwclock) are likely to 
+cause trouble, do not use them.
+
+Please note that because the shutdown scripts call hwclock --systohc, you
+cannot set the clock using hwclock only, as your adjustment will be lost on
+the next reboot. THIS MEANS YOU MUST *NOT* FOLLOW THE PROCEDURES IN THE
+hwclock(8) MAN PAGE TO SET THE CLOCK DATE/TIME USING A REBOOT UNLESS YOU
+EDIT THE SHUTDOWN SCRIPTS.
+
+
+The full story:
+
+A Linux system actually has two clocks:
+
+ - The System Clock, kept by the kernel. This is the clock that Linux uses for
+   day-to-day activities, and this is also the clock you set using date.
+
+ - The Hardware Clock, also called RTC, which is used as a backup to keep time 
+   while the computer is turned off, or in APM suspended state. This is the
+   clock you set using hwclock --set.
+
+(you can get more information about these two clocks in the hwclock(8) man
+page).
+
+hwclock is used to copy time between these two clocks. For the Debian
+standard install, the system clock is initialized with the value of the
+hardware clock during startup, and the value of the system clock is copied
+back to the hardware clock during system shutdown/reboot.
+
+So, in a Debian default install, you can keep the illusion that there's a
+single clock. Unless you use a program that modifies the hardware clock
+directly and does not set the system clock as well, that is.
+
+
+Issues with hwclock --adjust:
+
+hwclock has a facility to try to correct for systematic drift in the
+hardware clock, accessed by hwclock --adjust. This facility is *dangerous*
+because it has a severe drawback: it assumes that no program other than
+hwclock --systohc will ever be used to change the hardware clock.
+
+This assumption is often false, as many common utilities such as ntp,
+chrony, as well as your computer's System Setup BIOS program, and
+any other OS you have in your machine will change the clock.
+
+Also, if hwclock --adjust is used, one must make sure the drift file
+(/etc/adjtime) is deleted every time the system clock is set to a very
+different value (even if you're using hwclock itself to do it!), or the
+drift computation might become invalid and cause the hardware clock to be
+incorrectly set the next time hwclock --adjust is used.
+
+hwclock currently does not perform any sort of sanity checks in the values
+it uses to compute the drift file, and will corrupt your clock time by
+potentially very large amounts if anything goes wrong.
+
+Don't use the hwclock --adjust facility, refer to alternate (and much safer)
+programs such as ntp or chrony if you need precision timekeeping.
+
--- util-linux-2.12r.orig/debian/README.script
+++ util-linux-2.12r/debian/README.script
@@ -0,0 +1,38 @@
+Security hole in `script'
+-------------------------
+
+The BSD `script' utility included in the `bsdutils' package is not
+installed setuid root, and was not written to be.  Sometimes the tty
+`script' allocates is already owned by the appropriate user, in which
+case there will be no problem.  In other cases, `script' will not be
+able to set the ownership or mode of the pty/tty pair it allocates,
+and so it cannot prevent other processes reading or writing to the tty.
+
+The result of this is a security hole: during such a `script' session,
+other users can read keystrokes from your tty, or write to your terminal,
+without any warning or explicit authorisation.  This means that any
+password(s) or other sensitive data you enter during such a `script'
+session are not secure against snooping, even if they are (properly)
+not echoed to the screen.
+
+To protect against this, `script' tries to detect whether the tty
+allocated for it by the C library's openpty() function is secure
+against snooping.  If it detects that there is a problem, `script'
+issues a warning.  If you see this warning, you should not enter any
+sensitive data during the script session, and you should not trust the
+output displayed, or that recorded in the `typescript' file, to be free
+from tampering.
+
+This bug is due to a long-standing design flaw in UNIX, and is to be cured
+shortly by the introduction of the UNIX98-style pty system supported
+by GLIBC 2.1 and Linux 2.2.  The UNIX98-style pty system makes use of
+kernel support to create slave devices on the fly, with the correct
+ownership and permissions already in place.  This allows unprivileged
+user programs to allocate pty/tty pairs securely, and eliminates the
+race conditions currently present in pty allocation.
+
+When `script' is used on a system with UNIX98-style pty support in
+the kernel and in libc, `script' will detect that its tty is secure,
+and will not display the warning.
+
+Charles Briscoe-Smith <cpbs@debian.org>  Wed,  9 Dec 1998 13:32:49 +0000
--- util-linux-2.12r.orig/debian/bsdutils.postinst
+++ util-linux-2.12r/debian/bsdutils.postinst
@@ -0,0 +1,6 @@
+#!/bin/sh -e
+
+if [ -L /usr/doc/bsdutils ] ; then
+    rm -f /usr/doc/bsdutils
+fi
+
--- util-linux-2.12r.orig/debian/bsdutils.prerm
+++ util-linux-2.12r/debian/bsdutils.prerm
@@ -0,0 +1,5 @@
+#!/bin/sh -e
+
+if [ -L /usr/doc/bsdutils ] ; then
+       rm -f /usr/doc/bsdutils
+fi
--- util-linux-2.12r.orig/debian/changelog
+++ util-linux-2.12r/debian/changelog
@@ -0,0 +1,1638 @@
+util-linux (2.12r-12) unstable; urgency=low
+
+  * drop hwclockfirst.sh, and put hwclock.sh back at 50.  See #50572 and
+    Closes: #342887
+  * Deal with _syscall5 going away.  Patch imported from Ubuntu.
+    Closes: #392236
+
+ -- LaMont Jones <lamont@debian.org>  Thu, 19 Oct 2006 19:01:33 -0600
+
+util-linux (2.12r-11) unstable; urgency=low
+
+  * typos in NFSv4 (GSSDLCK didn't have .pid, and the latest
+    nfs-common no longer creates the file at all.) Closes: #376931
+    - modified 30nfs4-fix.dpatch
+
+ -- LaMont Jones <lamont@debian.org>  Tue, 19 Sep 2006 09:33:31 -0600
+
+util-linux (2.12r-10) unstable; urgency=low
+
+  * NFSv4 patch fixes for cfs.  Closes: #367049
+    Thanks to Trond Myklebust for the quick fix.
+    - modified 30nfs4-fix.dpatch
+
+ -- LaMont Jones <lamont@debian.org>  Mon, 15 May 2006 18:12:24 -0600
+
+util-linux (2.12r-9) unstable; urgency=low
+
+  * Release NFSv4 support. Closes: #302420, #239031, #290873
+  * Deliver isosize. Closes: #354960
+  * Fix udeb dependencies.  Closes: #360352
+
+ -- LaMont Jones <lamont@debian.org>  Sat,  6 May 2006 21:53:12 -0600
+
+util-linux (2.12r-8.2nfs4) experimental; urgency=low
+
+  * Turn on fixed nfsv4 patch.  Closes: #302420, #239031
+    Thanks to Steinar H. Gunderson <sgunderson@bigfoot.com>
+
+ -- LaMont Jones <lamont@debian.org>  Fri, 28 Apr 2006 11:04:39 -0600
+
+util-linux (2.12r-8) unstable; urgency=high
+
+  * Drop NFS v4 patch, since it breaks mounting things exported by
+    nfs-user-server.  It will be happily reapplied once someone fixes
+    the patch.  Closes: #354075.  Reopens: #302420, #239031
+    - fix compiler warnings in said patch.
+    - Apply nfs4mount.c fix to (dropped) nfsv4 patch.  Closes: #354193
+
+ -- LaMont Jones <lamont@debian.org>  Fri, 24 Feb 2006 10:57:29 -0700
+
+util-linux (2.12r-7) unstable; urgency=low
+
+  * Add nfsv4 patch.  Closes: #302420, #239031
+
+ -- LaMont Jones <lamont@debian.org>  Tue, 21 Feb 2006 11:01:21 -0700
+
+util-linux (2.12r-6) unstable; urgency=low
+
+  * make hwclock even more policy compilant.
+
+ -- LaMont Jones <lamont@debian.org>  Sat, 28 Jan 2006 08:57:45 -0700
+
+util-linux (2.12r-5) unstable; urgency=low
+
+  * make hwclock prettier.  Closes: #348718
+
+ -- LaMont Jones <lamont@debian.org>  Wed, 18 Jan 2006 11:44:06 -0700
+
+util-linux (2.12r-4) unstable; urgency=low
+
+  * Stupid fat-fingers typo.  Closes: #348483
+
+ -- LaMont Jones <lamont@debian.org>  Tue, 17 Jan 2006 07:40:56 -0700
+
+util-linux (2.12r-3) unstable; urgency=low
+
+  * Add ppc64 support.  Closes: #322130
+  * Update sections to match the overrides file.
+  * hwclockfirst.sh may not exit, since it gets sourced.
+    Closes: #343447
+  * make the start messages from hwclock{first,}.sh slightly
+    different, for clarity.
+  * Build sparc binaries on sparc64
+  * Actually cleanup pager alternatives.  Closes: #348235
+  * Deal better with long passwords.  Based on patch from YAEGASHI Takeshi
+    <yaegashi@debian.org>.  Closes: #315660
+
+ -- LaMont Jones <lamont@debian.org>  Mon, 16 Jan 2006 14:35:42 -0700
+
+util-linux (2.12r-2) unstable; urgency=low
+
+  * Add back in dropped cramfs-udebsize patch.
+
+ -- LaMont Jones <lamont@debian.org>  Fri,  9 Dec 2005 12:25:19 -0700
+
+util-linux (2.12r-1) unstable; urgency=low
+
+  * New upstream verison and maintainer.
+    - cfdisk: fix a segfault with ReiserFS partitions
+    - umount: disallow -r option for non-root users (CAN-2005-2876)
+    - sfdisk: document -G option in --help output
+    - updated translations: ca, et, fr
+    - sfdisk: add -G option (Andries Brouwer)
+    - updated translations: de, es, ru, sv, tr, nl
+  * split cfdisk into its own udeb.  Closes: #243094, #314368
+  * Really move hwclockfirst.sh back to S18 where it belongs.
+    Put hwclock.sh at S22.  See #50572.
+  * Missing line break in hwclock.sh.  Closes: #337955
+  * Include swap-suspend patch from Ubuntu.
+  * Fix variable name typo in hwclock.sh.  Closes: #340232
+  * Add CPU=$(arch) to make call for building on amd64/i386 mixed systems.
+    Closes: #305907
+  * Cleanup lsb_init function usage.
+
+ -- LaMont Jones <lamont@debian.org>  Wed,  7 Dec 2005 08:52:21 -0700
+
+util-linux (2.12p-8) unstable; urgency=high
+
+  * if /etc/adjtime is a dangling symlink, don't use it in hwclock*.sh
+  * Applited patch by Max Vozeler to fix a local privilege escalation
+    vulnerability in umount -r [debian/patches/51security_CAN-2005-2876.dpatch]
+    Closes: #328141, #329063
+
+ -- LaMont Jones <lamont@debian.org>  Wed, 21 Sep 2005 08:36:17 -0600
+
+util-linux (2.12p-7) unstable; urgency=low
+
+  * Fix non-posix typo in hwclock.sh.  Closes: #323872
+
+ -- LaMont Jones <lamont@debian.org>  Thu, 18 Aug 2005 19:27:51 -0600
+
+util-linux (2.12p-6) unstable; urgency=low
+
+  * Use helper program in mount for guessed FS types too.  Thanks to Manish
+    Singh and Fabio Massimo Di Nitto.  Adds: 20guesshelper.dpatch
+  * Remove /usr/doc links on install.  Closes: #322806, #322816
+  * Fix /usr/bin/pg pager alternative.  Closes: #323204
+  * Overhaul hwclock.sh and hwclockfirst.sh.  Closes: #286948, #251479
+  * Resync with Ubuntu, changes by Martin.Pitt@ubuntu.com:  Closes: #323463
+    debian/patches/60_opt_O1.dpatch:
+    - MCONFIG, configure: Build with -O1 instead of -O2 to work around cfdisk
+      segfault.
+    - Yay for upstream build systems which do not support specifying CFLAGS or
+      OPT without breaking.
+
+ -- LaMont Jones <lamont@debian.org>  Wed, 17 Aug 2005 16:14:29 -0600
+
+util-linux (2.12p-5) unstable; urgency=low
+
+  * Merge changes from ubuntu
+    - closes #319143
+  * Build-Depend: libslang2-dev.  Closes: #315634
+
+ -- LaMont Jones <lamont@debian.org>  Thu, 21 Jul 2005 12:08:23 -0600
+
+util-linux (2.12p-4ubuntu4) breezy; urgency=low
+
+  * dpkg-architecture says DEB_HOST_GNU_SYSTEM is "linux-gnu" now, not
+    "linux". Take account of this, and add compatibility code for old
+    dpkg-architecture (closes: Ubuntu #11012).
+
+ -- Colin Watson <cjwatson@ubuntu.com>  Sat, 21 May 2005 12:03:36 +0100
+
+util-linux (2.12p-4ubuntu3) breezy; urgency=low
+
+  * Don't special case sparc, it has umount2.
+
+ -- Jeff Bailey <jbailey@ubuntu.com>  Fri, 20 May 2005 11:48:24 +0000
+
+util-linux (2.12p-4ubuntu2) breezy; urgency=low
+
+  * Run hwclockfirst.sh after modules load, so that rtc is loaded.
+
+ -- LaMont Jones <lamont@ubuntu.com>  Thu, 12 May 2005 10:24:42 -0600
+
+util-linux (2.12p-4ubuntu1) breezy; urgency=low
+
+  * Resynchronise with Debian.
+  * correct shutdown message from hwclock.sh
+
+ -- LaMont Jones <lamont@ubuntu.com>  Fri, 15 Apr 2005 18:01:57 -0600
+
+util-linux (2.12p-4) unstable; urgency=low
+
+  * Depend on newer libblkid1.
+
+ -- LaMont Jones <lamont@debian.org>  Thu, 17 Mar 2005 11:50:49 -0700
+
+util-linux (2.12p-3) unstable; urgency=low
+
+  * Add an alternative for pager pointing at pg (at pref 10).  Closes: #294218
+  * enable fdisk on s390.  Closes: #238151
+
+ -- LaMont Jones <lamont@debian.org>  Tue,  8 Feb 2005 13:45:34 -0700
+
+util-linux (2.12p-2ubuntu2) hoary; urgency=low
+
+  * Update dependencies for new libblkid1
+
+ -- LaMont Jones <lamont@ubuntu.com>  Thu, 17 Mar 2005 11:12:42 -0700
+
+util-linux (2.12p-2ubuntu1) hoary; urgency=low
+
+  * Resync with Debian.
+
+ -- LaMont Jones <lamont@canonical.com>  Sat, 25 Dec 2004 08:12:38 -0700
+
+util-linux (2.12p-2) unstable; urgency=low
+
+  * Really fix man page in alternatives.  Closes: #145647
+  * more typos in hwclockfirst.sh.  Closes: #276372
+
+ -- LaMont Jones <lamont@debian.org>  Sat, 25 Dec 2004 08:08:12 -0700
+
+util-linux (2.12p-1ubuntu1) hoary; urgency=low
+
+  * Resync with Debian.  Closes warty #3366, 4784
+
+ -- LaMont Jones <lamont@canonical.com>  Fri, 24 Dec 2004 15:27:32 -0700
+
+util-linux (2.12p-1) unstable; urgency=low
+
+  * New upstream version. (2.12p)
+    Closes: #182325, #270173, #192751, #229875, #230859, #214144, #254317, #272580
+    - cfdisk: fix number of new partition when partitions not in disk order
+    - fdisk: fix Sun label handling in sector mode
+    - mkfs: never truncate filename (not that that ever happened)
+    - more: fix redraw flaw.  Closes: #146678
+  * New upstream version. (2.12o)  Closes: #286519, #132998, #207236
+    - lomount: revert patch from 2.12j
+    - lptune.8: -T option is obsolete
+    - mkswap, mkswap.8, swapon: support labels
+      (use HAVE_BLKID=no as long as the blkid library doesnt support this)
+    - umount: allow user unmounting repeatedly mounted nfs mounts
+  * Build-Depend on uuid-dev.  Closes: #282668
+  * correct chown args in debian/rules.  Closes: #254780
+  * include man page in update-alternatives for pager.  Closes: #145647
+  * fix typos in howclockfirst.sh.  Closes: #276372
+  * fix losetup -N documentation.  Closes: #239475
+  * cleanup some narrow window sprintf issues in cfdisk.
+
+ -- LaMont Jones <lamont@mmjgroup.com>  Fri, 24 Dec 2004 14:38:23 -0700
+
+util-linux (2.12m-1ubuntu1) hoary; urgency=low
+
+  * Resync with Debian.
+
+ -- LaMont Jones <lamont@canonical.com>  Mon, 20 Dec 2004 10:55:20 -0700
+
+util-linux (2.12m-1) unstable; urgency=low
+
+  * New upstream version
+    - cfdisk: recognize JFS, support reiserfs labels (flavio.stanchina@tin.it)
+    - mount: fix option parsing bug
+    - mount.8: several updates
+    - swapon.8: document -v option
+
+ -- LaMont Jones <lamont@debian.org>  Mon, 20 Dec 2004 10:46:16 -0700
+
+util-linux (2.12l-1ubuntu1) hoary; urgency=low
+
+  * Resync with debian
+
+ -- LaMont Jones <lamont@canonical.com>  Wed, 15 Dec 2004 17:22:52 -0700
+
+util-linux (2.12l-1) unstable; urgency=low
+
+  * New upstream version, shrinking the size of the Debian diff.
+    - Makefile: remove cat-id-tbl.c upon make clean
+    - fdisk: fixed a bug that would cause a non-update of a sun disklabel
+    - fdisk: use sectorsize instead of 512 for SGI (Eric Y. Theriault)
+    - fdisk: use __attribute__((packed)) for alpha, ARM: avoid unaligned accesses
+    - hwclock: actually use HAVE_tm_gmtoff
+    - swapon: fix priority handling
+    - umount: refuse to unmount an empty string
+  * Jetisoning the (broken) hurd patch for now.
+
+ -- LaMont Jones <lamont@debian.org>  Wed, 15 Dec 2004 17:27:44 -0700
+
+util-linux (2.12k-2ubuntu1) hoary; urgency=low
+
+  * Resync with Debian
+
+ -- LaMont Jones <lamont@canonical.com>  Wed, 15 Dec 2004 11:32:45 -0700
+
+util-linux (2.12k-2) unstable; urgency=low
+
+  * Switch to dpatch.
+  * Clean up --nohashpass in losetup.  Closes: #285639
+  * Use stat instead of open in losetup.  (From #285353)
+
+ -- LaMont Jones <lamont@debian.org>  Wed, 15 Dec 2004 10:43:29 -0700
+
+util-linux (2.12k-1ubuntu1) hoary; urgency=low
+
+  * Resync with Debian
+
+ -- LaMont Jones <lamont@canonical.com>  Mon, 13 Dec 2004 16:55:15 -0700
+
+util-linux (2.12k-1) unstable; urgency=low
+
+  * New upstream version.
+    * various translation updates
+    * gcc-3.4 support help
+
+ -- LaMont Jones <lamont@debian.org>  Mon, 13 Dec 2004 16:50:57 -0700
+
+util-linux (2.12j-3ubuntu1) hoary; urgency=low
+
+  * Resync with Debian
+
+ -- LaMont Jones <lamont@canonical.com>  Fri, 10 Dec 2004 07:23:03 -0700
+
+util-linux (2.12j-3) unstable; urgency=low
+
+  * umount -l "" does bad things.  Don't do let the user do that.
+  * remove non-utf8 characters from changelog.  sorry.
+
+ -- LaMont Jones <lamont@debian.org>  Fri, 10 Dec 2004 07:11:02 -0700
+
+util-linux (2.12j-2ubuntu1) hoary; urgency=low
+
+  * resync with Debian
+
+ -- LaMont Jones <lamont@canonical.com>  Tue,  7 Dec 2004 11:01:29 -0700
+
+util-linux (2.12j-2) unstable; urgency=low
+
+  * uninitialized variable.  Closes: #284597
+
+ -- LaMont Jones <lamont@debian.org>  Tue,  7 Dec 2004 10:52:55 -0700
+
+util-linux (2.12j-1ubuntu1) hoary; urgency=low
+
+  * resync with Debian
+
+ -- LaMont Jones <lamont@canonical.com>  Mon,  6 Dec 2004 03:55:55 -0700
+
+util-linux (2.12j-1) unstable; urgency=low
+
+  * New upstream version
+
+ -- LaMont Jones <lamont@debian.org>  Mon,  6 Dec 2004 03:29:45 -0700
+
+util-linux (2.12h-4ubuntu1) hoary; urgency=low
+
+  * resync with debian.
+
+ -- LaMont Jones <lamont@canonical.com>  Thu,  2 Dec 2004 22:37:16 -0700
+
+util-linux (2.12h-4) unstable; urgency=low
+
+  * mkswap on a file was broken. Thanks to Bas Zoetekouw <bas@debian.org>
+    for the patch.  Closes: #280032, #282678
+  * add libblkid-dev to Build-Depends.  Closes: #282668
+
+ -- LaMont Jones <lamont@debian.org>  Thu,  2 Dec 2004 10:42:04 -0700
+
+util-linux (2.12h-3ubuntu1) hoary; urgency=low
+
+  * Resync with debian.
+    Fix mount segv.  Closes: Warty#3153
+
+ -- LaMont Jones <lamont@canonical.com>  Wed,  3 Nov 2004 10:44:22 -0700
+
+util-linux (2.12h-3) unstable; urgency=low
+
+  * Fix mount segv's.  Closes: #279306
+
+ -- LaMont Jones <lamont@debian.org>  Wed,  3 Nov 2004 10:09:43 -0700
+
+util-linux (2.12h-2ubuntu2) hoary; urgency=medium
+
+  * Fix unterminated string in hwclock.sh (thanks, Jones Lee).
+
+ -- Colin Watson <cjwatson@canonical.com>  Tue,  2 Nov 2004 22:29:24 +0000
+
+util-linux (2.12h-2ubuntu1) hoary; urgency=low
+
+  * Re-sync with Debian.
+
+ -- LaMont Jones <lamont@canonical.com>  Sat, 30 Oct 2004 21:14:51 -0600
+
+util-linux (2.12h-2) unstable; urgency=low
+
+  * Cleanup the changelog entry in the uploaded package, to reduce panic.
+
+ -- LaMont Jones <lamont@debian.org>  Sat, 30 Oct 2004 15:38:18 -0600
+
+util-linux (2.12h-1) unstable; urgency=low
+
+  * Even newer upstream... sigh.
+  * Fix copyright file.  Closes: #278925
+
+ -- LaMont Jones <lamont@debian.org>  Sat, 30 Oct 2004 12:56:19 -0600
+
+util-linux (2.12b-1) unstable; urgency=low
+
+  * New upstream.
+
+ -- LaMont Jones <lamont@debian.org>  Fri, 29 Oct 2004 15:40:10 -0600
+
+util-linux (2.12-11) unstable; urgency=low
+
+  * Add amd64 to fdisk.
+  * use absolute path to hwclock in scripts.  Closes: #277780
+  * deal with unaligned partition table entries in fdisk.  Closes: #268119
+
+ -- LaMont Jones <lamont@debian.org>  Fri, 29 Oct 2004 15:05:15 -0600
+
+util-linux (2.12-10) unstable; urgency=low
+
+  * The "SO WHY IS LETTING TWO PROCESSES OPEN THE SAME TTY FOR READ A
+    _GOOD_ THING" Release.
+  * Admit that the kernel API doesn't provide what we need, and turn the code
+    back off.  Discussions will follow on how to deal with this post-sarge.
+    Closes: #272689, Reopens: #216658
+
+ -- LaMont Jones <lamont@debian.org>  Thu, 23 Sep 2004 22:29:09 -0600
+
+util-linux (2.12-9) unstable; urgency=high
+
+  * The I-HATE-LINUX-TTY-HANDLING Release
+  * New and improved tty-in-use check, that actually works.  Closes: #272689
+
+ -- LaMont Jones <lamont@debian.org>  Wed, 22 Sep 2004 12:30:01 -0600
+
+util-linux (2.12-8) unstable; urgency=high
+
+  * Fix tty-in-use check.  Many thanks to Samuel Thibault for tracking this
+    down and providing a patch.  Closes: #226443
+
+ -- LaMont Jones <lamont@debian.org>  Mon, 20 Sep 2004 08:53:42 -0600
+
+util-linux (2.12-7) unstable; urgency=low
+
+  * Have pri= only affect that entry in swapon -a.  Closes: #214407
+  * Mention the freshmeat site.  Closes: #225605
+  * fix disk sun label creation in fdisk.  Closes: #228747
+  * Use a more general form for uname.  Closes: #231477
+  * Provide fdisk-udeb for sparc.  Closes: #228444
+  * Cleanup vty code in getty.  Closes: #224028, #224067, #226443, #229788
+  * Changes from Javier Fernandez-Sanguino Pen~a <jfs@computer.org>
+    - Added amd64 architecture (Closes: #241855)
+    - Fixed manpage to avoid pointing to non existant files (Closes: #234875)
+    - Fixed Theodore Tso's address to the new one in dmesg (Closes: #222106)
+    - Modified cfdisk's es.po in order to not ask for an accented character
+      since it will not be shown in cfdisk and causes confusion amongst
+      users, this change could be reverted when upstream manages
+      8-bit characters better (Closes: #210363, #204162)
+    - mkswap manpage now mentiones --sparece=never option to cp 
+      (Closes: #184492)
+    - Added upstream maintainers to debian/copyright (Closes: #130858)
+ 
+ -- LaMont Jones <lamont@debian.org>  Fri,  6 Feb 2004 14:50:09 -0700
+
+util-linux (2.12-6) unstable; urgency=low
+
+  * Clean up FTBFS isses. Closes: #223149
+  * Deal with hwclock.sh on s390x.  Closes: #216567
+  * Have getty check before opening a device.  Closes: #216658
+
+ -- LaMont Jones <lamont@debian.org>  Sat,  6 Dec 2003 18:42:20 -0700
+
+util-linux (2.12-5) unstable; urgency=low
+
+  * Fix compile error in get_blocks.c.  Closes: #218894
+  * Help out fdisk-udeb.  Closes: #218920
+
+ -- LaMont Jones <lamont@debian.org>  Mon,  3 Nov 2003 15:02:04 -0700
+
+util-linux (2.12-4) unstable; urgency=low
+
+  * Version the build-depends on slang1-utf8-dev to make life clearer for
+    woody backporters... Closes: #211974
+  * Deliver pg.  Closes: #217310
+
+ -- LaMont Jones <lamont@debian.org>  Fri, 24 Oct 2003 19:54:10 -0600
+
+util-linux (2.12-3) unstable; urgency=low
+
+  * Re-add support for kerneli (if cryptoapi is there, we use it.  If not, we assume
+    that -e <name> refers to kerneli).  Closes: #65068, #131044, #163639, #211534.
+
+ -- LaMont Jones <lamont@debian.org>  Fri, 19 Sep 2003 20:42:08 -0600
+
+util-linux (2.12-2) unstable; urgency=low
+
+  * release to unstable.  Closes: #206396,#180353
+
+ -- LaMont Jones <lamont@debian.org>  Tue, 16 Sep 2003 23:07:27 -0600
+
+util-linux (2.12-1) experimental; urgency=low
+
+  * Fix package priorities.
+  * Cleanup cryptoapi patch. (Really just needed the keybits patch.)
+
+ -- LaMont Jones <lamont@debian.org>  Sun, 14 Sep 2003 20:40:56 -0600
+
+util-linux (2.12-0) experimental; urgency=low
+
+  * New upstream release.
+  * cryptoapi patch (sort of) migrated forward, along with code inspired by
+    the patch in #206396.  Still fighting with 2.4.22 crypto api, patches
+    welcome.
+
+ -- LaMont Jones <lamont@debian.org>  Sun, 14 Sep 2003 11:30:17 -0600
+
+util-linux (2.11z-5) unstable; urgency=low
+
+  * Fix mount -p (to make -p an accepted option), and add back in okeybits=
+    to make the natives happy.  Closes: #131863, #197211, #157843
+  * Merge in dependency change from -4.1, and cleanup the dirty diff that
+    brought.  Closes: #200327, #205382, #206621
+  * Was creating invalid swap files.  Closes: #196149, #203528
+  * Fix LSB failures in cal.  Closes: #184885
+  * Fix wall copyright, patch from Shaul Karl.  Closes: #196850
+  * Fix HURD patch.  Closes: #198026
+  * Include cramfs support.  Closes: #207207
+  * Fix configure bug.  Closes: #207227
+  * Create /etc/mtab mode 0600.  Closes: #208860
+  * Fix man page ref to rpc.nfsd(8).  Closes: #165381
+
+ -- LaMont Jones <lamont@debian.org>  Sat,  6 Sep 2003 16:43:20 -0600
+
+util-linux (2.11z-4.1) unstable; urgency=low
+
+  * Non-maintainer upload.
+  * Correct build-depend from slang1-dev to slang1-utf8-dev to get cfdisk in
+    fdisk-udeb to link with the same slang library as the other d-i modules.
+    Patch from Joe Nahmias.  (Closes: #200327, #205382)
+
+ -- Petter Reinholdtsen <pere@debian.org>  Fri,  5 Sep 2003 22:18:21 +0200
+
+util-linux (2.11z-4) unstable; urgency=low
+
+  * Put ddate back in, just to keep the natives quiet.
+
+ -- LaMont Jones <lamont@debian.org>  Wed, 21 May 2003 14:36:14 -0600
+
+util-linux (2.11z-3) unstable; urgency=low
+
+  * Fix bashism in postinst from hurd port.  Closes: #194149
+  * Drop ddate.  Closes: #149321, #174459, #180737
+  * Clean up messages in hwclock.sh.  Closes: #167484
+  * Some package description changes. Closes: #139953
+  * properly install changelog.  Closes: #148714
+  * Fix hwclock man page reference to /usr/local/timezone. Closes: #149996
+
+ -- LaMont Jones <lamont@debian.org>  Wed, 21 May 2003 07:47:41 -0600
+
+util-linux (2.11z-2) unstable; urgency=low
+
+  * add in hurd patch.  Closes: #153410
+  * Actually fixed in 2.11z-1 (or earlier)...  Closes: #81531, #138215, #138388, #185430
+  * Install line.  Closes: #141498
+  * Suggest dosfstools (home of mkfs.vfat).  Closes: #175369
+
+ -- LaMont Jones <lamont@debian.org>  Mon, 19 May 2003 21:17:22 -0600
+
+util-linux (2.11z-1) unstable; urgency=low
+
+  * New upstream version.  Closes: #167967, #127086, #122288
+
+ -- LaMont Jones <lamont@debian.org>  Fri, 21 Mar 2003 14:02:39 -0700
+
+util-linux (2.11y-2) unstable; urgency=low
+
+  * Fix sparc build.  sigh.
+
+ -- LaMont Jones <lamont@debian.org>  Thu, 30 Jan 2003 01:00:28 -0700
+
+util-linux (2.11y-1) unstable; urgency=low
+
+  * New upstream version
+  * don't build fdisk on m68k.  Closes: #170669
+  * Honor HWCLOCKACCESS in hwcolockfirst.sh.  Closes: #127972
+
+ -- LaMont Jones <lamont@debian.org>  Fri,  3 Jan 2003 22:05:53 -0700
+
+util-linux (2.11x-1) unstable; urgency=low
+
+  * New upstream version.  Closes: #163851
+  * Include errno.h where needed.  Closes: #168539
+
+ -- LaMont Jones <lamont@debian.org>  Sun, 24 Nov 2002 12:12:23 -0700
+
+util-linux (2.11u-2) unstable; urgency=low
+
+  * Fix changelog.
+
+ -- LaMont Jones <lamont@debian.org>  Mon,  7 Oct 2002 09:42:22 -0600
+
+util-linux (2.11u-1) unstable; urgency=low
+
+  * New upstream release
+  * Incorporate udeb fix from Tollef Fog Heen.  Closes: #156648
+  * Build fdisk-udeb only where we built fdisk...  Closes: #163461
+
+ -- LaMont Jones <lamont@debian.org>  Sun,  6 Oct 2002 23:31:42 -0600
+
+util-linux (2.11n-4.1) unstable; urgency=low
+
+  * NMU with maintainer's permission
+  * Generate udeb with *fdisk in it.  Closes: 156648
+
+ -- Tollef Fog Heen <tfheen@debian.org>  Sun, 22 Sep 2002 14:44:24 +0200
+
+util-linux (2.11n-4) unstable; urgency=low
+
+  * New maintainer.  Closes: #130842
+  * Fix Standards-Version.  Closes: #97040
+  * Loosen dependency of util-linux-locales to match upstream version.
+
+ -- LaMont Jones <lamont@debian.org>  Sat, 26 Jan 2002 11:21:41 -0700
+
+util-linux (2.11n-3) unstable; urgency=low
+
+  * Orphaned this package.
+
+ -- Adrian Bunk <bunk@fs.tum.de>  Fri, 25 Jan 2002 14:36:06 +0100
+
+util-linux (2.11n-2) unstable; urgency=high
+
+  * Applied a patch to hwclock/cmos.c that should fix the
+    compilation on alpha. (closes: #123357)
+
+ -- Adrian Bunk <bunk@fs.tum.de>  Tue, 11 Dec 2001 12:13:30 +0100
+
+util-linux (2.11n-1) unstable; urgency=high
+
+  * New upstream release.
+    - It's now possible to build pivot_root on all architectures.
+    - The confusing error message in mount is fixed.
+      (closes: #109483)
+    - minix v2 filesystems are now autodetected by mount.
+      (closes: #118092)
+    - tmpfs is now documented in mount (8). (closes: #120930)
+    - s/top/Top/g in ipc.texi. (closes: #117438)
+
+ -- Adrian Bunk <bunk@fs.tum.de>  Mon, 10 Dec 2001 19:46:36 +0100
+
+util-linux (2.11m-1) unstable; urgency=high
+
+  * New upstream release.
+    The following bugs are fixed in this release:
+    - "setterm -foreground default" does work now.
+      (closes: #115447)
+    - "more" on empty files does no longer print junk on powerpc.
+      (closes: #114973)
+    - The entry in the expert menu the option to create a
+      SGI disklabel is now called
+      "create an IRIX (SGI) partition table". (closes: #110277)
+  * debian/rules: "raw" does now compile on m68k.
+  * Remove the special handling for PowerPC/PReP machines from
+    the postinst. (closes: #118367)
+
+ -- Adrian Bunk <bunk@fs.tum.de>  Thu,  8 Nov 2001 22:46:55 +0100
+
+util-linux (2.11l-4) unstable; urgency=high
+
+  * Corrected the bug introduced in the last upload that did let
+    the installation of util-linux fail on powerpc.
+    (closes: 117393)
+  * s/"uname -m"/`uname -m`/ in the postinst of util-linux.
+
+ -- Adrian Bunk <bunk@fs.tum.de>  Sun, 28 Oct 2001 20:11:11 +0100
+
+util-linux (2.11l-3) unstable; urgency=low
+
+  * Don't install debian/tmp/DEBIAN/conffiles on s390 (since
+    there's no longer a hwclock on s390).
+
+ -- Adrian Bunk <bunk@fs.tum.de>  Tue, 23 Oct 2001 20:39:06 +0200
+
+util-linux (2.11l-2) unstable; urgency=low
+
+  * Don't install hwclock on s390. (closes: #115019)
+  * Make the warning in hwclockfirst.sh that occurs when the
+    timezone couldn't be determined more silent.
+    (closes: #116003)
+
+ -- Adrian Bunk <bunk@fs.tum.de>  Sun, 21 Oct 2001 12:50:40 +0200
+
+util-linux (2.11l-1) unstable; urgency=high
+
+  * New upstream release that consists of bug fixes and several
+    security fixes. (closes: #112271)
+    - renice does no longer incorrectly report a priority of 20.
+      (closes: #37348)
+    - Upstream has included the "replay" script written by
+      Joey Hess <joeyh@debian.org>. (closes: #68556)
+  * Added a hwclockfirst.sh script that runs before S20modutils.
+    (closes: #50572)
+
+ -- Adrian Bunk <bunk@fs.tum.de>  Tue,  9 Oct 2001 02:15:34 +0200
+
+util-linux (2.11h-1) unstable; urgency=high
+
+  * New upstream release.
+    - This release contains some fixes in more (1).
+      (closes: #46590)
+  * Don't build pivot_root on ia64 (ia64 has broken kernel
+    headers).
+
+ -- Adrian Bunk <bunk@fs.tum.de>  Fri, 27 Jul 2001 19:20:25 +0200
+
+util-linux (2.11g-4) unstable; urgency=low
+
+  * m68k doesn't has pivot_root, too. (closes: #103812)
+
+ -- Adrian Bunk <bunk@fs.tum.de>  Mon,  9 Jul 2001 23:20:36 +0200
+
+util-linux (2.11g-3) unstable; urgency=low
+
+  * Don't build "raw" on m68k because it doesn't compile.
+    (closes: #103812)
+
+ -- Adrian Bunk <bunk@fs.tum.de>  Sat,  7 Jul 2001 16:48:23 +0200
+
+util-linux (2.11g-2) unstable; urgency=low
+
+  * hwclock.sh does now check $HWCLOCKACCESS. (closes: #87187)
+
+ -- Adrian Bunk <bunk@fs.tum.de>  Fri,  6 Jul 2001 19:35:04 +0200
+
+util-linux (2.11g-1) unstable; urgency=low
+
+  * New upstream release.
+  * fdisk does now know about the partition type of the
+    Linux/PA-RISC boot loader. (closes: #101853)
+
+ -- Adrian Bunk <bunk@fs.tum.de>  Wed, 27 Jun 2001 18:56:34 +0200
+
+util-linux (2.11f-1) unstable; urgency=low
+
+  * New upstream release. Bugs fixed in this release:
+    - Fix for big endian architectures in disk-utils/raw.c.
+      (closes: #100462)
+    - Support for SuperH in mount. (closes: #99804)
+    - The alpha options in hwclock do now work as documented.
+      (closes: #84346)
+    - mount (8) does now mention that the quota utilities do use
+      the *quota options in /etc/fstab. (closes: #98485)
+
+ -- Adrian Bunk <bunk@fs.tum.de>  Sun, 24 Jun 2001 22:11:23 +0200
+
+util-linux (2.11d-1) unstable; urgency=low
+
+  * New upstream release. This release contains fixes for the
+    following bugs:
+    - Different fix for the problems with the "user" option in
+      umount. (closes: #98129)
+    - Support x86 RTC on UltraSPARC III's. (closes: #91774)
+    - An error message in mount is now proper english.
+      (closes: #92198)
+  * Install more.help in /usr/share/util-linux. (closes: #96375)
+  * Updated README.Debian.hwclock.gz. (closes: #76618)
+
+ -- Adrian Bunk <bunk@fs.tum.de>  Thu, 24 May 2001 10:57:43 +0200
+
+util-linux (2.11b-6) unstable; urgency=low
+
+  * Corrected the "charset" in po/nl.po .
+  * Standards-Version: 526.7.8.9.13-Foo.6
+
+ -- Adrian Bunk <bunk@fs.tum.de>  Wed,  9 May 2001 15:54:51 +0200
+
+util-linux (2.11b-5) unstable; urgency=low
+
+  * Made util-linux-locales binary-all.
+
+ -- Adrian Bunk <bunk@fs.tum.de>  Thu, 26 Apr 2001 23:57:45 +0200
+
+util-linux (2.11b-4) unstable; urgency=low
+
+  * Applied a fdisk patch for hppa and added hppa to fdisk_arch in
+    debian/rules. (closes: #92912)
+
+ -- Adrian Bunk <bunk@fs.tum.de>  Sun, 15 Apr 2001 03:01:40 +0200
+
+util-linux (2.11b-3) unstable; urgency=high
+
+  * Fixed the bug in umount that did let a user umount a file system
+    mounted by root when the "user" option is set in /etc/fstab.
+    (closes: #44749)
+  * Corrected a build error on powerpc in debian/rules.
+  * Corrected in util-linux-locales:
+    Section : base -> utils
+    Priority: required -> optional
+  * Added the crypto patch again. (closes: #36939)
+    Fixed in the new crypto patch:
+    - It's now the complete crypto patch. (closes: #55435)
+    - "losetup" no longer lists the available ciphers.
+      (closes: #61425)
+    - It already includes the patch from #68804. (closes: #68804)
+  * Added blockdev to util-linux. (closes: #61488)
+
+ -- Adrian Bunk <bunk@fs.tum.de>  Thu, 12 Apr 2001 19:41:14 +0200
+
+util-linux (2.11b-2) unstable; urgency=low
+
+  * Include pivot_root in util-linux. (closes: #91215)
+  * Added a lintian override for mount and umount.
+
+ -- Adrian Bunk <bunk@fs.tum.de>  Sun, 25 Mar 2001 20:16:39 +0200
+
+util-linux (2.11b-1) unstable; urgency=high
+
+  * New upstream release. This release fixes the following bugs:
+    - the problem with extended partitions when using the "o" command
+      in fdisk is fixed (closes: #45827)
+    - adfs options are now documentated in mount (8) (closes: #79181)
+    - missing .TP in mount (8) was added (closes: #56230)
+  * The locales are now in a seperate util-linux-locales package that
+    is not essential. (closes: #62651)
+  * util-linux "Suggests: kbd | console-tools" to help people to
+    find where "kbdrate" is.
+  * Added support for devfs in rdev. (closes: #74962)
+  * Include the "raw" program in util-linux. (closes: #85695)
+  * Include fdformat again. (closes: #81362)
+  * Moved the "install-info" call from the postrm to the prerm.
+    (closes: #90883)
+  * Install "HOSTORY" as "changelog.gz" in all packages.
+  * Removed the "swapdev" link to "rdev". Upstream says about swapdev:  
+      Nevertheless, all this is ancient junk. I just checked swapdev
+      and found that it was last used in kernel 0.12 but that swapdev
+      (or rdev -s) has not done anything in any kernel later than 0.12.
+
+ -- Adrian Bunk <bunk@fs.tum.de>  Fri, 23 Mar 2001 15:50:23 +0100
+
+util-linux (2.11a-2) unstable; urgency=low
+
+  * Corrected the location of the examples in getopt (1).
+    (closes: #63036)
+  * Added the missing build dependency on gettext.
+  * Added mips, mipsel and ia64 to fdisk_arch in debian/rules.
+
+ -- Adrian Bunk <bunk@fs.tum.de>  Mon, 12 Mar 2001 23:10:03 +0100
+
+util-linux (2.11a-1) unstable; urgency=low
+
+  * New upstream release.
+  * This release contains a fix for an overrun sprintf in mount.
+    (closes: #85739)
+  * A message of cfdisk is less confusing in this release.
+    (closes: #76664)
+  * Don't include a group writable /usr/share/locale/da .
+
+ -- Adrian Bunk <bunk@fs.tum.de>  Sat, 10 Mar 2001 01:41:51 +0100
+
+util-linux (2.11-1) unstable; urgency=low
+
+  * New upstream release.
+  * Upstream removed "kbdrate" from util-linux (it's now in the
+    packages kbd and console-tools).
+    Let util-linux conflict with kbd (<< 1.05-3) and
+    console-tools (<< 1:0.2.3-21) to avoid that a user of these
+    packages has a system without "kbdrate".
+
+ -- Adrian Bunk <bunk@fs.tum.de>  Fri,  9 Mar 2001 19:40:53 +0100
+
+util-linux (2.10s-2) unstable; urgency=low
+
+  * New maintainer. (closes: #86872)
+
+ -- Adrian Bunk <bunk@fs.tum.de>  Wed, 21 Feb 2001 18:21:03 +0100
+
+util-linux (2.10s-1) unstable; urgency=low
+
+  * New upstream release, Closes: #85492
+  * login-utils/wall now checks whether the devices has a colon in it and skips
+    it if it does.  This prevents wall from trying to send to X connectiosn.
+    Closes: #34217
+  * added joeyh's script patch for handling SIGWINCH, Closes: #42497
+  * debian has long been modifying the man page to point at proper file
+    locations, these two bugs were merged with two other bugs that are actually
+    bugs in docs v. reality and so were not getting closed.  unmerged and are
+    now being closed.  Closes: #55500.
+  * DEB_HOST_ARCH is set if not run from within dpkg-buildpackage,
+    Closes: #71978
+  * devfs code now in the upstream, Closes: #72241
+  * upstream fixed the wrong NAME, Closes: #79794
+  * umount knows that mips does not support umount2, Closes: #80386
+  * removed calls to suidregister
+  * orphaning package
+
+ -- Sean 'Shaleh' Perry <shaleh@debian.org>  Mon, 12 Feb 2001 14:43:32 -0800
+
+util-linux (2.10q-1) unstable; urgency=low
+
+  * New upstream release
+  * New maintainer (possibly temporarily) 
+  * I left out the alpha fdisk patch and the crypto patch.  Debian needs to
+    line up with the upstream.  If there is demand, will see what I can do.
+    Closes: #77259, #69717
+  * has patch for autofs from #31251, Closes: #31251
+  * loop mounts leaking seems to have been fixed long ago, Closes: #37063
+  * nfs(5) updated to mention (no)lock option, Closes: #50300
+  * umount sigsegv'ing when user lacks permisions seems to have been fixed
+    long ago, Closes: #54757
+  * FHS transition started in last upload forgot to, Closes: #61287, #66322
+  * umount -f is now documented and tries to be functional, Closes: #62625
+  * for all of those "please update this package" bugs, Closes: #64927, #64416
+  * umount -f seems to work now, I believe it was a kernel issue, Closes: #70484
+  * bsdutils description cleaned, no longer refers to missing binaries,
+    Closes: #63617
+  * Patch rejected by upstream, Closes: #25832
+  * problems with alpha and bsd partitions believed fixed in 2.9w,
+    Closes: #34572
+  * /dev/vcsa patch accepted, Closes: #54204
+  * msglevel fixed by upstream, Closes: #54213
+  * update-mime call seems to have been fixed in previous release,
+    Closes: #55140
+  * looks like user error, Closes: #57757, #58833, #70651
+  * does not look valid any more, Closes: #64226, #67815, #60197
+  * LVM supported in current release, Closes: #67297
+  * forgot to Closes: #69442, when I put elvtune's manpage where it belongs
+  * prerm typo, oops, Closes: #77300
+  * fdformat is just a wrapper, no more confusing messages,
+    Closes: #52364, #53037
+  * hwclock.sh supports a BADYEAR argument from etc/default/rcS.
+  * no longer include example.files, they do not readily apply to debian
+    Closes: #59711
+
+ -- Sean 'Shaleh' Perry <shaleh@debian.org>  Thu, 16 Nov 2000 14:25:50 -0800
+
+util-linux (2.10p-1.0) unstable; urgency=low
+
+  * New upstream release
+  * NMU with maintainer's permission
+  * added Build-Depends, Closes: #75713
+  * upstream added the patch from #36340, so Closes: #36340
+  * upstream put '--More--' back to reverse video, Closes: #55165
+  * hwclock man page points at /usr/share/zoneinfo, not usr/lib
+  * all created packages' postints now sets usr/doc/ symlink, its prerm removes
+    said link
+  * copyright file now points to usr/share/common-licenses and the typo in the
+    URL was fixed (it is misc, not Misc)
+  * update hwclock.sh to reflect FHS changes
+  * debian/rules file brought up to date for FHS
+  * elvtune man page put with the binary
+  * The above changes allow Closes: #69698
+  * edited fr.po, fixed "Nombre de partitions" to "Numero de partition",
+    Closes: #71743
+  * whereis knows that /usr/share/man/* is valid, Closes: #72097
+  * debian/rules now sets SHELL to bash, so it can use bashisms, Closes: #74095
+  * upstream HISTORY file included as changelog.gz, Closes: #63175
+  * removed /etc/fdprm, Closes: #62955
+  * made fdformat a sh script instead of a bash script (the bash was unneeded)
+
+ -- Sean 'Shaleh' Perry <shaleh@debian.org>  Thu,  9 Nov 2000 17:55:10 -0800
+
+util-linux (2.10o-1) unstable; urgency=low
+
+  * New upstream code. Add elvtune.
+    closes: #69166: util-linux package not complete.
+
+ -- Vincent Renardias <vincent@debian.org>  Thu, 17 Aug 2000 18:17:34 +0200
+
+util-linux (2.10n-1) unstable; urgency=low
+
+  * New upstream code.
+    closes: #68976 util-linux needs new upstream version.
+    closes: #64536 util-linux: [PATCH] mkswap refuses to create big swap partitions.
+    closes: #63747 Option parsing bug of 'mkswap' command Debian Package util-linux.
+    closes: #62935 mkswap BUG of option parsing in Debian Package util-linux.
+    closes: #59264 util-linux: mkswap: erroneous option parsing, documentation outdated.
+    closes: #64079 util-linux: mkswap's -v[01] option is broken.
+
+ -- Vincent Renardias <vincent@debian.org>  Sun, 13 Aug 2000 00:54:51 +0200
+
+util-linux (2.10f-5.1) frozen unstable; urgency=low
+
+  * Non-Maintainer Upload
+  * Patch from Ben Collins to fix the -v[01] option in mkswap
+    (closes: #64079)
+  * Patch from Chris Butler to fix hwclock's handling of RTC
+    (closes: #62688)
+  * Change to line 879 of fdiskbsdlabel.c to allow building on sparc
+    (patch sent to maintainer)
+    
+ -- Stephen R. Gore <sgore@debian.org>  Sun, 25 Jun 2000 22:18:47 +0500
+
+util-linux (2.10f-5) frozen unstable; urgency=low
+
+  * Patch from David Huggins-Daines <dhd@linuxcare.com>
+    which is required to get a working fdisk on alpha.
+
+ -- Vincent Renardias <vincent@debian.org>  Mon,  1 May 2000 22:40:17 +0200
+
+util-linux (2.10f-4) unstable; urgency=low
+
+  * Patch for mips support from Florian Lohoff <flo@rfc822.org>.
+    closes: #62247: patch for mips/mipsel and bsddisklabel.
+
+ -- Vincent Renardias <vincent@debian.org>  Wed, 12 Apr 2000 17:26:24 +0200
+
+util-linux (2.10f-3) frozen unstable; urgency=low
+
+  * included patch from David Huggins-Daines <dhuggins@linuxcare.com> so
+    that fdisk behaves correctly with OSF/1 disklabels.
+    closes: #59385: Fixes for BSD disklabel support (for Alpha)
+    (Important bug)
+
+ -- Vincent Renardias <vincent@debian.org>  Thu,  2 Mar 2000 13:21:40 +0100
+
+util-linux (2.10f-2) frozen unstable; urgency=low
+
+  * Now that 2.10f-1 has been tested in unstable, re-upload it to frozen.
+    closes: #54252: cfdisk fails to detect DAC960 partitions. (CRITICAL)
+
+ -- Vincent Renardias <vincent@debian.org>  Sat,  5 Feb 2000 19:05:29 +0100
+
+util-linux (2.10f-1) unstable; urgency=low
+
+  * New upstream release:
+    * Security fix for mount (okir)
+    * Avoid infinite loop in namei (Brett Wuth)
+      closes: #56761: namei segment faults on circular links.
+    * added clock-ppc.c (from Matsuura Takanori), not merged yet
+    * deleted clockB subdirectory
+    * recognize mkdosfs string (Michal Svec)
+    * New: rename
+    * Added option to mkswap so that user can override pagesize
+    * fdisk -l now reads /proc/partitions when no device was given
+      closes: #55614: util-linux: 'fdisk -l' no longer works?.
+    * Fixed fdisk.8 (James Manning)
+    * Added devpts info to mount.8 (Elrond)
+    * Newline fix for logger output to stdout (Henri Spencer)
+
+ -- Vincent Renardias <vincent@debian.org>  Thu,  3 Feb 2000 14:19:33 +0100
+
+util-linux (2.10d-7) frozen unstable; urgency=low
+
+  * There is no real concensus about what we should do about the
+    hwclock issue. Now at least the problem is enough documented
+    to let the user decide. (Thanks to Henrique M Holschuh <hmh+debianml@rcm.org.br>
+    for the patch).
+    When this package is installed, I'll examine one by one which BR can
+    be closed.
+
+ -- Vincent Renardias <vincent@debian.org>  Mon, 31 Jan 2000 14:34:03 +0100
+
+util-linux (2.10d-6) frozen unstable; urgency=low
+
+  * kbdrate isn't suid anymore.
+    closes: #54978: ordinary user can change keyboard repeat vor all users.
+
+ -- Vincent Renardias <vincent@debian.org>  Fri, 28 Jan 2000 16:52:27 +0100
+
+util-linux (2.10d-5) unstable; urgency=low
+
+  * Included patch from "J.H.M. Dassen (Ray)" <jhm@cistron.nl>:
+    - Restored enhanced losetup(8) manpage.
+    - Restored encrypted filesystem support, by applying util-linux-2.9w from 
+      patch-int-2.2.13.3.gz as found on ftp.kerneli.org (modified to work with 
+      Debian's kernel-patch-int's crypto.h).
+    (closes: #54657)
+  * Recompiled with ncurses5.
+
+ -- Vincent Renardias <vincent@debian.org>  Wed, 12 Jan 2000 12:24:12 +0100
+
+util-linux (2.10d-4) unstable; urgency=low
+
+  * ipcrm now accepts multiple ids thanks to a patch from Topi Miettinen.
+    closes: #15110: ipcrm doesn't work with xargs.
+  * fix postinst script:
+    closes: #53254: util-linux: ppc chunk of postinst script has syntactical error.
+
+ -- Vincent Renardias <vincent@debian.org>  Wed, 22 Dec 1999 17:24:46 +0100
+
+util-linux (2.10d-3) unstable; urgency=low
+
+  * Disabled 'hwclock --adjust' on boot.
+    closes: #37657: util-linux: hwclock --systohc dangerous.
+    closes: #40283: util-linux: hwclock --systohc dangerous.
+    closes: #41263: hwclock --adjust doesn't work (temporary fix included).
+    closes: #51805: /etc/adjtime.
+    closes: #35432: "/etc/init.d/hwclock.sh" possible bug.
+    closes: #43228: Clock taking advance in potato.
+
+ -- Vincent Renardias <vincent@debian.org>  Mon, 20 Dec 1999 13:55:21 +0100
+
+util-linux (2.10d-2) unstable; urgency=low
+
+  * cfdisk must be build with slang; not ncurses.
+    closes: #52559: cfdisk linked against libncurses instead of slang.
+
+ -- Vincent Renardias <vincent@debian.org>  Fri, 10 Dec 1999 11:21:36 +0100
+
+util-linux (2.10d-1) unstable; urgency=low
+
+  * New upstream release.
+    closes: #52151: mount: mount/umount infinite loop on stale lockfiles.
+  * Put renice manpage in section 1 instead of 8.
+    closes: #52370: bsdutils: wrong section for renice manpage.
+  * kbdrate's PAM now uses pam_unix.so by default.
+    closes: #51273: util-linux: uses pam_pwdb for kbdrate.
+  * already fixed in 2.10-5:
+    closes: #49823: name conflict.
+
+ -- Vincent Renardias <vincent@debian.org>  Fri, 10 Dec 1999 11:21:36 +0100
+
+util-linux (2.10-6) unstable; urgency=low
+
+  * Patch by Topi Miettinen <Topi.Miettinen@nic.fi> to a longstanding
+    bug in logger. closes: #19666.
+
+ -- Vincent Renardias <vincent@debian.org>  Mon,  6 Dec 1999 11:49:10 +0100
+
+util-linux (2.10-5) unstable; urgency=low
+
+  * replace fdformat by a notice asking to use superformat instead.
+  * remove setfdprm; closes: #44941.
+
+ -- Vincent Renardias <vincent@debian.org>  Mon,  6 Dec 1999 11:49:10 +0100
+
+util-linux (2.10-4) unstable; urgency=low
+
+  * conflict/replace with fdisk on sparc.
+    closes: #50254: please conflict and replace fdisk on sparc.
+
+ -- Vincent Renardias <vincent@debian.org>  Mon, 15 Nov 1999 17:28:00 +0100
+
+util-linux (2.10-3) unstable; urgency=low
+
+  * re-introduce missing c?fdisk... (oops ;)
+    closes: #49406, #49457, #49337, #49313, #46732.
+
+ -- Vincent Renardias <vincent@debian.org>  Mon,  8 Nov 1999 13:01:12 +0100
+
+util-linux (2.10-2) unstable; urgency=low
+
+  * Do TheRightThing(tm) for bug #47219.
+  * from NMU prepared by Torsten Landschoff <torsten@debian.org>:
+    * Fixed case expression in hwclock.sh
+      (closes: #42431, #42435, #42856).
+    * Added usage information to hwclock (closes: #23184).
+    * Upstream has long changed mount.c to handle nouser properly
+      (closes: #24954, #24956).
+    * Excluded clock.8 link from powerpc build (closes: #46010).
+    * Replaced "$(shell dpkg --print-architecture)" with
+      "$DEB_HOST_ARCH" in debian/rules.
+
+ -- Vincent Renardias <vincent@debian.org>  Thu,  4 Nov 1999 10:53:37 +0100
+
+util-linux (2.10-1) unstable; urgency=low
+
+  * New upstream release.
+  * make /etc/rc{0,6}.d/*hwclock.sh correctly.
+    closes: #47111: util-linux: hwclock.sh: wrong names on rc*.d links.
+    closes: #47373: hwclock.sh links are wrong.
+  * Correct kdbrate pam entry.
+    closes: #45674: kbdrate PAM config references missing pam_console.so.
+  * Fix fdiskdsblabel.h.
+    closes: #47219: util-linux: errors compiling on sparc.
+  * Use jgg's patch for hwclock.sh
+    closes: #43793: Support for both GMT and UTC default/rc.S setting is wrong.
+  * Really link kbdrate with pam.
+    closes: #48425: pam support for kbdrate useless.
+
+ -- Vincent Renardias <vincent@debian.org>  Wed,  3 Nov 1999 11:41:44 +0100
+
+util-linux (2.9x-1) unstable; urgency=low
+
+  * New upstream release.
+    closes: #32916: hwclock freezes m68k system.
+    closes: #44986: util-linux: PAM support for kbdrate.
+    closes: #44821: util-linux: pam.d entry contains a path.
+    closes: #44727: util-linux: sfdisk examples are present twice in the package.
+    closes: #45565: removed /bin/kill. this is now provided by procps.
+    closes: #36332: problems with our /bin/kill.
+    closes: #41171: wall should be sgid tty, not root.
+
+ -- Vincent Renardias <vincent@debian.org>  Tue, 21 Sep 1999 17:54:47 +0200
+
+util-linux (2.9w-3) unstable; urgency=low
+
+  * Include PowerPC patch from Matt Porter <mporter@phx.mcd.mot.com>.
+  * Should be 100% PAMified(tm). Please report anomalies.
+
+ -- Vincent Renardias <vincent@debian.org>  Tue,  7 Sep 1999 18:53:37 +0200
+
+util-linux (2.9w-2) unstable; urgency=low
+
+  * updated losetup.8 from "J.H.M. Dassen (Ray)" <jdassen@wi.LeidenUniv.nl>.
+
+ -- Vincent Renardias <vincent@debian.org>  Tue, 24 Aug 1999 17:44:06 +0200
+
+util-linux (2.9w-1) unstable; urgency=low
+
+  * Upstream upgrade:
+      util-linux 2.9w:
+      * Updated mount.8 (Yann Droneaud)
+      * Improved makefiles
+      * Fixed flaw in fdisk
+      util-linux 2.9v:
+      * cfdisk no longer believes the kernel's HDGETGEO
+        (and may be able to partition a 2 TB disk)
+      util-linux 2.9u:
+      * Czech more.help and messages (Jii Pavlovsky)
+      * Japanese messages (Daisuke Yamashita)
+      * fdisk fix (Klaus G. Wagner)
+      * mount fix (Hirokazu Takahashi)
+      * agetty: enable hardware flow control (Thorsten Kranzkowski)
+      * minor cfdisk improvements
+      * fdisk no longer accepts a default device
+      * Makefile fix
+  * now uses the script(1) supplied with util-linux instead
+    of the one from the old bsdutils package.
+  * remove alpha specific build patch:
+    closes: #41256.
+  * remove useless warning in preinst.
+
+ -- Vincent Renardias <vincent@debian.org>  Tue, 24 Aug 1999 17:44:06 +0200
+
+util-linux (2.9t-3) unstable; urgency=low
+
+  * include missing fdformat, setfdprm. (How comes nobody noticed yet?!)
+  * recompile against slang1-dev 1.2.2-3.
+
+ -- Vincent Renardias <vincent@debian.org>  Tue, 24 Aug 1999 09:23:59 +0200
+
+util-linux (2.9t-2) unstable; urgency=low
+
+  * correct hwclock.sh;
+    closes: #35429 sysvinit: bad comments in /etc/defaults/rcS.
+
+ -- Vincent Renardias <vincent@debian.org>  Wed, 28 Jul 1999 18:43:05 +0200
+
+util-linux (2.9t-1.1) unstable; urgency=low
+
+  * Non-maintainer upload.
+  * Applied util-linux-2.9s.patch from patch-int-2.2.10.4.gz as found on
+    ftp.kerneli.org to enable support for mounting encrypted filesystems
+    through the loopback devices when using an international kernel.
+    (Fixes: Bug#36939, #38371)
+  * Include <linux/loop.h> and <linux/crypto.h> in the source, so as not to
+    rely on source outside main.
+  * Updated the losetup(8) manpage.
+
+ -- J.H.M. Dassen (Ray) <jdassen@wi.LeidenUniv.nl>  Thu, 22 Jul 1999 18:32:16 +0200
+
+util-linux (2.9t-1) unstable; urgency=low
+
+  * Upstream upgrade:
+    * national language support for hwclock
+    * Japanese messages (both by Daisuke Yamashita)
+    * German messages and some misc i18n fixes (Elrond)
+    * Czech messages (Jii Pavlovsky)
+    * wall fixed for /dev/pts/xx ttys
+    * make last and wall use getutent() (Sascha Schumann)
+      [Maybe this is bad: last reading all of wtmp may be too slow.
+       Revert in case people complain.]
+    * documented UUID= and LABEL= in fstab.5
+    * added some partition types
+    * swapon: warn only if verbose
+    closes: #37008: de.po file integrated upstream.
+    closes: #37380: it.po file integrated upstream.
+    closes: #38232: patch integrated upstream.
+    closes: #36124: examples included.
+    closes: #36848, #37153, #38101, #38416: pts bug fixed upstream.
+    closes: #40868: use suidregister /usr/bin/wall.
+    closes: #34728: patch integrated upstream.
+    closes: #38219: typo. fixed; patch sent upstream.
+    closes: #37585: bug corrected upstream.
+    closes: #37002: CRLF fstab isn't a problem anymore.
+  * changed hwclock.sh to get rid of a lintian error.
+
+ -- Vincent Renardias <vincent@debian.org>  Fri,  9 Jul 1999 16:15:01 +0200
+
+util-linux (2.9r-3) unstable; urgency=low
+
+  * Added missing *.gmo files
+  * Re-add Harmut's powerpc patch that somehow got left out (closes: #37973).
+
+ -- Vincent Renardias <vincent@debian.org>  Wed, 19 May 1999 12:45:09 +0200
+
+util-linux (2.9r-2) unstable; urgency=low
+
+  * Fix stupid bug #37916.
+
+ -- Vincent Renardias <vincent@debian.org>  Tue, 18 May 1999 15:51:08 +0200
+
+util-linux (2.9r-1) unstable; urgency=low
+
+  * Upstream upgrade.
+  * Now compiled with PAM=yes.
+  * initial .it localisation.
+  * Improved .fr translation.
+  * corrected hwclock.sh (reassigned #35429 back to sysvinit).
+  * put rev into /usr/bin instead of /usr/sbin (Fix #34188,#35421).
+  * include getopt examples (Fix #34705).
+
+ -- Vincent Renardias <vincent@debian.org>  Fri, 14 May 1999 16:21:44 +0200
+
+util-linux (2.9i-1) unstable; urgency=low
+
+  * Upstream upgrade.
+  * This source package now also provides the 'bsdutils' binary
+    package.
+  * Included patch for logger.1 from and1000@debian.org.
+  * Included patch to logger.c from Joey (closes: #32109).
+  * renice.c: include <errno.h> (closes: #31288).
+  * re-use script(1) from the 'old' bsdutils package as well
+    as README.script (closes: #988).
+  * Now umount is compiled with '-f' support (closes: #33147).
+  * Re-add suidregister support for mount (closes: #32495).
+
+ -- Vincent Renardias <vincent@debian.org>  Sun, 21 Feb 1999 20:16:20 +0100
+
+util-linux (2.9g-6) frozen unstable; urgency=low
+
+  * modify mount.8 manpage to warn that nosuid is useless
+    if something like suidperl is installed.
+    (doesn't fix the critical bug #31980 reported on suidperl,
+    but at least warn about its existance)
+  * add missing manpages (ramsize,rootflags,swapdev)
+  * #32414: changed a 'rm' into 'rm -f' so the source
+    package builds cleanly.
+  * also target the upload for frozen since this is the only missing
+    package to be able to safely use kernels 2.2.x:
+    To the FTP/Release maintainers:
+      util-linux_2.9g has been introduced in unstable on Dec, 31st 98;
+      so far I received no bug reports about it except for the missing
+      manpages. Also compared to the 2.7.1 version from frozen, this
+      package fixes _57_ bugs. (see www.debian.org/Bugs/db/pa/lutil-linux.html)
+
+ -- Vincent Renardias <vincent@waw.com>  Tue, 26 Jan 1999 23:51:57 +0100
+
+util-linux (2.9g-5) unstable; urgency=low
+
+  * Fix bug #31981.
+  * Localised cfdisk + provided initial French translation.
+    New translations welcome; you can get the potfile at
+    http://www.ldsol.com/~vincent/util-linux.pot
+
+ -- Vincent Renardias <vincent@waw.com>  Sat, 23 Jan 1999 21:55:06 +0100
+
+util-linux (2.9g-4) unstable; urgency=low
+
+  * Add rev and readprofile commands.
+  * Updated fstab.5 regarding spaces in mount points names.
+  * Fix bugs #32235,#31997 (missing hwclock.8 manpage).
+  * Fix bug #32097 (missing mkswap.8 manpage).
+  * Improve somewhat cfdisk regarding exit codes thanks to
+    Enrique's patch (#31607).
+
+ -- Vincent Renardias <vincent@waw.com>  Fri, 22 Jan 1999 19:13:25 +0100
+
+util-linux (2.9g-3) unstable; urgency=low
+
+  * Include patch from Hartmut Koptein for better powerpc support.
+
+ -- Vincent Renardias <vincent@waw.com>  Wed, 13 Jan 1999 22:46:04 +0100
+
+util-linux (2.9g-2) unstable; urgency=high
+
+  * Patch from Topi Miettinen (Thanks Topi ;) to fix
+    bug #31554,#31573.
+
+ -- Vincent Renardias <vincent@waw.com>  Mon, 11 Jan 1999 03:59:19 +0100
+
+util-linux (2.9g-1) unstable; urgency=high
+
+  * Adopting the package from Guy Maor.
+  * Re-add hwclock & kbdrate which had been lost
+    (Fix bug #31476).
+
+ -- Vincent Renardias <vincent@waw.com>  Fri,  1 Jan 1999 19:53:33 +0100
+
+util-linux (2.9g-0.3) unstable; urgency=high
+
+  * YA NMU.
+  * Split mount out into separate package so as not to
+    force the dangerous replacement of an essential package.
+
+ -- Joel Klecker <espy@debian.org>  Sun,  3 Jan 1999 19:00:31 -0800
+
+util-linux (2.9g-0.2) unstable; urgency=low
+
+  * NMU (Part II): Fix more problems in 'mount'.
+  * swapon now warn if swap device has insecure mode;
+    Patch from Topi Miettinen <tom@medialab.sonera.net>
+    (Fix bug #23249).
+  * mount can now handle multiple hostnames for NFS mounts
+    in fstab (Fix bug #29309).
+  * Do'h; add missing /sbin/swapoff ;).
+
+ -- Vincent Renardias <vincent@waw.com>  Fri,  1 Jan 1999 19:53:33 +0100
+
+util-linux (2.9g-0.1) unstable; urgency=low
+
+  * NMU.
+  * This package now provides /bin/mount & co. and thus
+    obsoletes the mount package.
+  * provides the ddate command (Fix bugs #30015 & #19820).
+  * Move wtmp lockfile from /etc to /var/lock
+    (Fix bug #29128).
+  * Set bug #28885 to 'fixed' (this-is-not-a-bug,-but-a-feature(tm)).
+  * Set bug #27931 to 'fixed' (works again since version 2.8).
+  * Set bug #27723 to 'fixed' (been fixed by the ARM NMU).
+  * Set bug #25831 to 'fixed' (hwclock now works as advertised).
+  * Set buffering off on the output channel in chkdupexe.pl
+    (Fix bug #22839).
+  * Include patch for powerpc build by Joel Klecker <jk@espy.org>
+    (Fix bug #21374).
+  * Removed the confusing references to agetty (Fix bug #20668).
+  * Check the result for the malloc()s added in the code to chown
+    vcsa to root.sys (Fix bug #18696).
+  * Include patch for sparc build by
+    Eric Delaunay <delaunay@lix.polytechnique.fr> (Fix bug #17784).
+  * Set bug #17752 to 'fixed' (Appear to work with current versions
+    of xvt and /bin/more).
+  * Include patch for alpha build by
+    Christopher C Chimelis <chris@classnet.med.miami.edu>
+    (Fix bug #17661).
+  * Patch mkfs.minix doesn't go into infinate loop any more depending
+    on the argument passed to -i (Fix bug #17648).
+  * Set bug #17483 to 'fixed' (now that util-linux is compiled with
+    libc6 > =2.0.6 it should be fixed).
+  * Set bug #26625 to 'fixed' (this patch has already been applied).
+  * Applied patch from Bcwhite to get mime support
+    (Fix bug #26715).
+  * Applied patch from Topi Miettinen <tom@medialab.sonera.net>:
+      POSIX etc fixes:
+      - ioctl(.., TCSETSF,..) -> tcsetattr()
+      - ioctl(.., TCGETS,..) -> tcgetattr()
+      - ioctl(.., TIOCGPGRP,..) -> tcgetpgprp()
+      - gcc -Wall warning fixes
+      - write(2, ..) -> write(fileno(stderr), ..)
+      - vi -> sensible-editor
+      - added setlocale(LC_ALL, "")
+      - use perror, isdigit, isprint, iscntrl where applicable
+      - execv -> execvp
+      - added simple ELF detection
+      OpenBSD fixes:
+      - UCB fix
+      - POSIX: rindex -> strrchr
+      - obsolete fseek flag L_SET -> SEEK_SET
+      - control-F == f
+      - $EDITOR support
+    (Fix bug #27635). 
+  * Link clock.8.gz to hwclock.8.gz (Fix bug #25852).
+
+ -- Vincent Renardias <vincent@waw.com>  Thu, 31 Dec 1998 23:48:42 +0100
+
+util-linux (2.9e-0.4) unstable; urgency=high
+
+  * Non-maintainer upload.
+  * Recompiled with slang1.
+
+ -- James Troup <james@nocrew.org>  Sat, 19 Dec 1998 20:42:52 +0000
+
+util-linux (2.9e-0.3) unstable; urgency=low
+
+  * Non-maintainer upload
+  * Include /etc/init.d/hwclock.sh
+  * Fix some of the (pre|post)(inst|rm) script wrt $1 processing
+    Fixes:
+    #18007: sysvinit: hwclock.sh uses GMT env variable - but how?
+    #26904: hwclock.sh doesn't "test -x"
+    #24649: [Peter Kundrat <kundrat@gic.sk>] hwclock startup script
+    #20728: util-linux: hwlock: GMT status lost?
+    #19248: util-linux should install /etc/init.d/hwclock.sh
+
+ -- Miquel van Smoorenburg <miquels@cistron.nl>  Thu, 17 Dec 1998 13:56:45 +0100
+
+util-linux (2.9e-0.2) unstable; urgency=low
+
+  * NMU: Added ARM architecture in 'disk-utils/fdiskbsdlabel.h' and
+    'disk-utils/fdiskbsdlabel.c'.
+  * Removed '-m3' flag from arm-specific optimizations in MCONFIG.
+
+ -- Tor Slettnes <tor@slett.net>  Sun, 29 Nov 1998 01:20:13 -0800
+
+util-linux (2.9e-0.1) unstable; urgency=low
+
+  * Non-maintainer upload - new 2GB swap areas, removed hostid
+  * upstream uses fixed more.c (line 813 had *p++)
+
+ -- Adrian Bridgett <bridgett@debian.org>  Sat, 21 Nov 1998 17:35:35 +0000
+
+util-linux (2.7.1-3.1) frozen unstable; urgency=low
+
+  * Non-maintainer upload
+  * recompiled with slang1 and ncurses4
+
+ -- Joseph Carter <knghtbrd@debian.org>  Sun, 25 Oct 1998 21:48:16 -0800
+
+util-linux (2.7.1-3) unstable; urgency=low
+
+  * Another m68k patch from Roman Hodek
+    <rnhodek@faui22c.informatik.uni-erlangen.de>
+  * fdisk patch from Russell Coker <rjc@snoopy.virtual.net.au> for better
+    behavior on IDE CD's when HDIO_GETGEO fails.
+  * fix getopt(1) typo. (16227)
+  * Use slang for cfdisk.
+  * fdisk -l tries eda also (13841).
+  * Fix fdisk -l segfaults (15236,15603).
+  * Install rdev on only i386 (15228).
+  * Don't strip perl script (15480).
+  * Add type 17=Hidden IFS to cfdisk (16843).
+    
+ -- Guy Maor <maor@ece.utexas.edu>  Sun, 11 Jan 1998 17:20:23 -0800
+
+util-linux (2.7.1-2) unstable; urgency=low
+
+  * Removed sync (13291).
+  * Added m68k hwclock patches from Roman Hodek (9870).
+  * agetty.c: set vcs,vcsa to root.sys 600 when starting.
+
+ -- Guy Maor <maor@ece.utexas.edu>  Thu, 25 Sep 1997 16:51:34 -0500
+
+util-linux (2.7.1-1) unstable; urgency=low
+
+  * libc6 compile of new upstream version (10098, 11744, 13123).
+  * Updated cfdisk to cfdisk 0.8k
+  * Added old patches; I'll send them upstream.
+  	* fdisk - extended paritions, exit on EOF.
+  	* mkfs - fix search paths.
+  	* mkfs.minix - set owner of root dir to invoker.
+  	* chkdupexe - remove upstream brokenness by checking PATH too.
+  	* mcookie - fix man page
+  	* whereis - fix search paths, find .gz files.
+  	* sync - put it back (doh!)
+  * Folded in getty:
+  	* glibc patch (8815, 11687, 12738).
+  	* Set tty to 660 root.dialout (8960).
+  * Register pager alternative (12475).
+    
+ -- Guy Maor <maor@ece.utexas.edu>  Mon, 22 Sep 1997 18:29:53 -0500
+
+util-linux (2.5-12) frozen unstable; urgency=low
+
+  * Updated cfdisk to ftp.win.tue.nl:/pub/linux/util/cfdisk-0.8i.tar.gz
+
+ -- Guy Maor <maor@ece.utexas.edu>  Tue, 6 May 1997 15:29:56 -0500
+
+util-linux (2.5-11) frozen unstable; urgency=medium
+
+  * Updated cfdisk to ftp.win.tue.nl:/pub/linux/util/cfdisk-0.8g.tar.gz (#9146)
+  * -i from 2.5-9 removed as no longer needed.
+
+ -- Guy Maor <maor@ece.utexas.edu>  Tue, 29 Apr 1997 13:40:26 -0500
+
+util-linux (2.5-10) frozen unstable; urgency=medium
+
+  * cfdisk: really fixed cast this time so should be able to deal with
+    >2GB disks(#6747, #8041)
+  * fdisk, cfdisk: Added partition id 0xa6 = OpenBSD (#7571)
+  * setterm: use putp to output (#7852)
+  * Removed miscutils removal trick as it no longer works (#5757, #6862)
+  * mkfs.minix: added patch from Volker Leiendecker <volker@fsing.uni-sb.de>
+    to set owner of root directory to invoker (like mkfs.ext2). (#6902)
+  * Fix dpkg-shlibddeps rules line for m68k (#5818)
+
+ -- Guy Maor <maor@ece.utexas.edu>  Thu, 27 Mar 1997 13:04:35 -0600
+
+util-linux (2.5-9) frozen unstable; urgency=low
+
+  * Add undocumented "-i" flag to ignore bad partition tables when starting
+    instead of throwing a fatal error. Let's pass this to the upstream
+    maintainer, please.
+
+ -- Bruce Perens <bruce@pixar.com>  Fri, 6 Dec 1996 22:12:31 -0800
+
+util-linux (2.5-8) frozen unstable; urgency=low
+
+  * disk-utils/cfdisk.c: cast sector number to ext2_loff_t in calls to
+    ext2_llseek()
+  
+ -- Guy Maor <maor@ece.utexas.edu>  Sat, 23 Nov 1996 23:07:59 -0600
+
+util-linux (2.5-7) unstable; urgency=low
+
+  * sys-utils/clock.c: fixed bug on machines without RTC enabled.
+  * sys-utils/whereis.c: better path, compare function.
+  * Install whereis, cytune, setsid.
+
+ -- Guy Maor <maor@ece.utexas.edu>  Fri, 27 Sep 1996 23:02:09 -0500
+
+util-linux (2.5-6) unstable; urgency=low
+
+  * sys-utils/clock.c: Fixed bugs when real-time clock device is enabled
+    in kernel.
+  * New source format.
+
+ -- Guy Maor <maor@ece.utexas.edu>  Tue, 3 Sep 1996 14:25:31 -0500
+
+util-linux (2.5-5) unstable; urgency=low
+
+  * disk-utils/fdisk.c: Added type a7 = NEXTSTEP (fixes bug 3259)
+  * fdisk.c,cfdisk.c: Applied patch from Miquel van Smoorenburg
+    <miquels@Q.cistron.nl> to let fdisk and cfdisk support Linux
+    extended partitions.
+  * Applied patch from Frank Neumann
+    <Frank.Neumann@Informatik.Uni-Oldenburg.DE> for Linux/m68k
+    support.
+  * Install mkcookie.
+  * disk-utils/mkfs.minix: fixed bug 3777 re parsing oddities.
+
+ -- Guy Maor <maor@ece.utexas.edu>  Tue, 20 Aug 1996 16:21:21 -0500
+
+util-linux (2.5-4) unstable; urgency=low
+
+  * misc-utils/setterm.c (tc_entry): Applied patch from Michael
+    Nonweiler <mrn20@hermes.cam.ac.uk> to make it work with ncurses.
+  * misc-utils/chkdupexe.pl: Fixed some bugs with duplicate path
+    and symbolic links.  Put in a better value for exedirs.
+  * Install chkdupexe, setterm.
+
+ -- Guy Maor <maor@ece.utexas.edu>  Wed, 05 Jun 1996 08:44:25 -0500
+
+util-linux (2.5-3) unstable; urgency=low
+
+  * text-utils/more.c (getline): more now handles files with lines ending
+    with "\r\n".  Fixes Bug #2579.
+  * Added 'priority: required'
+
+ -- Guy Maor <maor@ece.utexas.edu>  Thu, 25 Apr 1996 04:55:22 -0500
+
+util-linux (2.5-2) unstable; urgency=low
+
+  * disk-utils/fdisk.c (read_line): EOF now exits instead of looping
+    forever.  Fixes Bug #1206.
+  * Added 'section: base'
+
+ -- Guy Maor <maor@ece.utexas.edu>  Fri, 19 Apr 1996 05:13:09 -0500
+
+util-linux (2.5-1) unstable; urgency=low
+
+  * Initial release
+
+ -- Guy Maor <maor@ece.utexas.edu>  Thu, 18 Apr 1996 04:32:22 -0500
+
+
--- util-linux-2.12r.orig/debian/changelog.Debian-mount.old
+++ util-linux-2.12r/debian/changelog.Debian-mount.old
@@ -0,0 +1,168 @@
+mount (2.8a-1.2) frozen unstable; urgency=low
+
+  * Non-maintainer upload.
+  * Update lineno when reading fstab
+  * Cope with systems that don't have a newline on the last line of
+    /etc/fstab (Fixes#29282)
+
+ -- Anthony Towns <ajt@debian.org>  Wed, 11 Nov 1998 23:53:24 +1000
+
+mount (2.8a-1.1) unstable; urgency=low
+
+  * Non-maintainer upload with permision by Vincent
+  * Fixed wrong while loop that caused too many lines to be ignored.  The
+    code for the whole condition is generated with all variables replaced
+    by their values as they were when the condition was entered.  This
+    means that if one uses variable assignments, the variable to which a
+    new value was assigned still contains the old value later in the same
+    condition.  Thanks to Peter Moulder <reiter@netspace.net.au (fixes:
+    Bug#27421)
+  * Applied patch by James Troup <james@nocrew.org> that prevents mount
+    from crashing when an empty argument list is used with `-t'.  (fixes:
+    Bug#27130)
+
+ -- Martin Schulze <joey@finlandia.infodrom.north.de>  Wed, 14 Oct 1998 23:11:14 +0200
+
+mount (2.8a-1) unstable; urgency=low
+
+  * New upstream version (Bug #26686).
+
+ -- Vincent Renardias <vincent@waw.com>  Wed, 23 Sep 1998 18:05:44 +0200
+
+mount (2.7l-5) frozen unstable; urgency=low
+
+  * Applied Roman Hodek's patch so the package now builds with stock libc6-dev
+    (This patch seems badly needed by m68k folks)
+    Fix bugs #22037, #14767, #15341, #22037.
+
+ -- Vincent Renardias <vincent@waw.com>  Mon,  8 Jun 1998 17:08:52 +0200
+
+mount (2.7l-4) unstable; urgency=low
+
+  * Fix to allow compilation on sparc
+    (Bug #21510, patch from Eric Delaunay <delaunay@lix.polytechnique.fr>)
+
+ -- Vincent Renardias <vincent@waw.com>  Thu, 23 Apr 1998 20:26:49 +0200
+
+mount (2.7l-3) unstable; urgency=low
+
+  * updated swapon(8) manpage.
+
+ -- Vincent Renardias <vincent@waw.com>  Fri, 17 Apr 1998 01:56:43 +0200
+
+mount (2.7l-2) unstable; urgency=low
+
+  * Update to debian std 2.4.0.0.
+  * Corrected snafu with md5sums (Bugs #19369, #18682).
+
+ -- Vincent Renardias <vincent@waw.com>  Sat, 14 Mar 1998 18:33:02 +0100
+
+mount (2.7l-1) unstable; urgency=low
+
+  * New upstream release (Bug #17745, Said to fix #17523).
+  * Apply the usual patches to get it to compile under libc6 *sigh*.
+  * Removed dependency on libc6 (already Pre-Depends:): Bug #18245.
+  * Remove doubled example in example fstab (Bug #16889).
+
+ -- Vincent Renardias <vincent@waw.com>  Tue, 17 Feb 1998 20:10:55 +0100
+
+mount (2.7g-2) unstable; urgency=low
+
+  * Recompile with kernel 2.0.32 headers so the option noatime works
+    (Bug #15304).
+  * compress changelog.Debian (Bug #15430).
+
+ -- Vincent Renardias <vincent@waw.com>  Thu, 18 Dec 1997 04:39:22 +0100
+
+mount (2.7g-1) unstable; urgency=low
+
+  * New upstream version:
+    - 'mount -aF': This will do the mounts on different devices
+       or different NFS servers in parallel.  (Fix Bug #?????)
+  * mount.c: patch to get it compile with DO_PS_FIDDLING.
+  * patch to get 'swapon -s' error messages more explicit.
+  * improved debian/rules cleanup rule.
+
+ -- Vincent Renardias <vincent@waw.com>  Sat, 13 Dec 1997 17:53:46 +0100
+
+mount (2.7f-1) unstable; urgency=low
+
+  * New upstream version (Bug #14585).
+  * Corrected documentation buglet (Bugs #13050, #14015).
+
+ -- Vincent Renardias <vincent@waw.com>  Sun, 9 Nov 1997 03:50:27 +0100
+
+mount (2.6g-2) unstable; urgency=low
+
+  * Rebuilt with libc6.
+
+ -- Vincent Renardias <vincent@waw.com>  Sat, 21 Jun 1997 17:26:47 +0200
+
+mount (2.6g-1) unstable; urgency=low
+
+  * Upstream upgrade.
+
+ -- Vincent Renardias <vincent@waw.com>  Thu, 1 May 1997 13:50:09 +0200
+
+mount (2.6d-2) unstable; urgency=low
+
+  * Included Patch from M. Dorman for glibc support (Bug #8810).
+
+ -- Vincent Renardias <vincent@waw.com>  Fri, 18 Apr 1997 20:40:17 +0200
+
+mount (2.6d-1) unstable; urgency=low
+
+  * New upstream source
+    (includes the patch I made to fix Bug #4289)
+
+ -- Vincent Renardias <vincent@waw.com>  Sat, 8 Mar 1997 23:29:53 +0100
+
+mount (2.6c-0.1) unstable; urgency=low
+
+  * Patched swapon.c to fix bug #4289:
+    'swapon -s' now gives a summary of mounted partitions.
+
+ -- Vincent Renardias <vincent@waw.com>  Tue, 18 Feb 1997 04:05:31 +0100
+
+mount (2.6c-0) unstable; urgency=low
+
+  * Upstream upgrade requested to author to fix bug #5498.
+  * it also appears to fix bug #7428, cool...
+
+ -- Vincent Renardias <vincent@waw.com>  Tue, 18 Feb 1997 02:22:11 +0100
+
+mount (2.6b-0.1) unstable; urgency=low
+
+  * Added 'Essential: yes' into debian/control.
+
+ -- Vincent Renardias <vincent@waw.com>  Sun, 16 Feb 1997 07:53:36 +0100
+
+mount (2.6b-0) unstable; urgency=low
+
+  * Upstream upgrade.
+  * Now users can umount user mounts (Fixes bug #3993).
+
+ -- Vincent Renardias <vincent@waw.com>  Sun, 16 Feb 1997 00:26:22 +0100
+
+mount (2.5p-1.2) unstable; urgency=low
+
+  * Corrected source package (Can now be extracted with
+    'dpkg-source -x').
+  * Changed 'Depends' into 'Pre-depends' on libc5.
+
+ -- Vincent Renardias <vincent@waw.com>  Sat, 15 Feb 1997 22:31:29 +0100
+
+mount (2.5p-1.1) unstable; urgency=low
+
+  * Just an interim release, the real maintainer is
+    Robert Leslie <rob@mars.org>
+  * Converted to the new package format (Fixes bug #7114).
+  * Corrected bug #6315: compressed man pages,
+    added '/usr/doc/mount/copyright' file,
+    moved examples to '/usr/doc/mount/examples'.
+
+ -- Vincent Renardias <vincent@waw.com>  Sun, 9 Feb 1997 22:08:56 +0100
+
+Local variables:
+mode: debian-changelog
+End:
--- util-linux-2.12r.orig/debian/conffiles
+++ util-linux-2.12r/debian/conffiles
@@ -0,0 +1 @@
+/etc/init.d/hwclock.sh
--- util-linux-2.12r.orig/debian/control
+++ util-linux-2.12r/debian/control
@@ -0,0 +1,73 @@
+Source: util-linux
+Section: base
+Priority: required
+Build-Depends: libncurses5-dev, libslang2-dev (>=2.0.4-1), gettext, zlib1g-dev, libblkid-dev, uuid-dev, dpatch, dpkg-dev (>=1.13.12)
+Maintainer: LaMont Jones <lamont@debian.org>
+Standards-Version: 3.6.2.0
+
+Package: util-linux
+Architecture: any
+Pre-Depends: ${util-linux:Depends}
+Section: utils
+Priority: required
+Essential: yes
+Depends: lsb-base (>= 3.0-6)
+Suggests: util-linux-locales, kbd | console-tools, dosfstools
+Replaces: miscutils, setterm, fdisk, ${util-linux:Conflicts}
+Conflicts: setterm, fdisk, kbd (<< 1.05-3), console-tools (<< 1:0.2.3-21), ${util-linux:Conflicts}
+Description: Miscellaneous system utilities
+ This package contains a number of important utilities, most of which
+ are oriented towards maintenance of your system.  Some of the more
+ important utilities included in this package allow you to partition
+ your hard disk, view kernel messages, and create new filesystems.
+
+Package: util-linux-locales
+Architecture: all
+Section: utils
+Priority: optional
+Depends: util-linux (>= ${Upstream}-0), util-linux (<< ${Upstream}.0-0)
+Replaces: util-linux (<< 2.11b)
+Description: Locales files for util-linux
+ This package contains the internationalization files of for the util-linux
+ package.
+ .
+ They are needed when you want the programs in util-linux to print their
+ messages in other languages than English.
+
+Package: mount
+Architecture: alpha amd64 arm hppa i386 ia64 m68k mips mipsel powerpc ppc64 sh s390 sparc sparc64
+Essential: yes
+Section: admin
+Pre-Depends: ${mount:Depends}
+Description: Tools for mounting and manipulating filesystems
+ This package provides the mount(8), umount(8), swapon(8),
+ swapoff(8), and losetup(8) commands.
+
+Package: bsdutils
+Architecture: any
+Essential: yes
+Section: utils
+Pre-Depends: ${bsdutils:Depends}
+Recommends: bsdmainutils
+Description: Basic utilities from 4.4BSD-Lite
+ This package contains the bare minimum number of BSD utilities needed
+ to boot a Debian system.  You should probably also install
+ bsdmainutils to get the remaining standard BSD utilities.
+ .
+ Included are: logger, renice, replay, script, wall
+
+Package: fdisk-udeb
+Architecture: alpha amd64 arm hppa i386 ia64 mips mipsel powerpc ppc64 hurd-i386 sparc s390
+Priority: extra
+Section: debian-installer
+Depends: ${fdisk-udeb:Depends}
+Description: Partition a hard drive (manual)
+ fdisk package
+
+Package: cfdisk-udeb
+Architecture: alpha amd64 arm hppa i386 ia64 mips mipsel powerpc ppc64 hurd-i386 s390
+Priority: extra
+Section: debian-installer
+Depends: ${cfdisk-udeb:Depends}
+Description: Partition a hard drive (cfdisk)
+ Cfdisk package
--- util-linux-2.12r.orig/debian/copyright
+++ util-linux-2.12r/debian/copyright
@@ -0,0 +1,29 @@
+This is the Debian GNU/Linux prepackaged version of util-linux.
+
+This package was put together by Guy Maor <maor@debian.org> and later
+maintained by Sean 'Shaleh' Perry <shaleh@debian.org>, and Adrian Bunk
+<bunk@stusta.de>.
+
+The current maintainer is LaMont Jones <lamont@debian.org>.
+
+It was downloaded from:
+    ftp://ftp.us.kernel.org/pub/linux/utils/util-linux/
+and previously was at
+    ftp://ftp.win.tue.nl/pub/home/aeb/linux-local/utils/util-linux/
+
+Upstream maintainers include:
+Maintainer: Adrian Bunk <bunk@fs.tum.de>
+Maintainer: Andries Brouwer <aeb@cwi.nl>
+Maintainer address: util-linux@math.uio.no
+Maintainer of getopt: Frodo Looijaard <frodol@dds.nl>
+Maintainer of simpleinit: Richard Gooch <rgooch@atnf.csiro.au>
+
+Copyright:
+
+getopt, more, pg, wall, and whereis may be redistributed under the terms
+of the UCB BSD license found on Debian systems in the file
+/usr/share/common-licenses/BSD
+
+Everything else may be redistributed under the terms of the GNU GPL
+Version 2 or later found on Debian systems in the file
+/usr/share/common-licenses/GPL
--- util-linux-2.12r.orig/debian/fdformat
+++ util-linux-2.12r/debian/fdformat
@@ -0,0 +1,9 @@
+#!/bin/sh
+
+echo '
+Note: /usr/bin/fdformat is obsolete and is no longer available.
+Please use /usr/bin/superformat instead (make sure you have the 
+fdutils package installed first).  Also, there had been some
+major changes from version 4.x.  Please refer to the documentation.
+'
+
--- util-linux-2.12r.orig/debian/fstab.example2
+++ util-linux-2.12r/debian/fstab.example2
@@ -0,0 +1,39 @@
+# /etc/fstab: static file system information.
+#
+# The following is an example. Please see fstab(5) for further details.
+# Please refer to mount(1) for a complete description of mount options.
+#
+# Format:
+#  <file system>         <mount point>   <type>  <options>	<dump>	<pass>
+#
+# dump(8) uses the <dump> field to determine which file systems need
+# to be dumped. fsck(8) uses the <pass> column to determine which file
+# systems need to be checked--the root file system should have a 1 in
+# this field, other file systems a 2, and any file systems that should
+# not be checked (such as MS-DOS or NFS file systems) a 0.
+#
+# The `sw' option indicates that the swap partition is to be activated
+# with `swapon -a'.
+/dev/hda2	none		swap	sw				0 0
+
+# The `bsdgroups' option indicates that the file system is to be mounted
+# with BSD semantics (files inherit the group ownership of the directory
+# in which they live). `ro' can be used to mount a file system read-only.
+/dev/hda3	/		ext2	defaults			0 1
+/dev/hda5	/home		ext2	defaults			0 2
+/dev/hda6	/var		ext2	defaults			0 2
+/dev/hda7	/usr		ext2	defaults,ro			0 2
+/dev/hda8	/usr/local	ext2	defaults,bsdgroups		0 2
+
+# The `noauto' option indicates that the file system should not be mounted
+# with `mount -a'. `user' indicates that normal users are allowed to mount
+# the file system.
+/dev/cdrom	/cdrom		iso9660	defaults,noauto,ro,user		0 0
+/dev/fd0	/floppy		minix	defaults,noauto,user		0 0
+/dev/fd1	/floppy		minix	defaults,noauto,user		0 0
+
+# NFS file systems:
+server:/export/usr	/usr	nfs	defaults			0 0
+
+# proc file system:
+proc		/proc		proc	defaults			0 0
--- util-linux-2.12r.orig/debian/hwclock.sh
+++ util-linux-2.12r/debian/hwclock.sh
@@ -0,0 +1,156 @@
+#!/bin/sh
+# hwclock.sh	Set and adjust the CMOS clock, according to the UTC
+#		setting in /etc/default/rcS (see also rcS(5)).
+#
+# Version:	@(#)hwclock.sh  2.00  14-Dec-1998  miquels@cistron.nl
+#
+# Patches:
+#		2000-01-30 Henrique M. Holschuh <hmh@rcm.org.br>
+#		 - Minor cosmetic changes in an attempt to help new
+#		   users notice something IS changing their clocks
+#		   during startup/shutdown.
+#		 - Added comments to alert users of hwclock issues
+#		   and discourage tampering without proper doc reading.
+
+# WARNING:	Please read /usr/share/doc/util-linux/README.Debian.hwclock
+#		before changing this file. You risk serious clock
+#		misbehaviour otherwise.
+
+FIRST=no	# debian/rules sets this to 'yes' when creating hwclockfirst.sh
+
+[ "X$FIRST" = "Xyes" ] && AGAIN="" || AGAIN=" again"
+
+# Set this to any options you might need to give to hwclock, such
+# as machine hardware clock type for Alphas.
+HWCLOCKPARS=
+
+hwclocksh()
+{
+    [ ! -x /sbin/hwclock ] && return 0
+    . /etc/default/rcS
+
+    . /lib/lsb/init-functions
+    verbose_log_action_msg() { [ "$VERBOSE" = no ] || log_action_msg "$@"; }
+
+    [ "$GMT" = "-u" ] && UTC="yes"
+    case "$UTC" in
+       no|"")	GMT="--localtime"
+		UTC=""
+		if [ "X$FIRST" = "Xyes" ] && [ ! -r /etc/localtime ]; then
+		    if [ -z "$TZ" ]; then
+			log_action_msg "System clock was not updated at this time"
+			return 1
+		    fi
+		fi
+		;;
+       yes)	GMT="--utc"
+		UTC="--utc"
+		;;
+       *)	log_action_msg "Unknown UTC setting: \"$UTC\""; return 1 ;;
+    esac
+
+    case "$BADYEAR" in
+       no|"")	BADYEAR="" ;;
+       yes)	BADYEAR="--badyear" ;;
+       *)	log_action_msg "unknown BADYEAR setting: \"$BADYEAR\""; return 1 ;;
+    esac
+
+    case "$1" in
+	start)
+	    if [ ! -f /etc/adjtime ] && [ ! -e /etc/adjtime ]; then
+		echo "0.0 0 0.0" > /etc/adjtime
+	    fi
+
+	    if [ "$FIRST" != yes ]; then
+		# Uncomment the hwclock --adjust line below if you want
+		# hwclock to try to correct systematic drift errors in the
+		# Hardware Clock.
+		#
+		# WARNING: If you uncomment this option, you must either make
+		# sure *nothing* changes the Hardware Clock other than
+		# hwclock --systohc, or you must delete /etc/adjtime
+		# every time someone else modifies the Hardware Clock.
+		#
+		# Common "vilains" are: ntp, MS Windows, the BIOS Setup
+		# program.
+		#
+		# WARNING: You must remember to invalidate (delete)
+		# /etc/adjtime if you ever need to set the system clock
+		# to a very different value and hwclock --adjust is being
+		# used.
+		#
+		# Please read /usr/share/doc/util-linux/README.Debian.hwclock
+		# before enablig hwclock --adjust.
+
+		#hwclock --adjust $GMT $BADYEAR
+		:
+	    fi
+
+	    if [ "$HWCLOCKACCESS" != no ]; then
+		log_action_msg "Setting the system clock$AGAIN."
+
+		# Copies Hardware Clock time to System Clock using the correct
+		# timezone for hardware clocks in local time, and sets kernel
+		# timezone. DO NOT REMOVE.
+		/sbin/hwclock --hctosys $GMT $HWCLOCKPARS $BADYEAR
+
+		if [ "$FIRST" = yes ]; then
+		    # Copies Hardware Clock time to System Clock using the correct
+		    # timezone for hardware clocks in local time, and sets kernel
+		    # timezone. DO NOT REMOVE.
+		    if [ -z "$TZ" ]; then
+		       /sbin/hwclock --noadjfile --hctosys $GMT $HWCLOCKPARS $BADYEAR
+		    else
+		       TZ="$TZ" /sbin/hwclock --noadjfile --hctosys $GMT $HWCLOCKPARS $BADYEAR
+		    fi
+
+		    if /sbin/hwclock --show $GMT $HWCLOCKPARS $BADYEAR 2>&1 > /dev/null |
+			grep -q '^The Hardware Clock registers contain values that are either invalid'; then
+			    echo "Invalid system date -- setting to 1/1/2002"
+			    /sbin/hwclock --set --date '1/1/2002 00:00:00' $GMT $HWCLOCKPARS $BADYEAR
+		    fi
+		fi
+
+		#	Announce the local time.
+		verbose_log_action_msg "System Clock set. Local time: `date $UTC`"
+	    else
+		verbose_log_action_msg "Not setting System Clock"
+	    fi
+	    ;;
+	stop|restart|reload|force-reload)
+	    if [ "X$FIRST" = "Xyes" ]; then
+		return 0
+	    fi
+	    #
+	    # Updates the Hardware Clock with the System Clock time.
+	    # This will *override* any changes made to the Hardware Clock.
+	    #
+	    # WARNING: If you disable this, any changes to the system
+	    #          clock will not be carried across reboots.
+	    #
+	    if [ "$HWCLOCKACCESS" != no ]; then
+		log_action_msg "Saving the system clock."
+		if [ "$GMT" = "-u" ]; then
+		    GMT="--utc"
+		fi
+		/sbin/hwclock --systohc $GMT $HWCLOCKPARS $BADYEAR
+		verbose_log_action_msg "Hardware Clock updated to `date`"
+	    else
+		verbose_log_action_msg "Not saving System Clock"
+	    fi
+	    ;;
+	show)
+	    if [ "$HWCLOCKACCESS" != no ]; then
+		/sbin/hwclock --show $GMT $HWCLOCKPARS $BADYEAR
+	    fi
+	    ;;
+	*)
+	    log_success_msg "Usage: hwclock.sh {start|stop|reload|force-reload|show}"
+	    log_success_msg "       start sets kernel (system) clock from hardware (RTC) clock"
+	    log_success_msg "       stop and reload set hardware (RTC) clock from kernel (system) clock"
+	    return 1
+	    ;;
+    esac
+}
+
+hwclocksh "$@"
--- util-linux-2.12r.orig/debian/lintian-override
+++ util-linux-2.12r/debian/lintian-override
@@ -0,0 +1,3 @@
+mount: setuid-binary bin/mount 4755 root/root
+mount: setuid-binary bin/umount 4755 root/root
+bsdutils: setgid-binary usr/bin/wall 2755 root/tty
--- util-linux-2.12r.orig/debian/mime.util-linux
+++ util-linux-2.12r/debian/mime.util-linux
@@ -0,0 +1,2 @@
+text/plain; more %s; needsterminal; priority=5
+text/*; more %s; needsterminal; priority=1
--- util-linux-2.12r.orig/debian/mount.fstab
+++ util-linux-2.12r/debian/mount.fstab
@@ -0,0 +1,39 @@
+# /etc/fstab: static file system information.
+#
+# The following is an example. Please see fstab(5) for further details.
+# Please refer to mount(1) for a complete description of mount options.
+#
+# Format:
+#  <file system>         <mount point>   <type>  <options>	<dump>	<pass>
+#
+# dump(8) uses the <dump> field to determine which file systems need
+# to be dumped. fsck(8) uses the <pass> column to determine which file
+# systems need to be checked--the root file system should have a 1 in
+# this field, other file systems a 2, and any file systems that should
+# not be checked (such as MS-DOS or NFS file systems) a 0.
+#
+# The `sw' option indicates that the swap partition is to be activated
+# with `swapon -a'.
+/dev/hda2	none		swap	sw				0 0
+
+# The `bsdgroups' option indicates that the file system is to be mounted
+# with BSD semantics (files inherit the group ownership of the directory
+# in which they live). `ro' can be used to mount a file system read-only.
+/dev/hda3	/		ext2	defaults			0 1
+/dev/hda5	/home		ext2	defaults			0 2
+/dev/hda6	/var		ext2	defaults			0 2
+/dev/hda7	/usr		ext2	defaults,ro			0 2
+/dev/hda8	/usr/local	ext2	defaults,bsdgroups		0 2
+
+# The `noauto' option indicates that the file system should not be mounted
+# with `mount -a'. `user' indicates that normal users are allowed to mount
+# the file system.
+/dev/cdrom	/cdrom		iso9660	defaults,noauto,ro,user		0 0
+/dev/fd0	/floppy		minix	defaults,noauto,user		0 0
+/dev/fd1	/floppy		minix	defaults,noauto,user		0 0
+
+# NFS file systems:
+server:/export/usr	/usr	nfs	defaults			0 0
+
+# proc file system:
+proc		/proc		proc	defaults			0 0
--- util-linux-2.12r.orig/debian/mount.postinst
+++ util-linux-2.12r/debian/mount.postinst
@@ -0,0 +1,5 @@
+#!/bin/sh -e
+
+if [ -L /usr/doc/mount ] ; then
+    rm -f /usr/doc/mount
+fi
--- util-linux-2.12r.orig/debian/mount.prerm
+++ util-linux-2.12r/debian/mount.prerm
@@ -0,0 +1,5 @@
+#!/bin/sh -e
+
+if [ -L /usr/doc/mount ] ; then
+        rm -f /usr/doc/mount
+fi
--- util-linux-2.12r.orig/debian/patches/00list
+++ util-linux-2.12r/debian/patches/00list
@@ -0,0 +1,18 @@
+10agetty
+10cal-widechar
+10cfdisk
+10cramfs-udebsize
+10debian
+10fstab
+10license
+10misc
+10mount
+10sparcumount
+10warnings
+20guesshelper
+30nfs4
+30nfs4-fix
+#20xgethostname
+#50hurd
+60_opt_O1
+65_llseek-syscall
--- util-linux-2.12r.orig/debian/patches/10agetty.dpatch
+++ util-linux-2.12r/debian/patches/10agetty.dpatch
@@ -0,0 +1,113 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 10agetty.dpatch by LaMont Jones <lamont@debian.org>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: agetty changes in Debian.  The biggest part is switching from
+## DP: termio to termios.  The only other thing is a block of turned-off
+## DP: code trying to interoperate better with gdm.
+
+@DPATCH@
+diff -urNad util-linux/login-utils/agetty.c /tmp/dpep.hTGWc1/util-linux/login-utils/agetty.c
+--- util-linux/login-utils/agetty.c	2004-12-15 17:12:15.678862928 -0700
++++ /tmp/dpep.hTGWc1/util-linux/login-utils/agetty.c	2004-12-15 17:15:56.246450201 -0700
+@@ -30,6 +30,8 @@
+ #include <getopt.h>
+ #include <time.h>
+ #include <sys/file.h>
++#include <sys/vt.h>
++#include <linux/tty.h>
+ #include "xstrncpy.h"
+ #include "nls.h"
+ 
+@@ -652,6 +654,91 @@
+ 	if ((st.st_mode & S_IFMT) != S_IFCHR)
+ 	    error(_("/dev/%s: not a character device"), tty);
+ 
++	/*
++	 * Try to avoid opening a vt that is already open, as this will
++	 * mean that the keyboard will be unusable.
++	 *
++	 * Unfortunately, all the kernel gives us to find out is an ioctl
++	 * for the next available vt.  As the kernel doesn't open the vt for
++	 * you with the ioctl, there is still a chance of both processes
++	 * opening the same vt, but this check is far better than nothing at
++	 * all.
++	 *
++	 * The kernel API sucks, and is unusable for this situation.  What
++	 * we really need is an ioctl that says 'does anyone _ELSE_ have
++	 * this tty open', and that doesn't exist.  Or better yet, the
++	 * kernel really shouldn't allow two processes to have read access
++	 * on the same tty at the same time (other than with dup...)  Opens
++	 * of the same tty device shouldn't be able to steal reads from
++	 * each other.
++	 *
++	 * Similar to the check added to gdm.
++	 *
++	 * For now, just turn off this check, restoring the bug that ?dm
++	 * (and the system) occasionally get their keyboard locked out by
++	 * getty showing up after they've taken a vt that inittab says
++	 * goes to a getty.
++	 * Bummer.
++	 *
++	 */
++#if 0
++	if (strncmp(tty,"tty",3) == 0)
++	{
++	    char *end;
++	    int vtno;
++
++	    vtno = strtol(tty+3,&end,10);
++	    if (end != tty+3 && *end == '\0' && vtno > 1)
++	    {
++		int fd;
++		int newvtno;
++		int fds[MAX_NR_CONSOLES];
++		int vt_cnt = 0;
++		int i;
++
++		for ( i = 0 ; i < MAX_NR_CONSOLES ; i++ )
++		    fds[i] = -1;
++
++		if ((fd = open("/dev/tty0", O_WRONLY, 0) ) < 0
++		    && errno != ENOENT)
++		    error(_("/dev/tty0: cannot open: %m"));
++
++		if (fd >= 0) do
++		{
++		    if ((ioctl(fd, VT_OPENQRY, &newvtno ) < 0))
++			error(_("failed to query next available vt"));
++
++		    if (newvtno == -1)
++			error(_("all vts are in use"));
++
++		    if (newvtno > vtno)
++			error(_("/dev/%s: already in use"), tty);
++
++		    if (newvtno < vtno)
++		    {
++			char vtname[TTY_NAME_MAX+3];
++
++			sprintf( vtname, "tty%d", newvtno );
++
++			if ((fds[vt_cnt++] =
++			    open(vtname, O_RDWR|O_NONBLOCK, 0)) < 0)
++			{
++			    error(_("/dev/%s: cannot open: %m"), tty);
++			}
++		    }
++		} while (newvtno != vtno);
++
++		close(fd);
++		for ( i = 0 ; i < MAX_NR_CONSOLES ; i++ )
++		{
++		    if (fds[i] == -1)
++			break;
++		    close(fds[i]);
++		}
++	    }
++	}
++#endif
++
+ 	/* Open the tty as standard input. */
+ 
+ 	(void) close(0);
--- util-linux-2.12r.orig/debian/patches/10cal-widechar.dpatch
+++ util-linux-2.12r/debian/patches/10cal-widechar.dpatch
@@ -0,0 +1,113 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 10cal-widechar.dpatch by LaMont Jones <lamont@debian.org>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Patch for wide-character support in cal.
+
+@DPATCH@
+diff -urNad util-linux/misc-utils/cal.c /tmp/dpep.GnsIaa/util-linux/misc-utils/cal.c
+--- util-linux/misc-utils/cal.c	2004-12-05 12:20:36.000000000 -0700
++++ /tmp/dpep.GnsIaa/util-linux/misc-utils/cal.c	2004-12-15 07:13:17.529049196 -0700
+@@ -367,8 +367,9 @@
+ {
+   int i, wd;
+ #ifdef ENABLE_WIDECHAR
++  int j;
+   wchar_t day_headings_wc[22],j_day_headings_wc[29];
+-  wchar_t wd_wc[10];
++  wchar_t wd_wc[10], tmp_wd_wc[10];
+ #endif
+ 
+   strcpy(day_headings,"");
+@@ -387,15 +388,32 @@
+   for(i = 0 ; i < 7 ; i++ ) {
+      wd = (i + week1stday) % 7;
+ #ifdef ENABLE_WIDECHAR
+-     mbstowcs(wd_wc,weekday(wd),10);
+-     if (wcswidth(wd_wc,10) < 3)
+-	     wcscat(j_day_headings_wc,L" ");
+-     if (wcswidth(wd_wc,10) < 2) {
+-	     wcscat(day_headings_wc, L" ");
+-	     wcscat(j_day_headings_wc, L" ");
++     mbstowcs(tmp_wd_wc,weekday(wd),10);
++
++     wmemset(wd_wc, L'\0', 10);
++     for (j = 0; j < wcslen(tmp_wd_wc); j++) {
++	 wd_wc[j] = tmp_wd_wc[j];
++	 if (wcswidth(wd_wc,10) > 2) {
++	     wd_wc[j] = L'\0';
++	     break;
++	 }
+      }
+-     wcsncat(day_headings_wc,wd_wc,2);
+-     wcsncat(j_day_headings_wc,wd_wc,3);
++     for (j = wcswidth(wd_wc,10); j < 2; j++)
++       wcscat(day_headings_wc,L" ");
++     wcscat(day_headings_wc,wd_wc);
++
++     wmemset(wd_wc, L'\0', 10);
++     for (j = 0; j < wcslen(tmp_wd_wc); j++) {
++	 wd_wc[j] = tmp_wd_wc[j];
++	 if (wcswidth(wd_wc,10) > 3) {
++	     wd_wc[j] = L'\0';
++	     break;
++	 }
++     }
++     for (j = wcswidth(wd_wc,10); j < 3; j++)
++       wcscat(j_day_headings_wc,L" ");
++     wcscat(j_day_headings_wc,wd_wc);
++	
+      wcscat(day_headings_wc, L" ");
+      wcscat(j_day_headings_wc, L" ");
+ #else
+@@ -426,6 +444,10 @@
+ do_monthly(int day, int month, int year, struct fmt_st *out) {
+ 	int col, row, len, days[MAXDAYS];
+ 	char *p, lineout[FMT_ST_CHARS];
++#ifdef ENABLE_WIDECHAR
++	wchar_t lineout_wc[FMT_ST_CHARS];
++	size_t wcs_len;
++#endif
+ 	int width = (julian ? J_WEEK_LEN : WEEK_LEN) - 1;
+ 
+ 	day_array(day, month, year, days);
+@@ -437,9 +459,17 @@
+ 	 * the Vietnamese should be "%s na(m %d", etc.
+ 	 */
+ 	len = sprintf(lineout, _("%s %d"), full_month[month - 1], year);
++#ifdef ENABLE_WIDECHAR
++	wcs_len = mbstowcs(lineout_wc,lineout,len);
++	if (wcs_len != (size_t)-1 && wcs_len != 0) {
++          len = wcswidth(lineout_wc,wcs_len);
++        } else {
++          len = strlen(lineout);
++        }
++#endif
+ 	center_str(lineout, out->s[0], SIZE(out->s[0]), width);
+ 
+-	sprintf(out->s[1],"%s",
++	(void)sprintf(out->s[1],"%s",
+ 		julian ? j_day_headings : day_headings);
+ 	for (row = 0; row < 6; row++) {
+ 		for (col = 0, p = lineout; col < 7; col++)
+@@ -767,6 +797,20 @@
+ 	int separate;
+ {
+ 	char lineout[FMT_ST_CHARS];
++#ifdef ENABLE_WIDECHAR
++	wchar_t str_wc[FMT_ST_CHARS];
++	size_t str_len, wcs_len;
++
++	wcs_len = mbstowcs (str_wc,str,FMT_ST_CHARS);
++	if (wcs_len != (size_t)-1 && wcs_len != 0) {
++           str_len = wcswidth(str_wc,wcs_len);
++        } else {
++           str_len = strlen(str);
++        } 
++	len -= str_len;
++#else
++	len -= strlen(str);
++#endif
+ 	center_str(str, lineout, SIZE(lineout), len);
+ 	fputs(lineout, stdout);
+ 	if (separate)
--- util-linux-2.12r.orig/debian/patches/10cfdisk.dpatch
+++ util-linux-2.12r/debian/patches/10cfdisk.dpatch
@@ -0,0 +1,49 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 10cfdisk.dpatch by LaMont Jones <lamont@debian.org>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Buffer overruns with narrow terminal windows.
+
+@DPATCH@
+diff -urNad util-linux/fdisk/cfdisk.c /tmp/dpep.rEB26p/util-linux/fdisk/cfdisk.c
+--- util-linux/fdisk/cfdisk.c	2004-12-24 14:41:20.000000000 -0700
++++ /tmp/dpep.rEB26p/util-linux/fdisk/cfdisk.c	2004-12-24 15:00:00.503453740 -0700
+@@ -2100,7 +2100,7 @@
+ 	if (to_file) {
+ 	    if ((fp = fopen(fname, "w")) == NULL) {
+ 		char errstr[LINE_LENGTH];
+-		sprintf(errstr, _("Cannot open file '%s'"), fname);
++		snprintf(errstr, LINE_LENGTH, _("Cannot open file '%s'"), fname);
+ 		print_warning(errstr);
+ 		return;
+ 	    }
+@@ -2184,7 +2184,7 @@
+ 	if (to_file) {
+ 	    if ((fp = fopen(fname, "w")) == NULL) {
+ 		char errstr[LINE_LENGTH];
+-		sprintf(errstr, _("Cannot open file '%s'"), fname);
++		snprintf(errstr, LINE_LENGTH, _("Cannot open file '%s'"), fname);
+ 		print_warning(errstr);
+ 		return;
+ 	    }
+@@ -2638,9 +2638,9 @@
+ 	mvaddstr(WARNING_START, 0, line);
+ 
+ 
+-    sprintf(line, "cfdisk %s", VERSION);
++    snprintf(line, COLS+1, "cfdisk %s", VERSION);
+     mvaddstr(HEADER_START, (COLS-strlen(line))/2, line);
+-    sprintf(line, _("Disk Drive: %s"), disk_device);
++    snprintf(line, COLS+1, _("Disk Drive: %s"), disk_device);
+     mvaddstr(HEADER_START+2, (COLS-strlen(line))/2, line);
+     {
+ 	    long long bytes = actual_size*(long long) SECTOR_SIZE;
+@@ -2654,7 +2654,7 @@
+ 			    bytes, megabytes/K, (10*megabytes/K)%10);
+     }
+     mvaddstr(HEADER_START+3, (COLS-strlen(line))/2, line);
+-    sprintf(line, _("Heads: %d   Sectors per Track: %d   Cylinders: %lld"),
++    snprintf(line, COLS+1, _("Heads: %d   Sectors per Track: %d   Cylinders: %lld"),
+ 	    heads, sectors, cylinders);
+     mvaddstr(HEADER_START+4, (COLS-strlen(line))/2, line);
+ 
--- util-linux-2.12r.orig/debian/patches/10cramfs-udebsize.dpatch
+++ util-linux-2.12r/debian/patches/10cramfs-udebsize.dpatch
@@ -0,0 +1,28 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 10cramfs-udebsize.dpatch by LaMont Jones <lamont@debian.org>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: malloc the output buffer, instead of statically creating it.
+
+@DPATCH@
+diff -urNad --exclude=CVS --exclude=.svn ./disk-utils/fsck.cramfs.c /tmp/dpep-work.XLCGO2/util-linux/disk-utils/fsck.cramfs.c
+--- ./disk-utils/fsck.cramfs.c	2005-12-06 11:57:59.000000000 -0700
++++ /tmp/dpep-work.XLCGO2/util-linux/disk-utils/fsck.cramfs.c	2005-12-06 11:59:18.000000000 -0700
+@@ -95,7 +95,7 @@
+ static unsigned long read_buffer_block = ~0UL;
+ 
+ /* Uncompressing data structures... */
+-static char outbuffer[PAGE_CACHE_SIZE*2];
++static char *outbuffer;
+ z_stream stream;
+ 
+ #endif /* INCLUDE_FS_TESTS */
+@@ -464,6 +464,8 @@
+ 	int c;			/* for getopt */
+ 	int start = 0;
+ 
++	outbuffer=(char*)malloc(PAGE_CACHE_SIZE*2);
++
+ 	if (argc)
+ 		progname = argv[0];
+ 
--- util-linux-2.12r.orig/debian/patches/10debian.dpatch
+++ util-linux-2.12r/debian/patches/10debian.dpatch
@@ -0,0 +1,115 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 10debian.dpatch by  <lamont@debian.org>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Debian specific configuration changes
+
+@DPATCH@
+diff -urNad util-linux/MCONFIG /tmp/dpep.BP9ADw/util-linux/MCONFIG
+--- util-linux/MCONFIG	2004-12-15 11:41:41.633346075 -0700
++++ /tmp/dpep.BP9ADw/util-linux/MCONFIG	2004-12-15 17:01:42.932876625 -0700
+@@ -22,7 +22,7 @@
+ # If HAVE_PAM is set to "yes", then login, chfn, chsh, and newgrp
+ # will use PAM for authentication. Additionally, passwd will not be
+ # installed as it is not PAM aware.
+-HAVE_PAM=no
++HAVE_PAM=yes
+ 
+ # If HAVE_SELINUX is set to "yes", the login will make sure the user is
+ # logged into an appropriate security context
+@@ -59,7 +59,7 @@
+ # not be built or installed from the login-utils subdirectory.  (The
+ # shutdown and init from the SysVinit package do not depend on the last,
+ # mesg, and wall from that package.)
+-HAVE_SYSVINIT_UTILS=yes
++HAVE_SYSVINIT_UTILS=no
+ 
+ # If HAVE_WRITE is set to "yes", then write will not be built or
+ # installed from the misc-utils subdirectory.
+@@ -155,7 +155,7 @@
+ 
+ # Set HAVE_SLANG to yes if you have slang (and prefer to use that for cfdisk)
+ # (If neither HAVE_NCURSES nor HAVE_SLANG is defined, cfdisk is not made.)
+-# HAVE_SLANG=yes
++HAVE_SLANG=yes
+ # There is a subdirectory /usr/include/slang containing slcurses.h
+ # SLANGFLAGS=-I/usr/include/slang
+ # No such subdirectory - slcurses.h lives in /usr/include
+@@ -172,7 +172,7 @@
+ USRLIB_DIR=	/usr/lib
+ USRBIN_DIR=	/usr/bin
+ USRGAMES_DIR=	/usr/games
+-USRSHAREMISC_DIR=/usr/share/misc
++USRSHAREMISC_DIR=/usr/share/util-linux
+ LOCALE_DIR=	/usr/share/locale
+ BIN_DIR=        /bin
+ VAR_PATH=	/var
+diff -urNad util-linux/getopt/getopt.1 /tmp/dpep.BP9ADw/util-linux/getopt/getopt.1
+--- util-linux/getopt/getopt.1	2004-12-15 11:41:41.634345860 -0700
++++ /tmp/dpep.BP9ADw/util-linux/getopt/getopt.1	2004-12-15 17:01:42.932876625 -0700
+@@ -403,9 +403,10 @@
+ Example scripts for (ba)sh and (t)csh are provided with the
+ .BR getopt (1)
+ distribution, and are optionally installed in 
+-.B /usr/local/lib/getopt 
++.BR /usr/lib/getopt 
+ or 
+-.BR /usr/lib/getopt .
++.B /usr/local/lib/getopt 
++(if you have created it).
+ .SH ENVIRONMENT
+ .IP POSIXLY_CORRECT
+ This environment variable is examined by the
+diff -urNad util-linux/hwclock/hwclock.8 /tmp/dpep.BP9ADw/util-linux/hwclock/hwclock.8
+--- util-linux/hwclock/hwclock.8	2004-12-15 16:33:16.000000000 -0700
++++ /tmp/dpep.BP9ADw/util-linux/hwclock/hwclock.8	2004-12-15 17:01:42.932876625 -0700
+@@ -578,8 +578,6 @@
+ .SH FILES
+ .I /etc/adjtime
+ .I /usr/share/zoneinfo/
+-.RI ( /usr/lib/zoneinfo
+-on old systems)
+ .I /dev/rtc
+ .I /dev/port
+ .I /dev/tty1
+@@ -592,6 +590,9 @@
+ .BR settimeofday (2),
+ .BR crontab (1),
+ .BR tzset (3)
++.BR /etc/init.d/hwclock.sh,
++.BR /usr/share/doc/util-linux/README.Debian.hwclock
++
+ 
+ .SH AUTHORS
+ Written by Bryan Henderson, September 1996 (bryanh@giraffe-data.com),
+diff -urNad util-linux/mount/README.mount /tmp/dpep.BP9ADw/util-linux/mount/README.mount
+--- util-linux/mount/README.mount	2004-12-15 11:41:41.634345860 -0700
++++ /tmp/dpep.BP9ADw/util-linux/mount/README.mount	2004-12-15 17:01:42.933876410 -0700
+@@ -8,3 +8,4 @@
+ Presently maintained by Andries Brouwer <aeb@cwi.nl>.
+ Ftp site: ftp.win.tue.nl:/pub/linux/utils/util-linux
+ 
++http://freshmeat.net/projects/util-linux/ tends to be current as well.
+diff -urNad util-linux/mount/my_dev_t.h /tmp/dpep.BP9ADw/util-linux/mount/my_dev_t.h
+--- util-linux/mount/my_dev_t.h	2004-12-15 11:41:41.635345645 -0700
++++ /tmp/dpep.BP9ADw/util-linux/mount/my_dev_t.h	2004-12-15 17:01:42.933876410 -0700
+@@ -2,19 +2,4 @@
+ /* glibc uses a different dev_t */
+ 
+ #include <linux/posix_types.h>
+-#include <linux/version.h>
+-
+-#ifndef KERNEL_VERSION
+-#define KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
+-#endif
+-
+-#if LINUX_VERSION_CODE < KERNEL_VERSION(1,3,78)
+-/* for i386 - alpha uses unsigned int */
+-#define my_dev_t unsigned short
+-#else
+-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,68)
+-#define my_dev_t __kernel_dev_t
+-#else
+ #define my_dev_t __kernel_old_dev_t
+-#endif
+-#endif
--- util-linux-2.12r.orig/debian/patches/10fstab.dpatch
+++ util-linux-2.12r/debian/patches/10fstab.dpatch
@@ -0,0 +1,19 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 10fstab.dpatch by  <lamont@debian.org>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: create /etc/mtab with mode 0600
+
+@DPATCH@
+diff -urNad util-linux/mount/fstab.c /tmp/dpep.pHan4D/util-linux/mount/fstab.c
+--- util-linux/mount/fstab.c	2004-12-04 16:20:19.000000000 -0700
++++ /tmp/dpep.pHan4D/util-linux/mount/fstab.c	2004-12-15 07:42:42.193006107 -0700
+@@ -462,7 +462,7 @@
+ 		struct flock flock;
+ 		int errsv, fd, i, j;
+ 
+-		i = open (linktargetfile, O_WRONLY|O_CREAT, 0);
++		i = open (linktargetfile, O_WRONLY|O_CREAT, 0600);
+ 		if (i < 0) {
+ 			int errsv = errno;
+ 			/* linktargetfile does not exist (as a file)
--- util-linux-2.12r.orig/debian/patches/10license.dpatch
+++ util-linux-2.12r/debian/patches/10license.dpatch
@@ -0,0 +1,39 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 10license.dpatch by  <lamont@debian.org>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: BSD License allows dropping of clause 3 from the 4-term license.
+
+@DPATCH@
+diff -urNad util-linux/login-utils/wall.1 /tmp/dpep.ZDTG6n/util-linux/login-utils/wall.1
+--- util-linux/login-utils/wall.1	2002-01-06 07:05:23.000000000 -0700
++++ /tmp/dpep.ZDTG6n/util-linux/login-utils/wall.1	2004-12-15 07:48:33.739391993 -0700
+@@ -9,11 +9,7 @@
+ .\" 2. Redistributions in binary form must reproduce the above copyright
+ .\"    notice, this list of conditions and the following disclaimer in the
+ .\"    documentation and/or other materials provided with the distribution.
+-.\" 3. All advertising materials mentioning features or use of this software
+-.\"    must display the following acknowledgement:
+-.\"	This product includes software developed by the University of
+-.\"	California, Berkeley and its contributors.
+-.\" 4. Neither the name of the University nor the names of its contributors
++.\" 3. Neither the name of the University nor the names of its contributors
+ .\"    may be used to endorse or promote products derived from this software
+ .\"    without specific prior written permission.
+ .\"
+diff -urNad util-linux/login-utils/wall.c /tmp/dpep.ZDTG6n/util-linux/login-utils/wall.c
+--- util-linux/login-utils/wall.c	2002-03-08 16:00:19.000000000 -0700
++++ /tmp/dpep.ZDTG6n/util-linux/login-utils/wall.c	2004-12-15 07:48:33.748390902 -0700
+@@ -10,11 +10,7 @@
+  * 2. Redistributions in binary form must reproduce the above copyright
+  *    notice, this list of conditions and the following disclaimer in the
+  *    documentation and/or other materials provided with the distribution.
+- * 3. All advertising materials mentioning features or use of this software
+- *    must display the following acknowledgement:
+- *	This product includes software developed by the University of
+- *	California, Berkeley and its contributors.
+- * 4. Neither the name of the University nor the names of its contributors
++ * 3. Neither the name of the University nor the names of its contributors
+  *    may be used to endorse or promote products derived from this software
+  *    without specific prior written permission.
+  *
--- util-linux-2.12r.orig/debian/patches/10misc.dpatch
+++ util-linux-2.12r/debian/patches/10misc.dpatch
@@ -0,0 +1,19 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 10misc.dpatch by  <lamont@debian.org>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: miscellaneous patches of unknown origin
+
+@DPATCH@
+diff -urNad util-linux/disk-utils/mkswap.8 /tmp/dpep.X7zJbq/util-linux/disk-utils/mkswap.8
+--- util-linux/disk-utils/mkswap.8	2002-11-02 04:21:41.000000000 -0700
++++ /tmp/dpep.X7zJbq/util-linux/disk-utils/mkswap.8	2004-12-15 07:48:50.935307520 -0700
+@@ -109,7 +109,7 @@
+ 
+ Note that a swap file must not contain any holes (so, using
+ .BR cp (1)
+-to create the file is not acceptable).
++to create the file is not generally acceptable).
+ 
+ .SH OPTIONS
+ .TP
--- util-linux-2.12r.orig/debian/patches/10mount.dpatch
+++ util-linux-2.12r/debian/patches/10mount.dpatch
@@ -0,0 +1,1216 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 10mount.dpatch by LaMont Jones <lamont@debian.org>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Mount changes from Debian, including some incompatible crap.  sorry.
+## DP: - merge all the various cryptoapi versions (kerneli, 2.6, etc)
+## DP: - Default to hashing passphrases for some of the crypto methods.
+## DP:   This would be the one that really trashes compatibility.
+## DP: - Extra options to take keysize, etc.
+
+@DPATCH@
+diff -urNad --exclude=CVS --exclude=.svn ./mount/Makefile /tmp/dpep-work.31redI/util-linux/mount/Makefile
+--- ./mount/Makefile	2005-08-16 11:50:21.000000000 -0600
++++ /tmp/dpep-work.31redI/util-linux/mount/Makefile	2006-01-16 11:09:51.000000000 -0700
+@@ -29,7 +29,7 @@
+ 
+ MAYBE = pivot_root swapoff
+ 
+-LO_OBJS = lomount.o $(LIB)/xstrncpy.o
++LO_OBJS = lomount.o $(LIB)/xstrncpy.o rmd160.o
+ NFS_OBJS = nfsmount.o nfsmount_xdr.o nfsmount_clnt.o
+ GEN_FILES = nfsmount.h nfsmount_xdr.c nfsmount_clnt.c
+ 
+@@ -64,7 +64,7 @@
+ main_losetup.o: lomount.c
+ 	$(COMPILE) -DMAIN lomount.c -o $@
+ 
+-losetup: main_losetup.o $(LIB)/xstrncpy.o
++losetup: main_losetup.o $(LIB)/xstrncpy.o rmd160.o
+ 	$(LINK) $^ -o $@
+ 
+ mount.o umount.o nfsmount.o losetup.o fstab.o realpath.o sundries.o: sundries.h
+diff -urNad --exclude=CVS --exclude=.svn ./mount/lomount.c /tmp/dpep-work.31redI/util-linux/mount/lomount.c
+--- ./mount/lomount.c	2005-08-16 11:50:21.000000000 -0600
++++ /tmp/dpep-work.31redI/util-linux/mount/lomount.c	2006-01-16 11:20:45.000000000 -0700
+@@ -20,6 +20,7 @@
+ 
+ #include "loop.h"
+ #include "lomount.h"
++#include "rmd160.h"
+ #include "xstrncpy.h"
+ #include "nls.h"
+ 
+@@ -30,6 +31,73 @@
+ 
+ #ifdef LOOP_SET_FD
+ 
++#include <getopt.h>
++#include <stdarg.h>
++
++struct crypt_type_struct {
++	int id;
++	char *name;
++	int keylength;
++} crypt_type_tbl[] = {
++        { LO_CRYPT_NONE, "none", 0 },
++        { LO_CRYPT_XOR, "xor", 0 },
++        { LO_CRYPT_DES, "des", 8 },
++        { LO_CRYPT_FISH2, "twofish", 20 },
++        { LO_CRYPT_BLOW, "blowfish", 20 },
++        { LO_CRYPT_CAST128, "cast", 16 },
++        { LO_CRYPT_SERPENT, "serpent", 16 },
++        { LO_CRYPT_MARS, "mars", 16 },
++        { LO_CRYPT_RC6, "rc6", 16 },
++        { LO_CRYPT_3DES, "des-ede3", 24 },
++        { LO_CRYPT_DFC, "dfc", 16 },
++        { LO_CRYPT_IDEA, "idea", 16 },
++        { LO_CRYPT_RIJNDAEL, "rijndael", 16 },
++	{ -1, NULL,0   }
++};
++
++#ifdef MAIN
++static struct option longopts[] = {
++	{ "delete", 0, 0, 'd' },
++	{ "detach", 0, 0, 'd' },
++	{ "encryption", 1, 0, 'e' },
++	{ "help", 0, 0, 'h' },
++	{ "nopasshash", 1, 0, 'N' },
++	{ "nohashpass", 1, 0, 'N' },
++	{ "offset", 1, 0, 'o' },
++	{ "pass-fd", 1, 0, 'p' },
++	{ "verbose", 0, 0, 'v' },
++	{ "keybits", 1, 0, 'k' },
++	{ NULL, 0, 0, 0 }
++};
++#endif
++
++static int 
++name_to_id(const char *name) 
++{
++	int i;
++
++	if (name) {
++		for (i = 0; crypt_type_tbl[i].id != -1; i++)
++			if (!strcasecmp (name, crypt_type_tbl[i].name))
++				return crypt_type_tbl[i].id;
++	} else
++		return LO_CRYPT_NONE;
++	return LO_CRYPT_CRYPTOAPI;
++}
++
++#ifdef MAIN
++static char *
++id_to_name(int id) {
++	int i;
++
++	for (i = 0; crypt_type_tbl[i].id != -1; i++)
++		if (id == crypt_type_tbl[i].id)
++			return crypt_type_tbl[i].name;
++	return "undefined";
++}
++#endif
++
++
+ static int
+ loop_info64_to_old(const struct loop_info64 *info64, struct loop_info *info)
+ {
+@@ -123,6 +191,10 @@
+ 	}
+ 
+ 	errsv = errno;
++	printf (_("%s: [%04x]:%ld (%s) offset %d, %s encryption\n"),
++		device, loopinfo.lo_device, loopinfo.lo_inode,
++		loopinfo.lo_name, loopinfo.lo_offset,
++		id_to_name(loopinfo.lo_encrypt_type));
+ 	fprintf(stderr, _("loop: can't get info on device %s: %s\n"),
+ 		device, strerror (errsv));
+ 	close (fd);
+@@ -240,10 +312,14 @@
+ 
+ int
+ set_loop(const char *device, const char *file, unsigned long long offset,
+-	 const char *encryption, int pfd, int *loopro) {
++	 const char *encryption, int pfd, int keysz, int *loopro, int hash_password) {
+ 	struct loop_info64 loopinfo64;
+ 	int fd, ffd, mode, i;
+ 	char *pass;
++	int tried_old;
++	struct stat statbuf;
++
++	int kerneli = (stat("/proc/crypto/cipher", &statbuf) == 0);
+ 
+ 	mode = (*loopro ? O_RDONLY : O_RDWR);
+ 	if ((ffd = open(file, mode)) < 0) {
+@@ -269,8 +345,13 @@
+ 			loopinfo64.lo_encrypt_type = atoi(encryption);
+ 		} else {
+ 			loopinfo64.lo_encrypt_type = LO_CRYPT_CRYPTOAPI;
+-			snprintf(loopinfo64.lo_crypt_name, LO_NAME_SIZE,
++			if (kerneli)
++			    snprintf(loopinfo64.lo_crypt_name, LO_NAME_SIZE,
++				 "%s-cbc", encryption);
++			else
++			    snprintf(loopinfo64.lo_crypt_name, LO_NAME_SIZE,
+ 				 "%s", encryption);
++			loopinfo64.lo_crypt_name[LO_NAME_SIZE-1] = 0;
+ 		}
+ 	}
+ 
+@@ -289,30 +370,114 @@
+ 	}
+ #endif
+ 
++	if (keysz==0)
++		keysz=LO_KEY_SIZE*8;
++	tried_old=0;
++again:
+ 	switch (loopinfo64.lo_encrypt_type) {
+ 	case LO_CRYPT_NONE:
+ 		loopinfo64.lo_encrypt_key_size = 0;
+ 		break;
+ 	case LO_CRYPT_XOR:
+ 		pass = getpass(_("Password: "));
+-		goto gotpass;
+-	default:
+-		pass = xgetpass(pfd, _("Password: "));
+-	gotpass:
+ 		memset(loopinfo64.lo_encrypt_key, 0, LO_KEY_SIZE);
+ 		xstrncpy(loopinfo64.lo_encrypt_key, pass, LO_KEY_SIZE);
+ 		memset(pass, 0, strlen(pass));
+ 		loopinfo64.lo_encrypt_key_size = LO_KEY_SIZE;
++		break;
++	case LO_CRYPT_FISH2:
++	case LO_CRYPT_BLOW:
++	case LO_CRYPT_IDEA:
++	case LO_CRYPT_CAST128:
++	case LO_CRYPT_SERPENT:
++	case LO_CRYPT_MARS:
++	case LO_CRYPT_RC6:
++	case LO_CRYPT_3DES:
++	case LO_CRYPT_DFC:
++	case LO_CRYPT_RIJNDAEL:
++	    {
++#define HASHLENGTH 20
++		char keybits[2*HASHLENGTH]; 
++		char *pass2;
++		int passwdlen;
++		int keylength;
++		int i;
++
++  		pass = xgetpass(pfd, _("Password: "));
++		passwdlen=strlen(pass);
++		pass2=malloc(passwdlen+2);
++		pass2[0]='A';
++		strcpy(pass2+1,pass);
++		rmd160_hash_buffer(keybits,pass,passwdlen);
++		rmd160_hash_buffer(keybits+HASHLENGTH,pass2,passwdlen+1);
++		memcpy((char*)loopinfo64.lo_encrypt_key,keybits,2*HASHLENGTH);
++		memset(pass, 0, passwdlen);
++		memset(pass2, 0, passwdlen+1);
++		free(pass2);
++		keylength=0;
++		for(i=0; crypt_type_tbl[i].id != -1; i++){
++		         if(loopinfo64.lo_encrypt_type == crypt_type_tbl[i].id){
++			         keylength = crypt_type_tbl[i].keylength;
++				 break;
++			 }
++		}
++		loopinfo64.lo_encrypt_key_size=keylength;
++		break;
++	    }
++	default:
++		if (hash_password) {
++		    char keybits[2*HASHLENGTH]; 
++		    char *pass2;
++		    int passwdlen;
++
++		    pass = xgetpass(pfd, _("Password: "));
++		    passwdlen=strlen(pass);
++		    pass2=malloc(passwdlen+2);
++		    pass2[0]='A';
++		    strcpy(pass2+1,pass);
++		    rmd160_hash_buffer(keybits,pass,passwdlen);
++		    rmd160_hash_buffer(keybits+HASHLENGTH,pass2,passwdlen+1);
++		    memset(pass, 0, passwdlen);
++		    memset(pass2, 0, passwdlen+1);
++		    free(pass2);
++
++		    memcpy((char*)loopinfo64.lo_encrypt_key,keybits,keysz/8);
++		    loopinfo64.lo_encrypt_key_size = keysz/8;
++		} else {
++		    pass = xgetpass(pfd, _("Password: "));
++		    memset(loopinfo64.lo_encrypt_key, 0, LO_KEY_SIZE);
++		    xstrncpy(loopinfo64.lo_encrypt_key, pass, LO_KEY_SIZE);
++		    memset(pass, 0, strlen(pass));
++		    loopinfo64.lo_encrypt_key_size = LO_KEY_SIZE;
++		}
+ 	}
+ 
+ 	if (ioctl(fd, LOOP_SET_FD, ffd) < 0) {
+ 		perror("ioctl: LOOP_SET_FD");
+ 		return 1;
+ 	}
+-	close (ffd);
+-
+-	i = ioctl(fd, LOOP_SET_STATUS64, &loopinfo64);
+-	if (i) {
++	if (kerneli) {
++	    struct loop_info loopinfo;
++	    loop_info64_to_old(&loopinfo64,&loopinfo);
++	    i=ioctl (fd, LOOP_SET_STATUS, &loopinfo);
++	    if (i<0) {
++		/* Try again with old-style LO_CRYPT_XX if
++		   new-style LO_CRYPT_CRYPTOAPI ioctl didn't work */
++		if (tried_old) {
++		    error("The cipher does not exist, or a cipher module "
++			  "needs to be loaded into the kernel");
++		    perror ("ioctl: LOOP_SET_STATUS");
++		    goto fail;
++		}
++		strncpy (loopinfo64.lo_file_name, file, LO_NAME_SIZE);
++		loopinfo64.lo_file_name[LO_NAME_SIZE - 1] = 0;
++		loopinfo64.lo_encrypt_type = name_to_id (encryption);
++		tried_old = 1;
++		goto again;
++	    }
++	} else {
++	    i=ioctl(fd, LOOP_SET_STATUS64, &loopinfo64);
++	    if (i<0) {
+ 		struct loop_info loopinfo;
+ 		int errsv = errno;
+ 
+@@ -326,6 +491,7 @@
+ 				perror("ioctl: LOOP_SET_STATUS");
+ 		}
+ 		memset(&loopinfo, 0, sizeof(loopinfo));
++	    }
+ 	}
+ 	memset(&loopinfo64, 0, sizeof(loopinfo64));
+ 
+@@ -334,12 +500,19 @@
+ 		close (fd);
+ 		return 1;
+ 	}
++	close (ffd);
+ 	close (fd);
+ 
+ 	if (verbose > 1)
+ 		printf(_("set_loop(%s,%s,%llu): success\n"),
+ 		       device, file, offset);
+ 	return 0;
++
++ fail:
++	(void) ioctl (fd, LOOP_CLR_FD, 0);
++	close (ffd);
++	close (fd);
++	return 1;
+ }
+ 
+ int 
+@@ -404,10 +577,27 @@
+ static void
+ usage(void) {
+ 	fprintf(stderr, _("usage:\n\
+-  %s loop_device                                       # give info\n\
+-  %s -d loop_device                                    # delete\n\
+-  %s -f                                                # find unused\n\
+-  %s [-e encryption] [-o offset] {-f|loop_device} file # setup\n"),
++  %s loop_device                                      # give info\n\
++  %s -d loop_device                                   # delete\n\
++  %s -f                                               # find unused\n\
++  %s [ options ] {-f|loop_device} file                # setup\n\
++    where options include\n\
++    --offset <num>, -o <num>\n\
++        start at offset <num> into file.\n\
++    --pass-fd <num>, -p <num>\n\
++        read passphrase from file descriptor <num>\n\
++        instead of the terminal.\n\
++    --encryption <cipher>, -e <cipher>\n\
++        encrypt with <cipher>.\n\
++        Check /proc/crypto or /proc/crypto/cipher for available ciphers.\n\
++    --nohashpass, -N\n\
++	Don't hash the password given.  (previous versions hash, non-debian doesn't.\n\
++    --keybits <num>, -k <num>\n\
++        specify number of bits in the hashed key given\n\
++        to the cipher.  Some ciphers support several key\n\
++        sizes and might be more efficient with a smaller\n\
++        key size.  Key sizes < 128 are generally not\n\
++        recommended\n"),
+ 		progname, progname, progname, progname);
+ 	exit(1);
+ }
+@@ -442,10 +632,13 @@
+ int
+ main(int argc, char **argv) {
+ 	char *p, *offset, *encryption, *passfd, *device, *file;
++	char *keysize;
+ 	int delete, find, c;
+ 	int res = 0;
+ 	int ro = 0;
+ 	int pfd = -1;
++	int keysz = 0;
++	int hash_password = 1;
+ 	unsigned long long off;
+ 
+ 	setlocale(LC_ALL, "");
+@@ -455,12 +648,14 @@
+ 	delete = find = 0;
+ 	off = 0;
+ 	offset = encryption = passfd = NULL;
++	keysize = NULL;
+ 
+ 	progname = argv[0];
+ 	if ((p = strrchr(progname, '/')) != NULL)
+ 		progname = p+1;
++	while ((c = getopt_long(argc,argv,"de:E:fhk:No:p:v",
++				longopts, NULL)) != EOF) {
+ 
+-	while ((c = getopt(argc, argv, "de:E:fo:p:v")) != -1) {
+ 		switch (c) {
+ 		case 'd':
+ 			delete = 1;
+@@ -472,6 +667,12 @@
+ 		case 'f':
+ 			find = 1;
+ 			break;
++		case 'k':
++		        keysize = optarg;
++			break;
++		case 'N':
++			hash_password=0;
++			break;
+ 		case 'o':
+ 			offset = optarg;
+ 			break;
+@@ -527,7 +728,10 @@
+ 			usage();
+ 		if (passfd && sscanf(passfd, "%d", &pfd) != 1)
+ 			usage();
+-		res = set_loop(device, file, off, encryption, pfd, &ro);
++		if (keysize && sscanf(keysize,"%d",&keysz) != 1)
++		        usage();
++		res = set_loop(device, file, off,
++		    		encryption, pfd, keysz, &ro, hash_password);
+ 	}
+ 	return res;
+ }
+diff -urNad --exclude=CVS --exclude=.svn ./mount/lomount.h /tmp/dpep-work.31redI/util-linux/mount/lomount.h
+--- ./mount/lomount.h	2005-08-16 11:50:21.000000000 -0600
++++ /tmp/dpep-work.31redI/util-linux/mount/lomount.h	2006-01-16 11:09:51.000000000 -0700
+@@ -1,6 +1,6 @@
+ extern int verbose;
+ extern int set_loop(const char *, const char *, unsigned long long,
+-		    const char *, int, int *);
++		    const char *, int, int, int *, int);
+ extern int del_loop(const char *);
+ extern int is_loop_device(const char *);
+ extern char * find_unused_loop_device(void);
+diff -urNad --exclude=CVS --exclude=.svn ./mount/loop.h /tmp/dpep-work.31redI/util-linux/mount/loop.h
+--- ./mount/loop.h	2005-08-16 11:50:21.000000000 -0600
++++ /tmp/dpep-work.31redI/util-linux/mount/loop.h	2006-01-16 11:09:51.000000000 -0700
+@@ -1,8 +1,39 @@
+-#define LO_CRYPT_NONE	0
+-#define LO_CRYPT_XOR	1
+-#define LO_CRYPT_DES	2
++#define LO_CRYPT_NONE  0
++#define LO_CRYPT_XOR   1
++#define LO_CRYPT_DES   2
+ #define LO_CRYPT_CRYPTOAPI 18
+ 
++#ifndef LO_CRYPT_FISH2
++#define LO_CRYPT_FISH2 3
++#endif
++#ifndef LO_CRYPT_BLOW
++#define LO_CRYPT_BLOW 4
++#endif
++#ifndef LO_CRYPT_CAST128
++#define LO_CRYPT_CAST128 5
++#endif
++#ifndef LO_CRYPT_IDEA
++#define LO_CRYPT_IDEA 6
++#endif
++#ifndef LO_CRYPT_SERPENT
++#define LO_CRYPT_SERPENT 7
++#endif
++#ifndef LO_CRYPT_MARS
++#define LO_CRYPT_MARS 8
++#endif
++#ifndef LO_CRYPT_RC6
++#define LO_CRYPT_RC6 11
++#endif
++#ifndef LO_CRYPT_3DES
++#define LO_CRYPT_3DES 12
++#endif
++#ifndef LO_CRYPT_DFC
++#define LO_CRYPT_DFC 15
++#endif
++#ifndef LO_CRYPT_RIJNDAEL
++#define LO_CRYPT_RIJNDAEL 16
++#endif
++
+ #define LOOP_SET_FD		0x4C00
+ #define LOOP_CLR_FD		0x4C01
+ #define LOOP_SET_STATUS		0x4C02
+diff -urNad --exclude=CVS --exclude=.svn ./mount/losetup.8 /tmp/dpep-work.31redI/util-linux/mount/losetup.8
+--- ./mount/losetup.8	2005-08-16 11:50:21.000000000 -0600
++++ /tmp/dpep-work.31redI/util-linux/mount/losetup.8	2006-01-16 11:09:51.000000000 -0700
+@@ -66,23 +66,29 @@
+ .B \-e
+ option.)
+ .SH OPTIONS
+-.IP \fB\-d\fP
+-Detach the file or device associated with the specified loop device.
++.IP "\fB\-\-delete, \-\-detach, \-d\fP"
++detach the file or device associated with the specified loop device.
+ .IP "\fB\-E \fIencryption_type\fP"
+ Enable data encryption with specified number.
+-.IP "\fB\-e \fIencryption_name\fP"
++.IP "\fB\-\-encryption, \-e \fIencryption\fP"
+ Enable data encryption with specified name.
+ .IP "\fB\-f\fP"
+ Find the first unused loop device. If a
+ .I file
+ argument is present, use this device. Otherwise, print its name.
++.IP "\fB\-\-nohashpass, \-N\fP"
++Do not hash the password.  By default, Debian systems run the password through a
++hash function, non-Debian systems tend not to.
++.IP "\fB\-\-offset, \-o \fIoffset\fP"
+ .IP "\fB\-o \fIoffset\fP"
+ The data start is moved \fIoffset\fP bytes into the specified file or
+ device.
+-.IP "\fB\-p \fInum\fP"
++.IP "\fB\-\-pass-fd, \-p \fInum\fP"
+ Read the passphrase from file descriptor with number
+ .I num
+ instead of from the terminal.
++.IP "\fB\-\-keybits, \-k \fInum\fP"
++set the number of bits to use in key to \fInum\fP.
+ .SH RETURN VALUE
+ .B losetup
+ returns 0 on success, nonzero on failure. When
+@@ -129,6 +135,9 @@
+ .fi
+ .SH RESTRICTION
+ DES encryption is painfully slow. On the other hand, XOR is terribly weak.
++Both are insecure nowadays. Some ciphers may require a licence for you to be
++allowed to use them.
++.fi
+ .\" .SH AUTHORS
+ .\" .nf
+ .\" Original version: Theodore Ts'o <tytso@athena.mit.edu>
+diff -urNad --exclude=CVS --exclude=.svn ./mount/mount.8 /tmp/dpep-work.31redI/util-linux/mount/mount.8
+--- ./mount/mount.8	2005-08-16 11:50:21.000000000 -0600
++++ /tmp/dpep-work.31redI/util-linux/mount/mount.8	2006-01-16 11:09:51.000000000 -0700
+@@ -281,6 +281,12 @@
+ .B \-v
+ Verbose mode.
+ .TP
++.B \-p "\fInum\fP"
++If the mount requires a passphrase to be entered, read it from file
++descriptor
++.IR num\fP
++instead of from the terminal.
++.TP
+ .B \-a
+ Mount all filesystems (of the given types) mentioned in
+ .IR fstab .
+@@ -653,6 +659,15 @@
+ .BR noexec ", " nosuid ", and " nodev
+ (unless overridden by subsequent options, as in the option line
+ .BR users,exec,dev,suid ).
++.TP
++.B encryption
++Specifies an encryption algorithm to use.  Used in conjunction with the
++.BR loop " option."
++.TP
++.B keybits
++Specifies the key size to use for an encryption algorithm. Used in conjunction
++with the
++.BR loop " and " encryption " options."
+ .RE
+ .TP
+ .B \-\-bind
+@@ -1845,6 +1860,10 @@
+ .BR loop ", " offset " and " encryption ,
+ that are really options to
+ .BR \%losetup (8).
++If the mount requires a passphrase, you will be prompted for one unless
++you specify a file descriptor to read from instead with the 
++.BR \-\-pass-fd
++option.
+ (These options can be used in addition to those specific
+ to the filesystem type.)
+ 
+@@ -1924,7 +1943,7 @@
+ .BR e2label (8),
+ .BR xfs_admin (8),
+ .BR mountd (8),
+-.BR nfsd (8),
++.BR rpc.nfsd (8),
+ .BR mke2fs (8),
+ .BR tune2fs (8),
+ .BR losetup (8)
+diff -urNad --exclude=CVS --exclude=.svn ./mount/mount.c /tmp/dpep-work.31redI/util-linux/mount/mount.c
+--- ./mount/mount.c	2005-08-16 11:50:21.000000000 -0600
++++ /tmp/dpep-work.31redI/util-linux/mount/mount.c	2006-01-16 11:09:51.000000000 -0700
+@@ -59,6 +59,9 @@
+ /* Nonzero for chatty (-v).  */
+ int verbose = 0;
+ 
++/* Do we hash the password or not */
++int hash_password = 1;
++
+ /* Nonzero for sloppy (-s).  */
+ int sloppy = 0;
+ 
+@@ -83,6 +86,9 @@
+ /* Contains the fd to read the passphrase from, if any. */
+ static int pfd = -1;
+ 
++/* Contains the preferred keysize in bits we want to use */
++static int keysz = 0;
++
+ /* Map from -o and fstab option strings to the flag argument to mount(2).  */
+ struct opt_map {
+   const char *opt;		/* option name */
+@@ -168,7 +174,7 @@
+ };
+ 
+ static const char *opt_loopdev, *opt_vfstype, *opt_offset, *opt_encryption,
+-	*opt_speed, *opt_comment;
++  *opt_keybits, *opt_nohashpass, *opt_speed, *opt_comment;
+ 
+ static struct string_opt_map {
+   char *tag;
+@@ -179,6 +185,8 @@
+   { "vfs=",	1, &opt_vfstype },
+   { "offset=",	0, &opt_offset },
+   { "encryption=", 0, &opt_encryption },
++  { "keybits=", 0, &opt_keybits },
++  { "nohashpass", 0, &opt_nohashpass },
+   { "speed=", 0, &opt_speed },
+   { "comment=", 1, &opt_comment },
+   { NULL, 0, NULL }
+@@ -607,7 +615,8 @@
+       *type = opt_vfstype;
+   }
+ 
+-  *loop = ((*flags & MS_LOOP) || *loopdev || opt_offset || opt_encryption);
++  *loop = ((*flags & MS_LOOP) || *loopdev || opt_offset || opt_encryption ||
++	   opt_keybits);
+   *loopfile = *spec;
+ 
+   if (*loop) {
+@@ -625,8 +634,12 @@
+       if (verbose)
+ 	printf(_("mount: going to use the loop device %s\n"), *loopdev);
+       offset = opt_offset ? strtoull(opt_offset, NULL, 0) : 0;
+-      if (set_loop(*loopdev, *loopfile, offset,
+-		   opt_encryption, pfd, &loopro)) {
++      if (!keysz && opt_keybits)
++	keysz  = strtoul(opt_keybits, NULL, 0);
++      if (opt_nohashpass)
++	hash_password=0;
++      if (set_loop (*loopdev, *loopfile, offset, opt_encryption, pfd, 
++		    keysz, &loopro, hash_password)) {
+ 	if (verbose)
+ 	  printf(_("mount: failed setting up loop device\n"));
+ 	return EX_FAIL;
+@@ -1405,6 +1418,7 @@
+ 	{ "options", 1, 0, 'o' },
+ 	{ "test-opts", 1, 0, 'O' },
+ 	{ "pass-fd", 1, 0, 'p' },
++	{ "keybits", 1, 0, 'k' },
+ 	{ "types", 1, 0, 't' },
+ 	{ "bind", 0, 0, 128 },
+ 	{ "replace", 0, 0, 129 },
+@@ -1461,6 +1475,8 @@
+ 	char *options = NULL, *test_opts = NULL, *node;
+ 	const char *spec;
+ 	char *volumelabel = NULL;
++	char *passfd = NULL;
++	char *keysize = NULL;
+ 	char *uuid = NULL;
+ 	char *types = NULL;
+ 	char *p;
+@@ -1491,7 +1507,7 @@
+ 	initproctitle(argc, argv);
+ #endif
+ 
+-	while ((c = getopt_long (argc, argv, "afFhilL:no:O:p:rsU:vVwt:",
++	while ((c = getopt_long (argc, argv, "afFhilL:k:no:O:p:rsU:vVwt:",
+ 				 longopts, NULL)) != -1) {
+ 		switch (c) {
+ 		case 'a':	       /* mount everything in fstab */
+@@ -1515,6 +1531,9 @@
+ 		case 'L':
+ 			volumelabel = optarg;
+ 			break;
++		case 'k':
++			keysize = optarg;
++			break;
+ 		case 'n':		/* do not write /etc/mtab */
+ 			++nomtab;
+ 			break;
+@@ -1635,6 +1654,11 @@
+ 	} else
+ 		spec = NULL;		/* just for gcc */
+ 
++	if (passfd && sscanf(passfd,"%d",&pfd) != 1)
++	        die (EX_USAGE, _("mount: argument to --pass-fd or -p must be a number"));
++	if (keysize && sscanf(keysize,"%d",&keysz) != 1)
++	        die (EX_USAGE, _("mount: argument to --keybits or -k must be a number"));
++
+ 	switch (argc+specseen) {
+ 	case 0:
+ 		/* mount -a */
+diff -urNad --exclude=CVS --exclude=.svn ./mount/rmd160.c /tmp/dpep-work.31redI/util-linux/mount/rmd160.c
+--- ./mount/rmd160.c	1969-12-31 17:00:00.000000000 -0700
++++ /tmp/dpep-work.31redI/util-linux/mount/rmd160.c	2006-01-16 11:09:51.000000000 -0700
+@@ -0,0 +1,532 @@
++/* rmd160.c  -	RIPE-MD160
++ *	Copyright (C) 1998 Free Software Foundation, Inc.
++ */
++
++/* This file was part of GnuPG. Modified for use within the Linux
++ * mount utility by Marc Mutz <Marc@Mutz.com>. None of this code is
++ * by myself. I just removed everything that you don't need when all
++ * you want to do is to use rmd160_hash_buffer().
++ * My comments are marked with (mm).  */
++
++/* GnuPG is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * GnuPG is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA */
++
++#include <string.h> /* (mm) for memcpy */
++#include <endian.h> /* (mm) for BIG_ENDIAN and BYTE_ORDER */
++#include "rmd160.h"
++
++/* (mm) these are used by the original GnuPG file. In order to modify
++ * that file not too much, we keep the notations. maybe it would be
++ * better to include linux/types.h and typedef __u32 to u32 and __u8
++ * to byte?  */
++typedef unsigned int u32; /* taken from e.g. util-linux's minix.h */
++typedef unsigned char byte;
++
++typedef struct {
++    u32  h0,h1,h2,h3,h4;
++    u32  nblocks;
++    byte buf[64];
++    int  count;
++} RMD160_CONTEXT;
++
++/****************
++ * Rotate a 32 bit integer by n bytes
++ */
++#if defined(__GNUC__) && defined(__i386__)
++static inline u32
++rol( u32 x, int n)
++{
++	__asm__("roll %%cl,%0"
++		:"=r" (x)
++		:"0" (x),"c" (n));
++	return x;
++}
++#else
++  #define rol(x,n) ( ((x) << (n)) | ((x) >> (32-(n))) )
++#endif
++
++/*********************************
++ * RIPEMD-160 is not patented, see (as of 25.10.97)
++ *   http://www.esat.kuleuven.ac.be/~bosselae/ripemd160.html
++ * Note that the code uses Little Endian byteorder, which is good for
++ * 386 etc, but we must add some conversion when used on a big endian box.
++ *
++ *
++ * Pseudo-code for RIPEMD-160
++ *
++ * RIPEMD-160 is an iterative hash function that operates on 32-bit words.
++ * The round function takes as input a 5-word chaining variable and a 16-word
++ * message block and maps this to a new chaining variable. All operations are
++ * defined on 32-bit words. Padding is identical to that of MD4.
++ *
++ *
++ * RIPEMD-160: definitions
++ *
++ *
++ *   nonlinear functions at bit level: exor, mux, -, mux, -
++ *
++ *   f(j, x, y, z) = x XOR y XOR z		  (0 <= j <= 15)
++ *   f(j, x, y, z) = (x AND y) OR (NOT(x) AND z)  (16 <= j <= 31)
++ *   f(j, x, y, z) = (x OR NOT(y)) XOR z	  (32 <= j <= 47)
++ *   f(j, x, y, z) = (x AND z) OR (y AND NOT(z))  (48 <= j <= 63)
++ *   f(j, x, y, z) = x XOR (y OR NOT(z))	  (64 <= j <= 79)
++ *
++ *
++ *   added constants (hexadecimal)
++ *
++ *   K(j) = 0x00000000	    (0 <= j <= 15)
++ *   K(j) = 0x5A827999	   (16 <= j <= 31)	int(2**30 x sqrt(2))
++ *   K(j) = 0x6ED9EBA1	   (32 <= j <= 47)	int(2**30 x sqrt(3))
++ *   K(j) = 0x8F1BBCDC	   (48 <= j <= 63)	int(2**30 x sqrt(5))
++ *   K(j) = 0xA953FD4E	   (64 <= j <= 79)	int(2**30 x sqrt(7))
++ *   K'(j) = 0x50A28BE6     (0 <= j <= 15)      int(2**30 x cbrt(2))
++ *   K'(j) = 0x5C4DD124    (16 <= j <= 31)      int(2**30 x cbrt(3))
++ *   K'(j) = 0x6D703EF3    (32 <= j <= 47)      int(2**30 x cbrt(5))
++ *   K'(j) = 0x7A6D76E9    (48 <= j <= 63)      int(2**30 x cbrt(7))
++ *   K'(j) = 0x00000000    (64 <= j <= 79)
++ *
++ *
++ *   selection of message word
++ *
++ *   r(j)      = j		      (0 <= j <= 15)
++ *   r(16..31) = 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8
++ *   r(32..47) = 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12
++ *   r(48..63) = 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2
++ *   r(64..79) = 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
++ *   r0(0..15) = 5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12
++ *   r0(16..31)= 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2
++ *   r0(32..47)= 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13
++ *   r0(48..63)= 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14
++ *   r0(64..79)= 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
++ *
++ *
++ *   amount for rotate left (rol)
++ *
++ *   s(0..15)  = 11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8
++ *   s(16..31) = 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12
++ *   s(32..47) = 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5
++ *   s(48..63) = 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12
++ *   s(64..79) = 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
++ *   s'(0..15) = 8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6
++ *   s'(16..31)= 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11
++ *   s'(32..47)= 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5
++ *   s'(48..63)= 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8
++ *   s'(64..79)= 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
++ *
++ *
++ *   initial value (hexadecimal)
++ *
++ *   h0 = 0x67452301; h1 = 0xEFCDAB89; h2 = 0x98BADCFE; h3 = 0x10325476;
++ *							h4 = 0xC3D2E1F0;
++ *
++ *
++ * RIPEMD-160: pseudo-code
++ *
++ *   It is assumed that the message after padding consists of t 16-word blocks
++ *   that will be denoted with X[i][j], with 0 <= i <= t-1 and 0 <= j <= 15.
++ *   The symbol [+] denotes addition modulo 2**32 and rol_s denotes cyclic left
++ *   shift (rotate) over s positions.
++ *
++ *
++ *   for i := 0 to t-1 {
++ *	 A := h0; B := h1; C := h2; D = h3; E = h4;
++ *	 A' := h0; B' := h1; C' := h2; D' = h3; E' = h4;
++ *	 for j := 0 to 79 {
++ *	     T := rol_s(j)(A [+] f(j, B, C, D) [+] X[i][r(j)] [+] K(j)) [+] E;
++ *	     A := E; E := D; D := rol_10(C); C := B; B := T;
++ *	     T := rol_s'(j)(A' [+] f(79-j, B', C', D') [+] X[i][r'(j)]
++						       [+] K'(j)) [+] E';
++ *	     A' := E'; E' := D'; D' := rol_10(C'); C' := B'; B' := T;
++ *	 }
++ *	 T := h1 [+] C [+] D'; h1 := h2 [+] D [+] E'; h2 := h3 [+] E [+] A';
++ *	 h3 := h4 [+] A [+] B'; h4 := h0 [+] B [+] C'; h0 := T;
++ *   }
++ */
++
++/* Some examples:
++ * ""                    9c1185a5c5e9fc54612808977ee8f548b2258d31
++ * "a"                   0bdc9d2d256b3ee9daae347be6f4dc835a467ffe
++ * "abc"                 8eb208f7e05d987a9b044a8e98c6b087f15a0bfc
++ * "message digest"      5d0689ef49d2fae572b881b123a85ffa21595f36
++ * "a...z"               f71c27109c692c1b56bbdceb5b9d2865b3708dbc
++ * "abcdbcde...nopq"     12a053384a9c0c88e405a06c27dcf49ada62eb2b
++ * "A...Za...z0...9"     b0e20b6e3116640286ed3a87a5713079b21f5189
++ * 8 times "1234567890"  9b752e45573d4b39f4dbd3323cab82bf63326bfb
++ * 1 million times "a"   52783243c1697bdbe16d37f97f68f08325dc1528
++ */
++
++
++static void
++rmd160_init( RMD160_CONTEXT *hd )
++{
++    hd->h0 = 0x67452301;
++    hd->h1 = 0xEFCDAB89;
++    hd->h2 = 0x98BADCFE;
++    hd->h3 = 0x10325476;
++    hd->h4 = 0xC3D2E1F0;
++    hd->nblocks = 0;
++    hd->count = 0;
++}
++
++
++
++/****************
++ * Transform the message X which consists of 16 32-bit-words
++ */
++static void
++transform( RMD160_CONTEXT *hd, byte *data )
++{
++    u32 a,b,c,d,e,aa,bb,cc,dd,ee,t;
++  #if BYTE_ORDER == BIG_ENDIAN
++    u32 x[16];
++    { int i;
++      byte *p2, *p1;
++      for(i=0, p1=data, p2=(byte*)x; i < 16; i++, p2 += 4 ) {
++	p2[3] = *p1++;
++	p2[2] = *p1++;
++	p2[1] = *p1++;
++	p2[0] = *p1++;
++      }
++    }
++  #else
++   #if 0
++    u32 *x =(u32*)data;
++   #else
++    /* this version is better because it is always aligned;
++     * The performance penalty on a 586-100 is about 6% which
++     * is acceptable - because the data is more local it might
++     * also be possible that this is faster on some machines.
++     * This function (when compiled with -02 on gcc 2.7.2)
++     * executes on a 586-100 (39.73 bogomips) at about 1900kb/sec;
++     * [measured with a 4MB data and "gpgm --print-md rmd160"] */
++    u32 x[16];
++    memcpy( x, data, 64 );
++   #endif
++  #endif
++
++
++#define K0  0x00000000
++#define K1  0x5A827999
++#define K2  0x6ED9EBA1
++#define K3  0x8F1BBCDC
++#define K4  0xA953FD4E
++#define KK0 0x50A28BE6
++#define KK1 0x5C4DD124
++#define KK2 0x6D703EF3
++#define KK3 0x7A6D76E9
++#define KK4 0x00000000
++#define F0(x,y,z)   ( (x) ^ (y) ^ (z) )
++#define F1(x,y,z)   ( ((x) & (y)) | (~(x) & (z)) )
++#define F2(x,y,z)   ( ((x) | ~(y)) ^ (z) )
++#define F3(x,y,z)   ( ((x) & (z)) | ((y) & ~(z)) )
++#define F4(x,y,z)   ( (x) ^ ((y) | ~(z)) )
++#define R(a,b,c,d,e,f,k,r,s) do { t = a + f(b,c,d) + k + x[r]; \
++				  a = rol(t,s) + e;	       \
++				  c = rol(c,10);	       \
++				} while(0)
++
++    /* left lane */
++    a = hd->h0;
++    b = hd->h1;
++    c = hd->h2;
++    d = hd->h3;
++    e = hd->h4;
++    R( a, b, c, d, e, F0, K0,  0, 11 );
++    R( e, a, b, c, d, F0, K0,  1, 14 );
++    R( d, e, a, b, c, F0, K0,  2, 15 );
++    R( c, d, e, a, b, F0, K0,  3, 12 );
++    R( b, c, d, e, a, F0, K0,  4,  5 );
++    R( a, b, c, d, e, F0, K0,  5,  8 );
++    R( e, a, b, c, d, F0, K0,  6,  7 );
++    R( d, e, a, b, c, F0, K0,  7,  9 );
++    R( c, d, e, a, b, F0, K0,  8, 11 );
++    R( b, c, d, e, a, F0, K0,  9, 13 );
++    R( a, b, c, d, e, F0, K0, 10, 14 );
++    R( e, a, b, c, d, F0, K0, 11, 15 );
++    R( d, e, a, b, c, F0, K0, 12,  6 );
++    R( c, d, e, a, b, F0, K0, 13,  7 );
++    R( b, c, d, e, a, F0, K0, 14,  9 );
++    R( a, b, c, d, e, F0, K0, 15,  8 );
++    R( e, a, b, c, d, F1, K1,  7,  7 );
++    R( d, e, a, b, c, F1, K1,  4,  6 );
++    R( c, d, e, a, b, F1, K1, 13,  8 );
++    R( b, c, d, e, a, F1, K1,  1, 13 );
++    R( a, b, c, d, e, F1, K1, 10, 11 );
++    R( e, a, b, c, d, F1, K1,  6,  9 );
++    R( d, e, a, b, c, F1, K1, 15,  7 );
++    R( c, d, e, a, b, F1, K1,  3, 15 );
++    R( b, c, d, e, a, F1, K1, 12,  7 );
++    R( a, b, c, d, e, F1, K1,  0, 12 );
++    R( e, a, b, c, d, F1, K1,  9, 15 );
++    R( d, e, a, b, c, F1, K1,  5,  9 );
++    R( c, d, e, a, b, F1, K1,  2, 11 );
++    R( b, c, d, e, a, F1, K1, 14,  7 );
++    R( a, b, c, d, e, F1, K1, 11, 13 );
++    R( e, a, b, c, d, F1, K1,  8, 12 );
++    R( d, e, a, b, c, F2, K2,  3, 11 );
++    R( c, d, e, a, b, F2, K2, 10, 13 );
++    R( b, c, d, e, a, F2, K2, 14,  6 );
++    R( a, b, c, d, e, F2, K2,  4,  7 );
++    R( e, a, b, c, d, F2, K2,  9, 14 );
++    R( d, e, a, b, c, F2, K2, 15,  9 );
++    R( c, d, e, a, b, F2, K2,  8, 13 );
++    R( b, c, d, e, a, F2, K2,  1, 15 );
++    R( a, b, c, d, e, F2, K2,  2, 14 );
++    R( e, a, b, c, d, F2, K2,  7,  8 );
++    R( d, e, a, b, c, F2, K2,  0, 13 );
++    R( c, d, e, a, b, F2, K2,  6,  6 );
++    R( b, c, d, e, a, F2, K2, 13,  5 );
++    R( a, b, c, d, e, F2, K2, 11, 12 );
++    R( e, a, b, c, d, F2, K2,  5,  7 );
++    R( d, e, a, b, c, F2, K2, 12,  5 );
++    R( c, d, e, a, b, F3, K3,  1, 11 );
++    R( b, c, d, e, a, F3, K3,  9, 12 );
++    R( a, b, c, d, e, F3, K3, 11, 14 );
++    R( e, a, b, c, d, F3, K3, 10, 15 );
++    R( d, e, a, b, c, F3, K3,  0, 14 );
++    R( c, d, e, a, b, F3, K3,  8, 15 );
++    R( b, c, d, e, a, F3, K3, 12,  9 );
++    R( a, b, c, d, e, F3, K3,  4,  8 );
++    R( e, a, b, c, d, F3, K3, 13,  9 );
++    R( d, e, a, b, c, F3, K3,  3, 14 );
++    R( c, d, e, a, b, F3, K3,  7,  5 );
++    R( b, c, d, e, a, F3, K3, 15,  6 );
++    R( a, b, c, d, e, F3, K3, 14,  8 );
++    R( e, a, b, c, d, F3, K3,  5,  6 );
++    R( d, e, a, b, c, F3, K3,  6,  5 );
++    R( c, d, e, a, b, F3, K3,  2, 12 );
++    R( b, c, d, e, a, F4, K4,  4,  9 );
++    R( a, b, c, d, e, F4, K4,  0, 15 );
++    R( e, a, b, c, d, F4, K4,  5,  5 );
++    R( d, e, a, b, c, F4, K4,  9, 11 );
++    R( c, d, e, a, b, F4, K4,  7,  6 );
++    R( b, c, d, e, a, F4, K4, 12,  8 );
++    R( a, b, c, d, e, F4, K4,  2, 13 );
++    R( e, a, b, c, d, F4, K4, 10, 12 );
++    R( d, e, a, b, c, F4, K4, 14,  5 );
++    R( c, d, e, a, b, F4, K4,  1, 12 );
++    R( b, c, d, e, a, F4, K4,  3, 13 );
++    R( a, b, c, d, e, F4, K4,  8, 14 );
++    R( e, a, b, c, d, F4, K4, 11, 11 );
++    R( d, e, a, b, c, F4, K4,  6,  8 );
++    R( c, d, e, a, b, F4, K4, 15,  5 );
++    R( b, c, d, e, a, F4, K4, 13,  6 );
++
++    aa = a; bb = b; cc = c; dd = d; ee = e;
++
++    /* right lane */
++    a = hd->h0;
++    b = hd->h1;
++    c = hd->h2;
++    d = hd->h3;
++    e = hd->h4;
++    R( a, b, c, d, e, F4, KK0,	5,  8);
++    R( e, a, b, c, d, F4, KK0, 14,  9);
++    R( d, e, a, b, c, F4, KK0,	7,  9);
++    R( c, d, e, a, b, F4, KK0,	0, 11);
++    R( b, c, d, e, a, F4, KK0,	9, 13);
++    R( a, b, c, d, e, F4, KK0,	2, 15);
++    R( e, a, b, c, d, F4, KK0, 11, 15);
++    R( d, e, a, b, c, F4, KK0,	4,  5);
++    R( c, d, e, a, b, F4, KK0, 13,  7);
++    R( b, c, d, e, a, F4, KK0,	6,  7);
++    R( a, b, c, d, e, F4, KK0, 15,  8);
++    R( e, a, b, c, d, F4, KK0,	8, 11);
++    R( d, e, a, b, c, F4, KK0,	1, 14);
++    R( c, d, e, a, b, F4, KK0, 10, 14);
++    R( b, c, d, e, a, F4, KK0,	3, 12);
++    R( a, b, c, d, e, F4, KK0, 12,  6);
++    R( e, a, b, c, d, F3, KK1,	6,  9);
++    R( d, e, a, b, c, F3, KK1, 11, 13);
++    R( c, d, e, a, b, F3, KK1,	3, 15);
++    R( b, c, d, e, a, F3, KK1,	7,  7);
++    R( a, b, c, d, e, F3, KK1,	0, 12);
++    R( e, a, b, c, d, F3, KK1, 13,  8);
++    R( d, e, a, b, c, F3, KK1,	5,  9);
++    R( c, d, e, a, b, F3, KK1, 10, 11);
++    R( b, c, d, e, a, F3, KK1, 14,  7);
++    R( a, b, c, d, e, F3, KK1, 15,  7);
++    R( e, a, b, c, d, F3, KK1,	8, 12);
++    R( d, e, a, b, c, F3, KK1, 12,  7);
++    R( c, d, e, a, b, F3, KK1,	4,  6);
++    R( b, c, d, e, a, F3, KK1,	9, 15);
++    R( a, b, c, d, e, F3, KK1,	1, 13);
++    R( e, a, b, c, d, F3, KK1,	2, 11);
++    R( d, e, a, b, c, F2, KK2, 15,  9);
++    R( c, d, e, a, b, F2, KK2,	5,  7);
++    R( b, c, d, e, a, F2, KK2,	1, 15);
++    R( a, b, c, d, e, F2, KK2,	3, 11);
++    R( e, a, b, c, d, F2, KK2,	7,  8);
++    R( d, e, a, b, c, F2, KK2, 14,  6);
++    R( c, d, e, a, b, F2, KK2,	6,  6);
++    R( b, c, d, e, a, F2, KK2,	9, 14);
++    R( a, b, c, d, e, F2, KK2, 11, 12);
++    R( e, a, b, c, d, F2, KK2,	8, 13);
++    R( d, e, a, b, c, F2, KK2, 12,  5);
++    R( c, d, e, a, b, F2, KK2,	2, 14);
++    R( b, c, d, e, a, F2, KK2, 10, 13);
++    R( a, b, c, d, e, F2, KK2,	0, 13);
++    R( e, a, b, c, d, F2, KK2,	4,  7);
++    R( d, e, a, b, c, F2, KK2, 13,  5);
++    R( c, d, e, a, b, F1, KK3,	8, 15);
++    R( b, c, d, e, a, F1, KK3,	6,  5);
++    R( a, b, c, d, e, F1, KK3,	4,  8);
++    R( e, a, b, c, d, F1, KK3,	1, 11);
++    R( d, e, a, b, c, F1, KK3,	3, 14);
++    R( c, d, e, a, b, F1, KK3, 11, 14);
++    R( b, c, d, e, a, F1, KK3, 15,  6);
++    R( a, b, c, d, e, F1, KK3,	0, 14);
++    R( e, a, b, c, d, F1, KK3,	5,  6);
++    R( d, e, a, b, c, F1, KK3, 12,  9);
++    R( c, d, e, a, b, F1, KK3,	2, 12);
++    R( b, c, d, e, a, F1, KK3, 13,  9);
++    R( a, b, c, d, e, F1, KK3,	9, 12);
++    R( e, a, b, c, d, F1, KK3,	7,  5);
++    R( d, e, a, b, c, F1, KK3, 10, 15);
++    R( c, d, e, a, b, F1, KK3, 14,  8);
++    R( b, c, d, e, a, F0, KK4, 12,  8);
++    R( a, b, c, d, e, F0, KK4, 15,  5);
++    R( e, a, b, c, d, F0, KK4, 10, 12);
++    R( d, e, a, b, c, F0, KK4,	4,  9);
++    R( c, d, e, a, b, F0, KK4,	1, 12);
++    R( b, c, d, e, a, F0, KK4,	5,  5);
++    R( a, b, c, d, e, F0, KK4,	8, 14);
++    R( e, a, b, c, d, F0, KK4,	7,  6);
++    R( d, e, a, b, c, F0, KK4,	6,  8);
++    R( c, d, e, a, b, F0, KK4,	2, 13);
++    R( b, c, d, e, a, F0, KK4, 13,  6);
++    R( a, b, c, d, e, F0, KK4, 14,  5);
++    R( e, a, b, c, d, F0, KK4,	0, 15);
++    R( d, e, a, b, c, F0, KK4,	3, 13);
++    R( c, d, e, a, b, F0, KK4,	9, 11);
++    R( b, c, d, e, a, F0, KK4, 11, 11);
++
++
++    t	   = hd->h1 + d + cc;
++    hd->h1 = hd->h2 + e + dd;
++    hd->h2 = hd->h3 + a + ee;
++    hd->h3 = hd->h4 + b + aa;
++    hd->h4 = hd->h0 + c + bb;
++    hd->h0 = t;
++}
++
++
++/* Update the message digest with the contents
++ * of INBUF with length INLEN.
++ */
++static void
++rmd160_write( RMD160_CONTEXT *hd, byte *inbuf, size_t inlen)
++{
++    if( hd->count == 64 ) { /* flush the buffer */
++	transform( hd, hd->buf );
++	hd->count = 0;
++	hd->nblocks++;
++    }
++    if( !inbuf )
++	return;
++    if( hd->count ) {
++	for( ; inlen && hd->count < 64; inlen-- )
++	    hd->buf[hd->count++] = *inbuf++;
++	rmd160_write( hd, NULL, 0 );
++	if( !inlen )
++	    return;
++    }
++
++    while( inlen >= 64 ) {
++	transform( hd, inbuf );
++	hd->count = 0;
++	hd->nblocks++;
++	inlen -= 64;
++	inbuf += 64;
++    }
++    for( ; inlen && hd->count < 64; inlen-- )
++	hd->buf[hd->count++] = *inbuf++;
++}
++
++/* The routine terminates the computation
++ */
++
++static void
++rmd160_final( RMD160_CONTEXT *hd )
++{
++    u32 t, msb, lsb;
++    byte *p;
++
++    rmd160_write(hd, NULL, 0); /* flush */;
++
++    msb = 0;
++    t = hd->nblocks;
++    if( (lsb = t << 6) < t ) /* multiply by 64 to make a byte count */
++	msb++;
++    msb += t >> 26;
++    t = lsb;
++    if( (lsb = t + hd->count) < t ) /* add the count */
++	msb++;
++    t = lsb;
++    if( (lsb = t << 3) < t ) /* multiply by 8 to make a bit count */
++	msb++;
++    msb += t >> 29;
++
++    if( hd->count < 56 ) { /* enough room */
++	hd->buf[hd->count++] = 0x80; /* pad */
++	while( hd->count < 56 )
++	    hd->buf[hd->count++] = 0;  /* pad */
++    }
++    else { /* need one extra block */
++	hd->buf[hd->count++] = 0x80; /* pad character */
++	while( hd->count < 64 )
++	    hd->buf[hd->count++] = 0;
++	rmd160_write(hd, NULL, 0);  /* flush */;
++	memset(hd->buf, 0, 56 ); /* fill next block with zeroes */
++    }
++    /* append the 64 bit count */
++    hd->buf[56] = lsb	   ;
++    hd->buf[57] = lsb >>  8;
++    hd->buf[58] = lsb >> 16;
++    hd->buf[59] = lsb >> 24;
++    hd->buf[60] = msb	   ;
++    hd->buf[61] = msb >>  8;
++    hd->buf[62] = msb >> 16;
++    hd->buf[63] = msb >> 24;
++    transform( hd, hd->buf );
++
++    p = hd->buf;
++  #if BYTE_ORDER == BIG_ENDIAN
++    #define X(a) do { *p++ = hd->h##a	   ; *p++ = hd->h##a >> 8;	\
++		      *p++ = hd->h##a >> 16; *p++ = hd->h##a >> 24; } while(0)
++  #else /* little endian */
++    #define X(a) do { *(u32*)p = hd->h##a ; p += 4; } while(0)
++  #endif
++    X(0);
++    X(1);
++    X(2);
++    X(3);
++    X(4);
++  #undef X
++}
++
++/****************
++ * Shortcut functions which puts the hash value of the supplied buffer
++ * into outbuf which must have a size of 20 bytes.
++ */
++void
++rmd160_hash_buffer( char *outbuf, const char *buffer, size_t length )
++{
++    RMD160_CONTEXT hd;
++
++    rmd160_init( &hd );
++    rmd160_write( &hd, (byte*)buffer, length );
++    rmd160_final( &hd );
++    memcpy( outbuf, hd.buf, 20 );
++}
+diff -urNad --exclude=CVS --exclude=.svn ./mount/rmd160.h /tmp/dpep-work.31redI/util-linux/mount/rmd160.h
+--- ./mount/rmd160.h	1969-12-31 17:00:00.000000000 -0700
++++ /tmp/dpep-work.31redI/util-linux/mount/rmd160.h	2006-01-16 11:09:51.000000000 -0700
+@@ -0,0 +1,9 @@
++#ifndef RMD160_H
++#define RMD160_H
++
++void
++rmd160_hash_buffer( char *outbuf, const char *buffer, size_t length );
++
++#endif /*RMD160_H*/
++
++
--- util-linux-2.12r.orig/debian/patches/10sparcumount.dpatch
+++ util-linux-2.12r/debian/patches/10sparcumount.dpatch
@@ -0,0 +1,18 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 10sparcumount.dpatch by Jeff Bailey <jbailey@ubuntu.com>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Sparc and Arm have umount2 in glibc.
+
+@DPATCH@
+--- util-linux/mount/umount.c	2005-05-20 11:39:07.000000000 +0000
++++ util-linux/mount/umount.c	2005-05-20 11:39:15.000000000 +0000
+@@ -31,7 +31,7 @@
+ #include <arpa/inet.h>
+ #endif
+ 
+-#if defined(MNT_FORCE) && !defined(__sparc__) && !defined(__arm__)
++#if defined(MNT_FORCE) 
+ /* Interesting ... it seems libc knows about MNT_FORCE and presumably
+    about umount2 as well -- need not do anything */
+ #else /* MNT_FORCE */
--- util-linux-2.12r.orig/debian/patches/10warnings.dpatch
+++ util-linux-2.12r/debian/patches/10warnings.dpatch
@@ -0,0 +1,33 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 10warnings.dpatch by LaMont Jones <lamont@debian.org>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Fix compiler warnings
+
+@DPATCH@
+diff -urNad --exclude=CVS --exclude=.svn ./misc-utils/ddate.c /tmp/dpep-work.BBs5Mx/util-linux/misc-utils/ddate.c
+--- ./misc-utils/ddate.c	2004-09-06 15:12:40.000000000 -0600
++++ /tmp/dpep-work.BBs5Mx/util-linux/misc-utils/ddate.c	2006-01-15 18:25:14.000000000 -0700
+@@ -296,6 +296,7 @@
+     int cal[12] = { 31,28,31,30,31,30,31,31,30,31,30,31 };
+     int dayspast=0;
+ 
++    memset(&funkychickens,0,sizeof(funkychickens));
+     /* basic range checks */
+     if (imonth < 1 || imonth > 12) {
+ 	    funkychickens.season = -1;
+diff -urNad --exclude=CVS --exclude=.svn ./misc-utils/script.c /tmp/dpep-work.BBs5Mx/util-linux/misc-utils/script.c
+--- ./misc-utils/script.c	2004-12-15 08:32:52.000000000 -0700
++++ /tmp/dpep-work.BBs5Mx/util-linux/misc-utils/script.c	2006-01-15 18:25:57.000000000 -0700
+@@ -325,9 +325,9 @@
+ 		shname = shell;
+ 
+ 	if (cflg)
+-		execl(shell, shname, "-c", cflg, 0);
++		execl(shell, shname, "-c", cflg, NULL);
+ 	else
+-		execl(shell, shname, "-i", 0);
++		execl(shell, shname, "-i", NULL);
+ 
+ 	perror(shell);
+ 	fail();
--- util-linux-2.12r.orig/debian/patches/20guesshelper.dpatch
+++ util-linux-2.12r/debian/patches/20guesshelper.dpatch
@@ -0,0 +1,197 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 20guesshelper.dpatch by LaMont Jones <lamont@debian.org>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: If /sbin/mount.${FSTYPE} exists, use it as a helper program to mount
+## DP: the filesystem.
+
+@DPATCH@
+diff -urNad util-linux/mount/mount.c /tmp/dpep.EXkuMo/util-linux/mount/mount.c
+--- util-linux/mount/mount.c	2005-08-16 11:48:18.000000000 -0600
++++ /tmp/dpep.EXkuMo/util-linux/mount/mount.c	2005-08-16 11:48:35.000000000 -0600
+@@ -468,6 +468,61 @@
+ }
+ 
+ /*
++ * check_special_mountprog()
++ *	If there is a special mount program for this type, exec it.
++ * returns: 0: no exec was done, 1: exec was done, status has result
++ */
++
++static int
++check_special_mountprog(const char *spec, const char *node, const char *type,
++			int flags, char *extra_opts, int *status) {
++  char mountprog[120];
++  struct stat statbuf;
++  int res;
++
++  if (!external_allowed)
++      return 0;
++
++  if (type && strlen(type) < 100) {
++       sprintf(mountprog, "/sbin/mount.%s", type);
++       if (stat(mountprog, &statbuf) == 0) {
++	    res = fork();
++	    if (res == 0) {
++		 const char *oo, *mountargs[10];
++		 int i = 0;
++
++		 setuid(getuid());
++		 setgid(getgid());
++		 oo = fix_opts_string (flags, extra_opts, NULL);
++		 mountargs[i++] = mountprog;
++		 mountargs[i++] = spec;
++		 mountargs[i++] = node;
++		 if (nomtab)
++		      mountargs[i++] = "-n";
++		 if (verbose)
++		      mountargs[i++] = "-v";
++		 if (oo && *oo) {
++		      mountargs[i++] = "-o";
++		      mountargs[i++] = oo;
++		 }
++		 mountargs[i] = NULL;
++		 execv(mountprog, (char **) mountargs);
++		 exit(1);	/* exec failed */
++	    } else if (res != -1) {
++		 int st;
++		 wait(&st);
++		 *status = (WIFEXITED(st) ? WEXITSTATUS(st) : EX_SYSERR);
++		 return 1;
++	    } else {
++	    	 int errsv = errno;
++		 error(_("mount: cannot fork: %s"), strerror(errsv));
++	    }
++       }
++  }
++  return 0;
++}
++
++/*
+  * guess_fstype_and_mount()
+  *	Mount a single file system. Guess the type when unknown.
+  * returns: 0: OK, -1: error in errno, 1: other error
+@@ -476,9 +531,11 @@
+  */
+ static int
+ guess_fstype_and_mount(const char *spec, const char *node, const char **types,
+-		       int flags, char *mount_opts) {
++		       int flags, char *mount_opts, int *special, int *status) {
+    struct mountargs args = { spec, node, NULL, flags & ~MS_NOSYS, mount_opts };
+-   
++
++   *special = 0;
++
+    if (*types && strcasecmp (*types, "auto") == 0)
+       *types = NULL;
+ 
+@@ -487,10 +544,16 @@
+ 
+    if (!*types && !(flags & MS_REMOUNT)) {
+       *types = guess_fstype(spec);
+-      if (*types && !strcmp(*types, "swap")) {
+-	  error(_("%s looks like swapspace - not mounted"), spec);
+-	  *types = NULL;
+-	  return 1;
++      if (*types) {
++	  if (!strcmp(*types, "swap")) {
++	      error(_("%s looks like swapspace - not mounted"), spec);
++	      *types = NULL;
++	      return 1;
++	  } else if (check_special_mountprog(spec, node, *types, flags,
++					     mount_opts, status)) {
++	      *special = 1;
++	      return 0;
++	  }
+       }
+    }
+ 
+@@ -726,61 +789,6 @@
+ }
+ 
+ /*
+- * check_special_mountprog()
+- *	If there is a special mount program for this type, exec it.
+- * returns: 0: no exec was done, 1: exec was done, status has result
+- */
+-
+-static int
+-check_special_mountprog(const char *spec, const char *node, const char *type,
+-			int flags, char *extra_opts, int *status) {
+-  char mountprog[120];
+-  struct stat statbuf;
+-  int res;
+-
+-  if (!external_allowed)
+-      return 0;
+-
+-  if (type && strlen(type) < 100) {
+-       sprintf(mountprog, "/sbin/mount.%s", type);
+-       if (stat(mountprog, &statbuf) == 0) {
+-	    res = fork();
+-	    if (res == 0) {
+-		 const char *oo, *mountargs[10];
+-		 int i = 0;
+-
+-		 setuid(getuid());
+-		 setgid(getgid());
+-		 oo = fix_opts_string (flags, extra_opts, NULL);
+-		 mountargs[i++] = mountprog;
+-		 mountargs[i++] = spec;
+-		 mountargs[i++] = node;
+-		 if (nomtab)
+-		      mountargs[i++] = "-n";
+-		 if (verbose)
+-		      mountargs[i++] = "-v";
+-		 if (oo && *oo) {
+-		      mountargs[i++] = "-o";
+-		      mountargs[i++] = oo;
+-		 }
+-		 mountargs[i] = NULL;
+-		 execv(mountprog, (char **) mountargs);
+-		 exit(1);	/* exec failed */
+-	    } else if (res != -1) {
+-		 int st;
+-		 wait(&st);
+-		 *status = (WIFEXITED(st) ? WEXITSTATUS(st) : EX_SYSERR);
+-		 return 1;
+-	    } else {
+-	    	 int errsv = errno;
+-		 error(_("mount: cannot fork: %s"), strerror(errsv));
+-	    }
+-       }
+-  }
+-  return 0;
+-}
+-
+-/*
+  * try_mount_one()
+  *	Try to mount one file system. When "bg" is 1, this is a retry
+  *	in the background. One additional exit code EX_BG is used here.
+@@ -792,7 +800,7 @@
+ static int
+ try_mount_one (const char *spec0, const char *node0, const char *types0,
+ 	       const char *opts0, int freq, int pass, int bg, int ro) {
+-  int res = 0, status;
++  int res = 0, status, special;
+   int mnt5_res = 0;		/* only for gcc */
+   int mnt_err;
+   int flags;
+@@ -868,9 +876,15 @@
+ 
+   block_signals (SIG_BLOCK);
+ 
+-  if (!fake)
++  if (!fake) {
+     mnt5_res = guess_fstype_and_mount (spec, node, &types, flags & ~MS_NOSYS,
+-				       mount_opts);
++				       mount_opts, &special, &status);
++
++    if (special) {
++        res = status;
++        goto out;
++    }
++  }
+ 
+   if (fake || mnt5_res == 0) {
+       /* Mount succeeded, report this (if verbose) and write mtab entry.  */
--- util-linux-2.12r.orig/debian/patches/20xgethostname.dpatch
+++ util-linux-2.12r/debian/patches/20xgethostname.dpatch
@@ -0,0 +1,720 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 20xgethostname.dpatch by LaMont Jones <lamont@debian.org>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Use xgethostname instead of gethostname
+
+@DPATCH@
+diff -urNad util-linux/lib/Makefile /tmp/dpep.YGr3Vu/util-linux/lib/Makefile
+--- util-linux/lib/Makefile	2002-11-02 06:51:26.000000000 -0700
++++ /tmp/dpep.YGr3Vu/util-linux/lib/Makefile	2004-12-15 08:20:23.534627822 -0700
+@@ -1,8 +1,9 @@
+ include ../make_include
+ include ../MCONFIG
+ 
+-all: err.o my_reboot.o setproctitle.o env.o carefulputc.o xstrncpy.o md5.o
+-
++all: err.o my_reboot.o setproctitle.o env.o carefulputc.o md5.o \
++	xgethostname.o xstrncpy.o
++ 
+ err.o: err.c
+ 
+ my_reboot.o: my_reboot.c linux_reboot.h
+@@ -15,6 +16,8 @@
+ 
+ xstrncpy.o: xstrncpy.h
+ 
++xgethostname.o: xgethostname.h
++
+ md5.o: md5.c md5.h
+ 
+ .PHONY: clean
+diff -urNad util-linux/lib/README.xgethostname /tmp/dpep.YGr3Vu/util-linux/lib/README.xgethostname
+--- util-linux/lib/README.xgethostname	1969-12-31 17:00:00.000000000 -0700
++++ /tmp/dpep.YGr3Vu/util-linux/lib/README.xgethostname	2004-12-15 08:20:23.534627822 -0700
+@@ -0,0 +1,76 @@
++A wrapper for gethostname that automatically checks system limitations.
++
++Latest version can always be found at:
++ftp://walfield.org/pub/people/neal/xgethostname/xgethostname-latest.tar.gz
++
++Author:
++Neal H Walfield <neal@cs.uml.edu>
++
++Version:
++April 13, 2002
++
++ChangeLog:
++2002-04-13  Neal H Walfield  <neal@walfield.org>
++
++	* VERSION: Update to 20010413.
++	* Release version 20010413.
++	
++2002-04-13  Neal H Walfield  <neal@walfield.org>
++
++	* xgethostname.c (xgethostname): gethostname returns -1 on error,
++	not the error code.  There is no need to use realloc as it copies
++	the unused buffer.
++
++2001-08-03  Neal H Walfield  <neal@cs.uml.edu>
++
++	* VERSION: Update to 20010803.
++	* Release version 20010803.
++
++2001-08-03  Neal H Walfield  <neal@cs.uml.edu>
++
++	* Makefile: Make no assumptions about the make that the user
++	will be using.
++	* xgethostname.c (xgethostname): Be explicitly sure that the
++	returned buffer is NULL terminated.
++	Always compile in the while (err = ENAMETOOLONG) loop; this
++	may help to catch a very exotic implementation and does not
++	hurt anyone.
++
++2001-08-02  Neal H Walfield  <neal@cs.uml.edu>
++
++	* Release version 20010802.
++
++2001-08-01  Neal H Walfield  <neal@cs.uml.edu>
++
++	* Makefile: New file.
++	* README: New file.
++	* xgethostname.c (xgethostname) [!_SC_HOST_NAME_MAX]: Should
++	not be subject to this condition.
++	(xgethostname): If the system defines a limit < 256 and > 0,
++	do not artificially inflate it, rather, respect it.
++
++2001-07-30  Neal H Walfield  <neal@cs.uml.edu>
++
++	* REAMME: Move from here . . .
++	* xgethostname.2: to here.
++	Format it for man.
++
++2001-07-30  Neal H Walfield  <neal@cs.uml.edu>
++
++	* README: Fix grammer error.
++	* xgethostname.c: Likewise.
++	* xgethostname.h: Likewise.
++
++	* Makefile: New file.
++
++2001-07-29  Neal H Walfield  <neal@cs.uml.edu>
++
++	* Release version 20010729.
++
++	* AUTHOR: New file.
++	* ChangeLog: New file.
++	* COPYING: New file.
++	* README: New file.
++	* VERSION: New file.
++	* xgethostname.c: New file.
++	* xgethostname.h: New file.
+diff -urNad util-linux/lib/xgethostname.2 /tmp/dpep.YGr3Vu/util-linux/lib/xgethostname.2
+--- util-linux/lib/xgethostname.2	1969-12-31 17:00:00.000000000 -0700
++++ /tmp/dpep.YGr3Vu/util-linux/lib/xgethostname.2	2004-12-15 08:20:23.534627822 -0700
+@@ -0,0 +1,37 @@
++.TH XGETHOSTNAME 2 "30 July 2001" "xgethostname"
++.SH NAME
++xgethostname \- get the host name.
++.SH
++SYNOPSIS
++.BI "char *xgethostname (void);"
++.SH DESCRIPTION
++The xhostname function is intended to replace
++.BR gethostname(2),
++a function used to access the host name.  The old interface is
++inflexable given that it assumes the existance of the
++.BR MAXHOSTNAMELEN
++macro, which neither
++.BR POSIX
++nor the proposed
++.BR "Single Unix Specification version 3"
++guarantee to be defined.
++.SH RETURN VALUE
++On success, a malloced, null terminated (possibly truncated)
++string containing the host name is returned.  On failure,
++.I NULL
++is returned and errno is set.
++.SH ERRORS
++.TP
++.BR ENOMEM
++Failed to allocate memory.
++.LP
++As 
++.BR xgethostname
++is really just a wrapper around your systems
++.BR gethostname (2),
++see that man page for additional details.
++.SH "SEE ALSO"
++.BR gethostname (2)
++.SH AUTHOR
++.BR xgethostname
++was written by Neal H Walfield  <neal@cs.uml.edu>.
+diff -urNad util-linux/lib/xgethostname.c /tmp/dpep.YGr3Vu/util-linux/lib/xgethostname.c
+--- util-linux/lib/xgethostname.c	1969-12-31 17:00:00.000000000 -0700
++++ /tmp/dpep.YGr3Vu/util-linux/lib/xgethostname.c	2004-12-15 08:20:23.535627607 -0700
+@@ -0,0 +1,126 @@
++/* Copyright (c) 2001 Neal H Walfield <neal@cs.uml.edu>.
++   
++   This file is placed into the public domain.  Its distribution
++   is unlimited.
++
++   THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
++   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
++   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
++   IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY
++   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
++   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
++   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
++   IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
++   OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
++   IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
++ */
++
++/* NAME
++
++	xgethostname - get the host name.
++
++   SYNOPSIS
++
++   	char *xgethostname (void);
++
++   DESCRIPTION
++
++	The xhostname function is intended to replace gethostname(2), a
++	function used to access the host name.  The old interface is
++	inflexable given that it assumes the existance of the
++	MAXHOSTNAMELEN macro, which neither POSIX nor the proposed
++	Single Unix Specification version 3 guarantee to be defined.
++
++   RETURN VALUE
++
++	On success, a malloced, null terminated (possibly truncated)
++	string containing the host name is returned.  On failure,
++	NULL is returned and errno is set.
++ */
++
++#include <sys/param.h>	/* For MAXHOSTNAMELEN */
++#include <stdlib.h>
++#include <errno.h>
++#include <unistd.h>
++#include "xgethostname.h"
++
++char *
++xgethostname (void)
++{
++  int size = 0;
++  int addnull = 0;
++  char *buf;
++  int err;
++
++#ifdef MAXHOSTNAMELEN
++  size = MAXHOSTNAMELEN;
++  addnull = 1;
++#else /* MAXHOSTNAMELEN */
++#ifdef _SC_HOST_NAME_MAX
++  size = sysconf (_SC_HOST_NAME_MAX);
++  addnull = 1;
++#endif /* _SC_HOST_NAME_MAX */
++  if (size <= 0)
++    size = 256;
++#endif /* MAXHOSTNAMELEN */
++
++  buf = malloc (size + addnull);
++  if (! buf)
++    {
++      errno = ENOMEM;
++      return NULL;
++    }
++
++  err = gethostname (buf, size);
++  while (err == -1 && errno == ENAMETOOLONG)
++    {
++      free (buf);
++
++      size *= 2;
++      buf = malloc (size + addnull);
++      if (! buf)
++	{
++	  errno = ENOMEM;
++	  return NULL;
++	}
++      
++      err = gethostname (buf, size);
++    }
++
++  if (err)
++    {
++      if (buf)
++        free (buf);
++      errno = err;
++      return NULL;
++    }
++
++  if (addnull)
++    buf[size] = '\0';
++
++  return buf;
++}
++
++#ifdef WANT_TO_TEST_XGETHOSTNAME
++#include <stdio.h>
++#include <string.h>
++
++int
++main (int argc, char *argv[])
++{
++  char *hostname;
++
++  hostname = xgethostname ();
++  if (! hostname)
++    {
++      perror ("xgethostname");
++      return 1;
++    }
++
++  printf ("%s\n", hostname);
++  free (hostname);
++
++  return 0;
++}
++#endif /* WANT_TO_TEST_XGETHOSTNAME */
+diff -urNad util-linux/lib/xgethostname.h /tmp/dpep.YGr3Vu/util-linux/lib/xgethostname.h
+--- util-linux/lib/xgethostname.h	1969-12-31 17:00:00.000000000 -0700
++++ /tmp/dpep.YGr3Vu/util-linux/lib/xgethostname.h	2004-12-15 08:20:23.535627607 -0700
+@@ -0,0 +1,48 @@
++/* Copyright (c) 2001 Neal H Walfield <neal@cs.uml.edu>.
++   
++   This file is placed into the public domain.  Its distribution
++   is unlimited.
++
++   THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
++   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
++   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
++   IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY
++   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
++   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
++   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
++   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
++   IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
++   OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
++   IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
++ */
++
++/* NAME
++
++	xgethostname - get the host name.
++
++   SYNOPSIS
++
++   	char *xgethostname (void);
++
++   DESCRIPTION
++
++	The xhostname function is intended to replace gethostname(2), a
++	function used to access the host name.  The old interface is
++	inflexable given that it assumes the existance of the
++	MAXHOSTNAMELEN macro, which neither POSIX nor the proposed
++	Single Unix Specification version 3 guarantee to be defined.
++
++   RETURN VALUE
++
++	On success, a malloced, null terminated (possibly truncated)
++	string containing the host name is returned.  On failure,
++	NULL is returned and errno is set.
++ */
++
++#ifndef XGETHOSTNAME
++#define XGETHOSTNAME
++
++char * xgethostname (void);
++
++#endif /* XGETHOSTNAME */
++
+diff -urNad util-linux/login-utils/Makefile /tmp/dpep.YGr3Vu/util-linux/login-utils/Makefile
+--- util-linux/login-utils/Makefile	2004-11-23 09:06:57.000000000 -0700
++++ /tmp/dpep.YGr3Vu/util-linux/login-utils/Makefile	2004-12-15 08:20:23.530628681 -0700
+@@ -100,18 +100,18 @@
+ shutdown.o simpleinit.o: $(LIB)/linux_reboot.h
+ wall.o: ttymsg.h $(LIB)/carefulputc.h
+ 
+-agetty: agetty.o $(LIB)/xstrncpy.o
++agetty: agetty.o $(LIB)/xstrncpy.o $(LIB)/xgethostname.o
+ chfn: chfn.o islocal.o setpwnam.o $(SELINUXOBJS) $(LIB)/env.o $(LIB)/xstrncpy.o
+ 	$(CC) $(LDFLAGS) -o $@ $^ $(CRYPT) $(PAM) $(SELINUXLLIB)
+ chsh: chsh.o islocal.o setpwnam.o $(SELINUXOBJS) $(LIB)/env.o
+ 	$(CC) $(LDFLAGS) -o $@ $^ $(CRYPT) $(PAM) $(SELINUXLLIB)
+-last: last.o
++last: last.o $(LIB)/xgethostname.o
+ 
+ ifeq "$(HAVE_PAM)" "yes"
+-login: login.o $(LIB)/setproctitle.o $(LIB)/xstrncpy.o
++login: login.o $(LIB)/setproctitle.o $(LIB)/xstrncpy.o $(LIB)/xgethostname.o
+ 	$(CC) $(LDFLAGS) -o $@ $^ $(CRYPT) $(PAM) $(SELINUXLLIB)
+ else
+-login: login.o $(LIB)/xstrncpy.o $(LIB)/setproctitle.o checktty.o 
++login: login.o $(LIB)/xstrncpy.o $(LIB)/xgethostname.o $(LIB)/setproctitle.o checktty.o 
+ 	$(CC) $(LDFLAGS) -o $@ $^ $(CRYPT) $(SELINUXLLIB)
+ endif
+ 
+@@ -134,7 +134,8 @@
+ newgrp.o: $(LIB)/pathnames.h
+ 	$(CC) -c $(CFLAGS) $(PAMFL) newgrp.c 
+ 
+-wall: wall.o ttymsg.o $(LIB)/carefulputc.o $(LIB)/xstrncpy.o
++wall: wall.o ttymsg.o $(LIB)/carefulputc.o $(LIB)/xstrncpy.o \
++		$(LIB)/xgethostname.o
+ 
+ LOGINFLAGS=
+ ifeq "$(USE_TTY_GROUP)" "yes"
+@@ -147,7 +148,8 @@
+ 	LOGINFLAGS += -DDO_STAT_MAIL
+ endif
+ 
+-login.o: login.c $(LIB)/pathnames.h $(LIB)/setproctitle.c $(LIB)/setproctitle.h
++login.o: login.c $(LIB)/pathnames.h $(LIB)/setproctitle.c $(LIB)/setproctitle.h \
++		$(LIB)/xgethostname.h
+ 	$(CC) -c $(CFLAGS) $(PAMFL) $(LOGINFLAGS) login.c
+ 
+ # LOGINFLAGS here only for -DUSE_TTY_GROUP
+diff -urNad util-linux/login-utils/agetty.c /tmp/dpep.YGr3Vu/util-linux/login-utils/agetty.c
+--- util-linux/login-utils/agetty.c	2004-12-15 08:20:12.865921144 -0700
++++ /tmp/dpep.YGr3Vu/util-linux/login-utils/agetty.c	2004-12-15 08:20:23.531628466 -0700
+@@ -1019,10 +1019,12 @@
+ #endif
+ #ifdef __linux__
+ 	{
+-		char hn[MAXHOSTNAMELEN+1];
++		char *hn;
+ 
+-		(void) gethostname(hn, MAXHOSTNAMELEN);
++		if (!(hn = xgethostname()))
++			error(_("can't get hostname"));
+ 		write(1, hn, strlen(hn));
++		free(hn);
+ 	}
+ #endif		
+     (void) write(1, LOGIN, sizeof(LOGIN) - 1);	/* always show login prompt */
+diff -urNad util-linux/login-utils/last.c /tmp/dpep.YGr3Vu/util-linux/login-utils/last.c
+--- util-linux/login-utils/last.c	2002-03-08 15:59:41.000000000 -0700
++++ /tmp/dpep.YGr3Vu/util-linux/login-utils/last.c	2004-12-15 08:20:23.532628252 -0700
+@@ -49,6 +49,7 @@
+ 
+ #include "pathnames.h"
+ #include "nls.h"
++#include "xgethostname.h"
+ 
+ #define	SECDAY	(24*60*60)			/* seconds in a day */
+ #define	NO	0				/* false/no */
+@@ -430,15 +431,15 @@
+ hostconv(char *arg) {
+ 	static int	first = 1;
+ 	static char	*hostdot,
+-			name[MAXHOSTNAMELEN];
++			*name;
+ 	char	*argdot;
+ 
+ 	if (!(argdot = strchr(arg, '.')))
+ 		return;
+ 	if (first) {
+ 		first = 0;
+-		if (gethostname(name, sizeof(name))) {
+-			perror(_("last: gethostname"));
++		if (!(name = xgethostname())) {
++			perror(_("last: can't get hostname"));
+ 			exit(1);
+ 		}
+ 		hostdot = strchr(name, '.');
+diff -urNad util-linux/login-utils/login.c /tmp/dpep.lVXZel/util-linux/login-utils/login.c
+--- util-linux/login-utils/login.c	2004-12-04 19:37:12.000000000 -0700
++++ /tmp/dpep.lVXZel/util-linux/login-utils/login.c	2004-12-15 08:26:47.887008273 -0700
+@@ -116,6 +116,7 @@
+ #include "my_crypt.h"
+ #include "login.h"
+ #include "xstrncpy.h"
++#include "xgethostname.h"
+ #include "nls.h"
+ 
+ #ifdef __linux__
+@@ -356,7 +355,7 @@
+     int ask, fflag, hflag, pflag, cnt, errsv;
+     int quietlog, passwd_req;
+     char *domain, *ttyn;
+-    char tbuf[MAXPATHLEN + 2], tname[sizeof(_PATH_TTY) + 10];
++    char tname[sizeof(_PATH_TTY) + 10];
+     char *termenv;
+     char *childArgv[10];
+     char *buff;
+@@ -398,9 +397,11 @@
+      * -h is used by other servers to pass the name of the remote
+      *    host to login so that it may be placed in utmp and wtmp
+      */
+-    gethostname(tbuf, sizeof(tbuf));
+-    xstrncpy(thishost, tbuf, sizeof(thishost));
+-    domain = index(tbuf, '.');
++    if (!(thishost = xgethostname())) {
++	    fprintf(stderr, _("login: can't get hostname\n"));
++	    exit(1);
++    }
++    domain = index(thishost, '.');
+     
+     username = tty_name = hostname = NULL;
+     fflag = hflag = pflag = 0;
+diff -urNad util-linux/login-utils/wall.c /tmp/dpep.YGr3Vu/util-linux/login-utils/wall.c
+--- util-linux/login-utils/wall.c	2004-12-15 08:20:13.006890841 -0700
++++ /tmp/dpep.YGr3Vu/util-linux/login-utils/wall.c	2004-12-15 08:20:23.533628037 -0700
+@@ -54,6 +54,7 @@
+ #include <utmp.h>
+ 
+ #include "nls.h"
++#include "xgethostname.h"
+ #include "xstrncpy.h"
+ #include "ttymsg.h"
+ #include "pathnames.h"
+@@ -146,8 +147,7 @@
+ 	time_t now;
+ 	FILE *fp;
+ 	int fd;
+-	char *p, *whom, *where, hostname[MAXHOSTNAMELEN],
+-		lbuf[MAXHOSTNAMELEN + 320],
++	char *p, *whom, *where, *hostname, lbuf[1024],
+ 		tmpname[sizeof(_PATH_TMP) + 20];
+ 
+ 	(void)sprintf(tmpname, "%s/wall.XXXXXX", _PATH_TMP);
+@@ -158,6 +158,9 @@
+ 	(void)unlink(tmpname);
+ 
+ 	if (!nobanner) {
++		char *mesg, *mesg_notice;
++		int mesg_size, size;
++
+ 		if (!(whom = getlogin()) || !*whom)
+ 			whom = (pw = getpwuid(getuid())) ? pw->pw_name : "???";
+ 		if (!whom || strlen(whom) > 100)
+@@ -165,7 +168,11 @@
+ 		where = ttyname(2);
+ 		if (!where || strlen(where) > 100)
+ 			where = "somewhere";
+-		(void)gethostname(hostname, sizeof(hostname));
++		if (!(hostname = xgethostname())) {
++			(void)fprintf(stderr, _("%s: can't get hostname.\n"),
++				progname);
++			exit(1);
++		}
+ 		(void)time(&now);
+ 		lt = localtime(&now);
+ 
+@@ -178,13 +185,35 @@
+ 		 */
+ 		/* snprintf is not always available, but the sprintf's here
+ 		   will not overflow as long as %d takes at most 100 chars */
++
++		mesg_notice = _("Broadcast Message from %s@%s");
++		mesg_size = strlen(whom) + strlen(hostname) +
++			strlen(mesg_notice);
++		if (!(mesg = malloc(mesg_size))) {
++			(void)fprintf(stderr, _("%s: Out of memory!\n"),
++				progname);
++			exit(1);
++		}
++
+ 		(void)fprintf(fp, "\r%79s\r\n", " ");
+-		(void)sprintf(lbuf, _("Broadcast Message from %s@%s"),
+-			      whom, hostname);
+-		(void)fprintf(fp, "%-79.79s\007\007\r\n", lbuf);
+-		(void)sprintf(lbuf, "        (%s) at %d:%02d ...",
+-			      where, lt->tm_hour, lt->tm_min);
+-		(void)fprintf(fp, "%-79.79s\r\n", lbuf);
++		(void)sprintf(mesg, mesg_notice, whom, hostname);
++		(void)fprintf(fp, "%-79.79s\007\007\r\n", mesg);
++
++		mesg_notice = "        (%s) at %d:%02d ...";
++		size = strlen(mesg_notice) + strlen(where);
++		if (mesg_size < size) {
++			if (!realloc(mesg, size)) {
++				(void)fprintf(stderr, _("%s: Out of memory!\n"),
++					progname);
++				exit(1);
++			}
++		}
++
++		(void)sprintf(mesg, mesg_notice, where,
++			lt->tm_hour, lt->tm_min);
++		(void)fprintf(fp, "%-79.79s\r\n", mesg);
++
++		free(mesg);
+ 	}
+ 	(void)fprintf(fp, "%79s\r\n", " ");
+ 
+diff -urNad util-linux/misc-utils/Makefile /tmp/dpep.YGr3Vu/util-linux/misc-utils/Makefile
+--- util-linux/misc-utils/Makefile	2004-12-05 12:09:12.000000000 -0700
++++ /tmp/dpep.YGr3Vu/util-linux/misc-utils/Makefile	2004-12-15 08:20:23.533628037 -0700
+@@ -96,8 +96,8 @@
+ mcookie.o: mcookie.c $(LIB)/md5.h
+ reset: reset.sh
+ script: script.o
+-write.o: $(LIB)/carefulputc.h
+-write: write.o $(LIB)/carefulputc.o
++write.o: $(LIB)/carefulputc.h $(LIB)/xgethostname.h
++write: write.o $(LIB)/carefulputc.o $(LIB)/xgethostname.o
+ 
+ ifeq "$(HAVE_NCURSES)" "yes"
+ setterm: setterm.o
+diff -urNad util-linux/misc-utils/write.c /tmp/dpep.YGr3Vu/util-linux/misc-utils/write.c
+--- util-linux/misc-utils/write.c	2001-03-15 03:09:58.000000000 -0700
++++ /tmp/dpep.YGr3Vu/util-linux/misc-utils/write.c	2004-12-15 08:20:23.533628037 -0700
+@@ -64,9 +64,10 @@
+ #include <paths.h>
+ #include "pathnames.h"
+ #include "carefulputc.h"
++#include "xgethostname.h"
+ #include "nls.h"
+  
+-void search_utmp(char *, char *, char *, uid_t);
++void search_utmp(char *, char **, char *, uid_t);
+ void do_write(char *, char *, uid_t);
+ void wr_fputs(char *);
+ static void done(int);
+@@ -78,7 +79,7 @@
+ 	time_t atime;
+ 	uid_t myuid;
+ 	int msgsok, myttyfd;
+-	char tty[MAXPATHLEN], *mytty;
++	char *tty, *mytty;
+ 
+ 	setlocale(LC_ALL, "");
+ 	bindtextdomain(PACKAGE, LOCALEDIR);
+@@ -120,7 +121,7 @@
+ 	/* check args */
+ 	switch (argc) {
+ 	case 2:
+-		search_utmp(argv[1], tty, mytty, myuid);
++		search_utmp(argv[1], &tty, mytty, myuid);
+ 		do_write(tty, mytty, myuid);
+ 		break;
+ 	case 3:
+@@ -189,8 +190,10 @@
+  *
+  * Special case for writing to yourself - ignore the terminal you're
+  * writing from, unless that's the only terminal with messages enabled.
++ *
++ * Returns tty as an allocated string.
+  */
+-void search_utmp(char *user, char *tty, char *mytty, uid_t myuid)
++void search_utmp(char *user, char **tty, char *mytty, uid_t myuid)
+ 
+ {
+ 	struct utmp u;
+@@ -224,7 +227,11 @@
+ 			++nttys;
+ 			if (atime > bestatime) {
+ 				bestatime = atime;
+-				(void)strcpy(tty, atty);
++				if ((*tty = strdup(atty)) == NULL) {
++					(void)fprintf(stderr,
++						_("write: out of memory\n"));
++					exit(1);
++				}
+ 			}
+ 		}
+ 	}
+@@ -236,7 +243,12 @@
+ 	}
+ 	if (nttys == 0) {
+ 		if (user_is_me) {		/* ok, so write to yourself! */
+-			(void)strcpy(tty, mytty);
++			if ((*tty = strdup(mytty)) == NULL) {
++				(void)fprintf(stderr,
++					_("write: out of memory\n"));
++				exit(1);
++			}
++
+ 			return;
+ 		}
+ 		(void)fprintf(stderr,
+@@ -245,7 +257,7 @@
+ 	} else if (nttys > 1) {
+ 		(void)fprintf(stderr,
+ 		    _("write: %s is logged in more than once; writing to %s\n"),
+-		    user, tty);
++		    user, *tty);
+ 	}
+ }
+ 
+@@ -257,19 +269,23 @@
+ 
+ {
+ 	struct stat s;
+-	char path[MAXPATHLEN];
++	char *path;
+ 
+-	if (strlen(tty) + 6 > sizeof(path))
+-		return(1);
++	if ((path = malloc(strlen(tty) + sizeof("/dev/") + 1)) == NULL){
++		(void)fprintf(stderr,_("write: out of memory\n"));
++		exit(1);
++	}
+ 	(void)sprintf(path, "/dev/%s", tty);
+ 	if (stat(path, &s) < 0) {
+ 		if (showerror)
+ 			(void)fprintf(stderr,
+ 			    "write: %s: %s\n", path, strerror(errno));
++		free(path);
+ 		return(1);
+ 	}
+ 	*msgsokP = (s.st_mode & (S_IWRITE >> 3)) != 0;	/* group write bit */
+ 	*atimeP = s.st_atime;
++	free(path);
+ 	return(0);
+ }
+ 
+@@ -280,7 +296,7 @@
+ 	char *login, *pwuid, *nows;
+ 	struct passwd *pwd;
+ 	time_t now;
+-	char path[MAXPATHLEN], host[MAXHOSTNAMELEN], line[512];
++	char *path, *host, *host_tmp, line[512];
+ 
+ 	/* Determine our login name(s) before the we reopen() stdout */
+ 	if ((pwd = getpwuid(myuid)) != NULL)
+@@ -290,8 +306,10 @@
+ 	if ((login = getlogin()) == NULL)
+ 		login = pwuid;
+ 
+-	if (strlen(tty) + 6 > sizeof(path))
++	if ((path = malloc(strlen(tty) + sizeof("/dev/") + 1)) == NULL) {
++		(void)fprintf(stderr, _("write: out of memory\n"));
+ 		exit(1);
++	}
+ 	(void)sprintf(path, "/dev/%s", tty);
+ 	if ((freopen(path, "w", stdout)) == NULL) {
+ 		(void)fprintf(stderr, "write: %s: %s\n",
+@@ -299,12 +317,16 @@
+ 		exit(1);
+ 	}
+ 
++	free(path);
++
+ 	(void)signal(SIGINT, done);
+ 	(void)signal(SIGHUP, done);
+ 
+ 	/* print greeting */
+-	if (gethostname(host, sizeof(host)) < 0)
+-		(void)strcpy(host, "???");
++	if ((host_tmp = xgethostname()) != NULL)
++		host = host_tmp;
++	else
++		host = "???";
+ 	now = time((time_t *)NULL);
+ 	nows = ctime(&now);
+ 	nows[16] = '\0';
+@@ -317,6 +339,8 @@
+ 			     login, host, mytty, nows + 11);
+ 	printf("\r\n");
+ 
++	free(host_tmp);
++
+ 	while (fgets(line, sizeof(line), stdin) != NULL)
+ 		wr_fputs(line);
+ }
--- util-linux-2.12r.orig/debian/patches/30nfs4-fix.dpatch
+++ util-linux-2.12r/debian/patches/30nfs4-fix.dpatch
@@ -0,0 +1,71 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 30nfs4-fix.dpatch by Steinar H. Gunderson <sesse@debian.org>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: No description.
+
+@DPATCH@
+diff -urNad 2.12r-11~/mount/nfs4mount.c 2.12r-11/mount/nfs4mount.c
+--- 2.12r-11~/mount/nfs4mount.c	2006-09-19 09:29:41.000000000 -0600
++++ 2.12r-11/mount/nfs4mount.c	2006-09-19 09:32:58.000000000 -0600
+@@ -367,7 +367,10 @@
+ 		/*
+ 		 * ditto with rpc.gssd daemon
+ 		 */
+-		gssd_check();
++		/*
++		 * The latest nfs-common doesn't create pid files at all.
++		 */
++		/* gssd_check(); */
+ 	}
+ 	data.auth_flavourlen = num_flavour;
+ 	data.auth_flavours = pseudoflavour;
+diff -urNad 2.12r-11~/mount/nfsmount.c 2.12r-11/mount/nfsmount.c
+--- 2.12r-11~/mount/nfsmount.c	2006-09-19 09:29:41.000000000 -0600
++++ 2.12r-11/mount/nfsmount.c	2006-09-19 09:29:42.000000000 -0600
+@@ -301,6 +301,7 @@
+ 			 (xdrproc_t)xdr_void, (caddr_t)NULL,
+ 			 (xdrproc_t)xdr_void, (caddr_t)&clnt_res,
+ 			 TIMEOUT);
++	rpc_createerr.cf_stat = stat;
+ 	clnt_destroy(clnt);
+ 	close(sock);
+ 	if (stat != RPC_PROGVERSMISMATCH)
+@@ -332,17 +333,17 @@
+ 	p_prot = prot ? &prot : protos;
+ 	p_vers = vers ? &vers : versions;
+ 	rpc_createerr.cf_stat = 0;
++	p_port = port;
+ 	for (;;) {
+-		saddr->sin_port = htons(PMAPPORT);
+-		p_port = pmap_getport(saddr, prog, *p_vers, *p_prot);
+-		if (p_port) {
+-			if (!port || port == p_port) {
+-				saddr->sin_port = htons(port);
+-				if (clnt_ping(saddr, prog, *p_vers, *p_prot))
+-					goto out_ok;
+-			}
+-		} else if (rpc_createerr.cf_stat != RPC_PROGNOTREGISTERED)
+-			break;
++		if (!port) {
++			saddr->sin_port = htons(PMAPPORT);
++			p_port = pmap_getport(saddr, prog, *p_vers, *p_prot);
++			if (p_port == 0 && rpc_createerr.cf_stat != RPC_PROGNOTREGISTERED)
++				break;
++		}
++		saddr->sin_port = htons(p_port);
++		if (clnt_ping(saddr, prog, *p_vers, *p_prot))
++			goto out_ok;
+ 		if (!prot) {
+ 			if (*++p_prot)
+ 				continue;
+@@ -416,7 +417,8 @@
+ 				return 1;
+ 			memcpy(mnt_pmap, &save_mnt, sizeof(*mnt_pmap));
+ 		}
+-		if (rpc_createerr.cf_stat != RPC_PROGNOTREGISTERED)
++		if (rpc_createerr.cf_stat != RPC_PROGNOTREGISTERED &&
++		    rpc_createerr.cf_stat != RPC_PROGVERSMISMATCH)
+ 			break;
+ 		memcpy(nfs_pmap, &save_nfs, sizeof(*nfs_pmap));
+ 	}
--- util-linux-2.12r.orig/debian/patches/30nfs4.dpatch
+++ util-linux-2.12r/debian/patches/30nfs4.dpatch
@@ -0,0 +1,2602 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 30nfs4.dpatch by LaMont Jones <lamont@debian.org>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: No description.
+
+@DPATCH@
+diff -urNad --exclude=CVS --exclude=.svn ./mount/Makefile /tmp/dpep-work.TJbhsa/2.12r-5.1/mount/Makefile
+--- ./mount/Makefile	2006-01-18 12:52:52.000000000 -0700
++++ /tmp/dpep-work.TJbhsa/2.12r-5.1/mount/Makefile	2006-01-18 12:53:26.000000000 -0700
+@@ -30,7 +30,7 @@
+ MAYBE = pivot_root swapoff
+ 
+ LO_OBJS = lomount.o $(LIB)/xstrncpy.o rmd160.o
+-NFS_OBJS = nfsmount.o nfsmount_xdr.o nfsmount_clnt.o
++NFS_OBJS = nfsmount.o nfsmount_xdr.o nfsmount_clnt.o nfs4mount.o
+ GEN_FILES = nfsmount.h nfsmount_xdr.c nfsmount_clnt.c
+ 
+ all: $(PROGS)
+@@ -54,7 +54,7 @@
+ 
+ umount: umount.o fstab.o sundries.o xmalloc.o realpath.o mntent.o \
+ 	getusername.o get_label_uuid.o mount_by_label.o mount_blkid.o \
+-	version.o $(LIB)/env.o $(LO_OBJS)
++	version.o  nfsmount.o nfsmount_xdr.o $(LIB)/env.o $(LO_OBJS)
+ 	$(LINK) $^ -o $@ $(BLKID_LIB)
+ 
+ swapon:	swapon.o version.o xmalloc.o \
+diff -urNad --exclude=CVS --exclude=.svn ./mount/mount.8 /tmp/dpep-work.TJbhsa/2.12r-5.1/mount/mount.8
+--- ./mount/mount.8	2006-01-18 12:52:52.000000000 -0700
++++ /tmp/dpep-work.TJbhsa/2.12r-5.1/mount/mount.8	2006-01-18 12:52:52.000000000 -0700
+@@ -389,6 +389,7 @@
+ .IR msdos ,
+ .IR ncpfs ,
+ .IR nfs ,
++.IR nfs4 ,
+ .IR ntfs ,
+ .IR proc ,
+ .IR qnx4 ,
+@@ -426,7 +427,7 @@
+ program has to do is issue a simple
+ .IR mount (2)
+ system call, and no detailed knowledge of the filesystem type is required.
+-For a few types however (like nfs, smbfs, ncpfs) ad hoc code is
++For a few types however (like nfs, nfs4, smbfs, ncpfs) ad hoc code is
+ necessary. The nfs ad hoc code is built in, but smbfs and ncpfs
+ have a separate mount program. In order to make it possible to
+ treat all types in a uniform way, mount will execute the program
+@@ -454,9 +455,10 @@
+ All of the filesystem types listed there will be tried,
+ except for those that are labeled "nodev" (e.g.,
+ .IR devpts ,
+-.I proc
++.IR proc ,
++.IR nfs ,
+ and
+-.IR nfs ).
++.IR nfs4 ).
+ If
+ .I /etc/filesystems
+ ends in a line with a single * only, mount will read
+@@ -1379,6 +1381,73 @@
+ .B nolock
+ Do not use locking. Do not start lockd.
+ 
++.SH "Mount options for nfs4"
++Instead of a textual option string, parsed by the kernel, the
++.I nfs4
++file system expects a binary argument of type
++.IR "struct nfs4_mount_data" .
++The program
++.B mount
++itself parses the following options of the form `tag=value',
++and puts them in the structure mentioned:
++.BI rsize= n,
++.BI wsize= n,
++.BI timeo= n,
++.BI retrans= n,
++.BI acregmin= n,
++.BI acregmax= n,
++.BI acdirmin= n,
++.BI acdirmax= n,
++.BI actimeo= n,
++.BI retry= n,
++.BI port= n,
++.BI proto= n,
++.BI clientaddr= n,
++.BI sec= n.
++The option
++.BI addr= n
++is accepted but ignored.
++Also the following Boolean options, possibly preceded by
++.B no
++are recognized:
++.BR bg ,
++.BR fg ,
++.BR soft ,
++.BR hard ,
++.BR intr ,
++.BR cto ,
++.BR ac ,
++For details, see
++.BR nfs (5).
++
++Especially useful options include
++.TP
++.B rsize=32768,wsize=32768
++This will make your NFS connection faster than with the default
++buffer size of 4096.
++.TP
++.B hard
++The program accessing a file on a NFS mounted file system will hang
++when the server crashes. The process cannot be interrupted or
++killed unless you also specify
++.BR intr .
++When the NFS server is back online the program will continue undisturbed
++from where it was. This is probably what you want.
++.TP
++.B soft
++This option allows the kernel to time out if the NFS server is not
++responding for some time. The time can be
++specified with
++.BR timeo=time .
++This timeout value is expressed in tenths of a second.
++The
++.BR soft
++option might be useful if your NFS server sometimes doesn't respond
++or will be rebooted while some process tries to get a file from the server.
++Avoid using this option with
++.BR proto=udp
++or with a short timeout.
++
+ .SH "Mount options for ntfs"
+ .TP
+ .BI iocharset= name
+diff -urNad --exclude=CVS --exclude=.svn ./mount/mount.c /tmp/dpep-work.TJbhsa/2.12r-5.1/mount/mount.c
+--- ./mount/mount.c	2006-01-18 12:52:52.000000000 -0700
++++ /tmp/dpep-work.TJbhsa/2.12r-5.1/mount/mount.c	2006-01-18 12:52:52.000000000 -0700
+@@ -873,8 +873,23 @@
+ 		      "without support for the type `nfs'"));
+ #endif
+   }
++#ifdef HAVE_NFS
++  /*
++   * NFSv4 support
++   */
++  if (!fake && types && streq (types, "nfs4")) {
++    mnt_err = nfs4mount(spec, node, &flags, &extra_opts, &mount_opts, bg);
++    if (mnt_err)
++      return mnt_err;
++	goto nosigblock;
++#else
++    die (EX_SOFTWARE, _("mount: this version was compiled "
++	              "without support for the type `nfs4'"));
++#endif
++  }
+ 
+   block_signals (SIG_BLOCK);
++nosigblock:
+ 
+   if (!fake) {
+     mnt5_res = guess_fstype_and_mount (spec, node, &types, flags & ~MS_NOSYS,
+diff -urNad --exclude=CVS --exclude=.svn ./mount/nfs4mount.c /tmp/dpep-work.TJbhsa/2.12r-5.1/mount/nfs4mount.c
+--- ./mount/nfs4mount.c	1969-12-31 17:00:00.000000000 -0700
++++ /tmp/dpep-work.TJbhsa/2.12r-5.1/mount/nfs4mount.c	2006-01-18 12:52:52.000000000 -0700
+@@ -0,0 +1,433 @@
++/*
++ * nfs4mount.c -- Linux NFS mount
++ * Copyright (C) 2002 Trond Myklebust <trond.myklebust@fys.uio.no>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2, or (at your option)
++ * any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * Note: this file based on the original nfsmount.c
++ */
++
++#include "../defines.h"	/* for HAVE_rpcsvc_nfs_prot_h and HAVE_inet_aton */
++
++#include <linux/posix_types.h>
++#include <asm/posix_types.h>
++#undef __FD_CLR
++#undef __FD_SET
++#undef __FD_ISSET
++#undef __FD_ZERO
++
++#include <unistd.h>
++#include <stdio.h>
++#include <string.h>
++#include <errno.h>
++#include <netdb.h>
++#include <time.h>
++#include <sys/socket.h>
++#include <sys/time.h>
++#include <sys/utsname.h>
++#include <sys/stat.h>
++#include <netinet/in.h>
++#include <arpa/inet.h>
++#include <rpc/auth.h>
++#ifdef HAVE_rpcsvc_nfs_prot_h
++#include <rpcsvc/nfs_prot.h>
++#else
++#include <linux/nfs.h>
++#define nfsstat nfs_stat
++#endif
++
++#include "sundries.h"
++
++#include "mount_constants.h"
++#include "nfs4_mount.h"
++
++#include "nls.h"
++
++#if defined(VAR_LOCK_DIR)
++#define DEFAULT_DIR VAR_LOCK_DIR
++#else
++#define DEFAULT_DIR "/var/run"
++#endif
++
++char *IDMAPLCK = DEFAULT_DIR "/rpc.idmapd.pid";
++#define idmapd_check() do { \
++	if (access(IDMAPLCK, F_OK)) { \
++		printf(_("Warning: rpc.idmapd appears not to be running.\n" \
++			"         All uids will be mapped to the nobody uid.\n")); \
++	} \
++} while(0);
++
++char *GSSDLCK = DEFAULT_DIR "/rpc.gssd.pid";
++#define gssd_check() do { \
++		if (access(GSSDLCK, F_OK)) { \
++			printf(_("Warning: rpc.gssd appears not to be running.\n")); \
++		} \
++} while(0); 
++
++#ifndef NFS_PORT
++#define NFS_PORT 2049
++#endif
++
++extern int clnt_ping(struct sockaddr_in *, const u_long, const u_long, const u_int);
++extern void rpc_strerror(void);
++
++struct {
++	char    *flavour;
++	int     fnum;
++} flav_map[] = {
++	{ "krb5",	RPC_AUTH_GSS_KRB5	},
++	{ "krb5i",	RPC_AUTH_GSS_KRB5I	},
++	{ "krb5p",	RPC_AUTH_GSS_KRB5P	},
++	{ "lipkey",	RPC_AUTH_GSS_LKEY	},
++	{ "lipkey-i",	RPC_AUTH_GSS_LKEYI	},
++	{ "lipkey-p",	RPC_AUTH_GSS_LKEYP	},
++	{ "spkm3",	RPC_AUTH_GSS_SPKM	},
++	{ "spkm3i",	RPC_AUTH_GSS_SPKMI	},
++	{ "spkm3p",	RPC_AUTH_GSS_SPKMP	},
++	{ "unix",	AUTH_UNIX		},
++	{ "sys",	AUTH_SYS		},
++	{ "null",	AUTH_NULL		},
++	{ "none",	AUTH_NONE		},
++};
++
++#define FMAPSIZE		(sizeof(flav_map)/sizeof(flav_map[0]))
++#define MAX_USER_FLAVOUR	16
++
++static int parse_sec(char *sec, int *pseudoflavour)
++{
++	int i, num_flavour = 0;
++
++	for (sec = strtok(sec, ":"); sec; sec = strtok(NULL, ":")) {
++		if (num_flavour >= MAX_USER_FLAVOUR) {
++			fprintf(stderr,
++				_("mount: maximum number of security flavors "
++				  "exceeded\n"));
++			return 0;
++		}
++		for (i = 0; i < FMAPSIZE; i++) {
++			if (strcmp(sec, flav_map[i].flavour) == 0) {
++				pseudoflavour[num_flavour++] = flav_map[i].fnum;
++				break;
++			}
++		}
++		if (i == FMAPSIZE) {
++			fprintf(stderr,
++				_("mount: unknown security type %s\n"), sec);
++			return 0;
++		}
++	}
++	if (!num_flavour)
++		fprintf(stderr,
++			_("mount: no security flavors passed to sec= option\n"));
++	return num_flavour;
++}
++
++static int parse_devname(char *hostdir, char **hostname, char **dirname)
++{
++	char *s;
++
++	if (!(s = strchr(hostdir, ':'))) {
++		fprintf(stderr,
++			_("mount: "
++			  "directory to mount not in host:dir format\n"));
++		return -1;
++	}
++	*hostname = hostdir;
++	*dirname = s + 1;
++	*s = '\0';
++	/* Ignore all but first hostname in replicated mounts
++	   until they can be fully supported. (mack@sgi.com) */
++	if ((s = strchr(hostdir, ','))) {
++		*s = '\0';
++		fprintf(stderr,
++			_("mount: warning: "
++			  "multiple hostnames not supported\n"));
++	}
++	return 0;
++}
++
++static int fill_ipv4_sockaddr(const char *hostname, struct sockaddr_in *addr)
++{
++	struct hostent *hp;
++	addr->sin_family = AF_INET;
++
++	if (inet_aton(hostname, &addr->sin_addr))
++		return 0;
++	if ((hp = gethostbyname(hostname)) == NULL) {
++		fprintf(stderr, _("mount: can't get address for %s\n"),
++			hostname);
++		return -1;
++	}
++	if (hp->h_length > sizeof(struct in_addr)) {
++		fprintf(stderr,
++			_("mount: got bad hp->h_length\n"));
++		hp->h_length = sizeof(struct in_addr);
++	}
++	memcpy(&addr->sin_addr, hp->h_addr, hp->h_length);
++	return 0;
++}
++
++static int get_my_ipv4addr(char *ip_addr, int len)
++{
++	char myname[1024];
++	struct sockaddr_in myaddr;
++
++	if (gethostname(myname, sizeof(myname))) {
++		fprintf(stderr, _("mount: can't determine client address\n"));
++		return -1;
++	}
++	if (fill_ipv4_sockaddr(myname, &myaddr))
++		return -1;
++	snprintf(ip_addr, len, "%s", inet_ntoa(myaddr.sin_addr));
++	ip_addr[len-1] = '\0';
++	return 0;
++}
++
++int nfs4mount(const char *spec, const char *node, int *flags,
++	      char **extra_opts, char **mount_opts,
++	      int running_bg)
++{
++	static struct nfs4_mount_data data;
++	static char hostdir[1024];
++	static char ip_addr[16] = "127.0.0.1";
++	static struct sockaddr_in server_addr;
++	static int pseudoflavour[MAX_USER_FLAVOUR];
++	int num_flavour = 0;
++
++	char *hostname, *dirname, *old_opts;
++	char new_opts[1024];
++	char *opt, *opteq;
++	char *s;
++	int val;
++	int bg, soft, intr;
++	int nocto, noac;
++	int retry;
++	int retval;
++
++	retval = EX_FAIL;
++	if (strlen(spec) >= sizeof(hostdir)) {
++		fprintf(stderr, _("mount: "
++				  "excessively long host:dir argument\n"));
++		goto fail;
++	}
++	strcpy(hostdir, spec);
++	if (parse_devname(hostdir, &hostname, &dirname))
++		goto fail;
++
++	if (fill_ipv4_sockaddr(hostname, &server_addr))
++		goto fail;
++	if (get_my_ipv4addr(ip_addr, sizeof(ip_addr)))
++		goto fail;
++
++	/* add IP address to mtab options for use when unmounting */
++	s = inet_ntoa(server_addr.sin_addr);
++	old_opts = *extra_opts;
++	if (!old_opts)
++		old_opts = "";
++	if (strlen(old_opts) + strlen(s) + 10 >= sizeof(new_opts)) {
++		fprintf(stderr, _("mount: "
++				  "excessively long option argument\n"));
++		goto fail;
++	}
++	snprintf(new_opts, sizeof(new_opts), "%s%saddr=%s",
++		 old_opts, *old_opts ? "," : "", s);
++	*extra_opts = xstrdup(new_opts);
++
++	/* Set default options.
++	 * rsize/wsize and timeo are left 0 in order to
++	 * let the kernel decide.
++	 */
++	memset(&data, 0, sizeof(data));
++	data.retrans	= 3;
++	data.acregmin	= 3;
++	data.acregmax	= 60;
++	data.acdirmin	= 30;
++	data.acdirmax	= 60;
++	data.proto	= IPPROTO_TCP;
++
++	bg = 0;
++	soft = 0;
++	intr = NFS4_MOUNT_INTR;
++	nocto = 0;
++	noac = 0;
++	retry = 10000;		/* 10000 minutes ~ 1 week */
++
++	/*
++	 * NFSv4 specifies that the default port should be 2049
++	 */
++	server_addr.sin_port = htons(NFS_PORT);
++
++	/* parse options */
++
++	for (opt = strtok(old_opts, ","); opt; opt = strtok(NULL, ",")) {
++		if ((opteq = strchr(opt, '='))) {
++			val = atoi(opteq + 1);	
++			*opteq = '\0';
++			if (!strcmp(opt, "rsize"))
++				data.rsize = val;
++			else if (!strcmp(opt, "wsize"))
++				data.wsize = val;
++			else if (!strcmp(opt, "timeo"))
++				data.timeo = val;
++			else if (!strcmp(opt, "retrans"))
++				data.retrans = val;
++			else if (!strcmp(opt, "acregmin"))
++				data.acregmin = val;
++			else if (!strcmp(opt, "acregmax"))
++				data.acregmax = val;
++			else if (!strcmp(opt, "acdirmin"))
++				data.acdirmin = val;
++			else if (!strcmp(opt, "acdirmax"))
++				data.acdirmax = val;
++			else if (!strcmp(opt, "actimeo")) {
++				data.acregmin = val;
++				data.acregmax = val;
++				data.acdirmin = val;
++				data.acdirmax = val;
++			}
++			else if (!strcmp(opt, "retry"))
++				retry = val;
++			else if (!strcmp(opt, "port"))
++				server_addr.sin_port = htons(val);
++			else if (!strcmp(opt, "proto")) {
++				if (!strncmp(opteq+1, "tcp", 3))
++					data.proto = IPPROTO_TCP;
++				else if (!strncmp(opteq+1, "udp", 3))
++					data.proto = IPPROTO_UDP;
++				else
++					printf(_("Warning: Unrecognized proto= option.\n"));
++			} else if (!strcmp(opt, "clientaddr")) {
++				if (strlen(opteq+1) >= sizeof(ip_addr))
++					printf(_("Invalid client address %s"),
++								opteq+1);
++				strncpy(ip_addr,opteq+1, sizeof(ip_addr));
++				ip_addr[sizeof(ip_addr)-1] = '\0';
++			} else if (!strcmp(opt, "sec")) {
++				num_flavour = parse_sec(opteq+1, pseudoflavour);
++				if (!num_flavour)
++					goto fail;
++			} else if (!strcmp(opt, "addr")) {
++				/* ignore */;
++			} else {
++				printf(_("unknown nfs mount parameter: "
++					 "%s=%d\n"), opt, val);
++				goto fail;
++			}
++		} else {
++			val = 1;
++			if (!strncmp(opt, "no", 2)) {
++				val = 0;
++				opt += 2;
++			}
++			if (!strcmp(opt, "bg")) 
++				bg = val;
++			else if (!strcmp(opt, "fg")) 
++				bg = !val;
++			else if (!strcmp(opt, "soft"))
++				soft = val;
++			else if (!strcmp(opt, "hard"))
++				soft = !val;
++			else if (!strcmp(opt, "intr"))
++				intr = val;
++			else if (!strcmp(opt, "cto"))
++				nocto = !val;
++			else if (!strcmp(opt, "ac"))
++				noac = !val;
++			else {
++				if (!sloppy) {
++					printf(_("unknown nfs mount option: "
++						 "%s%s\n"), val ? "" : "no", opt);
++					goto fail;
++				}
++			}
++		}
++	}
++
++	data.flags = (soft ? NFS4_MOUNT_SOFT : 0)
++		| (intr ? NFS4_MOUNT_INTR : 0)
++		| (nocto ? NFS4_MOUNT_NOCTO : 0)
++		| (noac ? NFS4_MOUNT_NOAC : 0);
++
++	/*
++	 * Give a warning if the rpc.idmapd daemon is not running
++	 */
++	idmapd_check();
++
++	if (num_flavour == 0)
++		pseudoflavour[num_flavour++] = AUTH_UNIX;
++	else {
++		/*
++		 * ditto with rpc.gssd daemon
++		 */
++		gssd_check();
++	}
++	data.auth_flavourlen = num_flavour;
++	data.auth_flavours = pseudoflavour;
++
++	data.client_addr.data = ip_addr;
++	data.client_addr.len = strlen(ip_addr);
++
++	data.mnt_path.data = dirname;
++	data.mnt_path.len = strlen(dirname);
++
++	data.hostname.data = hostname;
++	data.hostname.len = strlen(hostname);
++	data.host_addr = (struct sockaddr *)&server_addr;
++	data.host_addrlen = sizeof(server_addr);
++
++#ifdef NFS_MOUNT_DEBUG
++	printf("rsize = %d, wsize = %d, timeo = %d, retrans = %d\n",
++	       data.rsize, data.wsize, data.timeo, data.retrans);
++	printf("acreg (min, max) = (%d, %d), acdir (min, max) = (%d, %d)\n",
++	       data.acregmin, data.acregmax, data.acdirmin, data.acdirmax);
++	printf("port = %d, bg = %d, retry = %d, flags = %.8x\n",
++	       ntohs(server_addr.sin_port), bg, retry, data.flags);
++	printf("soft = %d, intr = %d, nocto = %d, noac = %d\n",
++	       (data.flags & NFS4_MOUNT_SOFT) != 0,
++	       (data.flags & NFS4_MOUNT_INTR) != 0,
++	       (data.flags & NFS4_MOUNT_NOCTO) != 0,
++	       (data.flags & NFS4_MOUNT_NOAC) != 0);
++
++	if (num_flavour > 0) {
++		int pf_cnt, i;
++
++		printf("sec = ");
++		for (pf_cnt = 0; pf_cnt < num_flavour; pf_cnt++) {
++			for (i = 0; i < FMAPSIZE; i++) {
++				if (flav_map[i].fnum == pseudoflavour[pf_cnt]) {
++					printf("%s", flav_map[i].flavour);
++					break;
++				}
++			}
++			printf("%s", (pf_cnt < num_flavour-1) ? ":" : "\n");
++		}
++	}
++	printf("proto = %s\n", (data.proto == IPPROTO_TCP) ? "tcp" : "udp");
++#endif
++
++	data.version = NFS4_MOUNT_VERSION;
++
++	clnt_ping(&server_addr, NFS_PROGRAM, 4, data.proto);
++	if (rpc_createerr.cf_stat) {
++		fprintf(stderr, "mount to NFS server '%s' failed.\n", data.hostname.data);
++		goto fail;
++	}
++
++	*mount_opts = (char *) &data;
++	/* clean up */
++	return 0;
++
++fail:
++	if (verbose) {
++		rpc_strerror();
++	}
++	return retval;
++}
+diff -urNad --exclude=CVS --exclude=.svn ./mount/nfs4_mount.h /tmp/dpep-work.TJbhsa/2.12r-5.1/mount/nfs4_mount.h
+--- ./mount/nfs4_mount.h	1969-12-31 17:00:00.000000000 -0700
++++ /tmp/dpep-work.TJbhsa/2.12r-5.1/mount/nfs4_mount.h	2006-01-18 12:52:52.000000000 -0700
+@@ -0,0 +1,82 @@
++#ifndef _LINUX_NFS4_MOUNT_H
++#define _LINUX_NFS4_MOUNT_H
++
++/*
++ *  linux/include/linux/nfs4_mount.h
++ *
++ *  Copyright (C) 2002  Trond Myklebust
++ *
++ *  structure passed from user-space to kernel-space during an nfsv4 mount
++ */
++
++/*
++ * WARNING!  Do not delete or change the order of these fields.  If
++ * a new field is required then add it to the end.  The version field
++ * tracks which fields are present.  This will ensure some measure of
++ * mount-to-kernel version compatibility.  Some of these aren't used yet
++ * but here they are anyway.
++ */
++#define NFS4_MOUNT_VERSION	1
++
++struct nfs_string {
++	unsigned int len;
++	const char* data;
++};
++
++struct nfs4_mount_data {
++	int version;				/* 1 */
++	int flags;				/* 1 */
++	int rsize;				/* 1 */
++	int wsize;				/* 1 */
++	int timeo;				/* 1 */
++	int retrans;				/* 1 */
++	int acregmin;				/* 1 */
++	int acregmax;				/* 1 */
++	int acdirmin;				/* 1 */
++	int acdirmax;				/* 1 */
++
++	/* see the definition of 'struct clientaddr4' in RFC3010 */
++	struct nfs_string client_addr;		/* 1 */
++
++	/* Mount path */
++	struct nfs_string mnt_path;		/* 1 */
++
++	/* Server details */
++	struct nfs_string hostname;		/* 1 */
++	/* Server IP address */
++	unsigned int host_addrlen;		/* 1 */
++	struct sockaddr* host_addr;		/* 1 */
++
++	/* Transport protocol to use */
++	int proto;				/* 1 */
++
++	/* Pseudo-flavours to use for authentication. See RFC2623 */
++	int auth_flavourlen;			/* 1 */
++	int *auth_flavours;			/* 1 */
++};
++
++/* bits in the flags field */
++/* Note: the fields that correspond to existing NFSv2/v3 mount options
++ * 	 should mirror the values from include/linux/nfs_mount.h
++ */
++
++#define NFS4_MOUNT_SOFT		0x0001	/* 1 */
++#define NFS4_MOUNT_INTR		0x0002	/* 1 */
++#define NFS4_MOUNT_NOCTO	0x0010	/* 1 */
++#define NFS4_MOUNT_NOAC		0x0020	/* 1 */
++#define NFS4_MOUNT_STRICTLOCK	0x1000	/* 1 */
++#define NFS4_MOUNT_FLAGMASK	0xFFFF
++
++/* pseudoflavors: */
++
++#define RPC_AUTH_GSS_KRB5       390003
++#define RPC_AUTH_GSS_KRB5I      390004
++#define RPC_AUTH_GSS_KRB5P      390005
++#define RPC_AUTH_GSS_LKEY       390006
++#define RPC_AUTH_GSS_LKEYI      390007
++#define RPC_AUTH_GSS_LKEYP      390008
++#define RPC_AUTH_GSS_SPKM       390009
++#define RPC_AUTH_GSS_SPKMI      390010
++#define RPC_AUTH_GSS_SPKMP      390011
++
++#endif
+diff -urNad --exclude=CVS --exclude=.svn ./mount/nfs.5 /tmp/dpep-work.TJbhsa/2.12r-5.1/mount/nfs.5
+--- ./mount/nfs.5	2006-01-18 12:50:07.000000000 -0700
++++ /tmp/dpep-work.TJbhsa/2.12r-5.1/mount/nfs.5	2006-01-18 12:52:52.000000000 -0700
+@@ -3,7 +3,7 @@
+ .\" patches. "
+ .TH NFS 5 "20 November 1993" "Linux 0.99" "Linux Programmer's Manual"
+ .SH NAME
+-nfs \- nfs fstab format and options
++nfs \- nfs and nfs4 fstab format and options
+ .SH SYNOPSIS
+ .B /etc/fstab
+ .SH DESCRIPTION
+@@ -17,14 +17,51 @@
+ and the NFS specific options that control
+ the way the filesystem is mounted.
+ .P
+-Here is an example from an \fI/etc/fstab\fP file from an NFS mount.
++Three different versions of the NFS protocol are
++supported by the Linux NFS client:
++NFS version 2, NFS version 3, and NFS version 4.
++To mount via NFS version 2, use the
++.BR nfs
++file system type and specify
++.BR nfsvers=2 .
++Version 2 is the default protocol version for the
++.BR nfs
++file system type when
++.BR nfsvers=
++is not specified on the mount command.
++To mount via NFS version 3, use the
++.BR nfs
++file system type and specify
++.BR nfsvers=3 .
++To mount via NFS version 4, use the
++.BR nfs4
++file system type.
++The
++.BR nfsvers=
++keyword is not supported for the
++.BR nfs4
++file system type.
++.P
++These file system types share similar mount options;
++the differences are listed below.
++.P
++Here is an example from an \fI/etc/fstab\fP file for an NFSv2 mount
++over UDP.
+ .sp
+ .nf
+ .ta 2.5i +0.75i +0.75i +1.0i
+ server:/usr/local/pub	/pub	nfs	rsize=8192,wsize=8192,timeo=14,intr
+ .fi
++.P
++Here is an example for an NFSv4 mount over TCP using Kerberos
++5 mutual authentication.
++.sp
++.nf
++.ta 2.5i +0.75i +0.75i +1.0i
++server:/usr/local/pub	/pub	nfs4	proto=tcp,sec=krb5,hard,intr
++.fi
+ .DT
+-.SS Options
++.SS Options for the nfs file system type
+ .TP 1.5i
+ .I rsize=n
+ The number of bytes NFS uses when reading files from an NFS server.
+@@ -128,7 +165,7 @@
+ Use an alternate RPC version number to contact the
+ mount daemon on the remote host.  This option is useful
+ for hosts that can run multiple NFS servers.
+-The default value is version 1.
++The default value depends on which kernel you are using.
+ .TP 1.5i
+ .I nfsprog=n
+ Use an alternate RPC program number to contact the
+@@ -141,7 +178,7 @@
+ Use an alternate RPC version number to contact the
+ NFS daemon on the remote host.  This option is useful
+ for hosts that can run multiple NFS servers.
+-The default value is version 2.
++The default value depends on which kernel you are using.
+ .TP 1.5i
+ .I nolock
+ Disable NFS locking. Do not start lockd.
+@@ -193,9 +230,25 @@
+ .TP 1.5i
+ .I noac
+ Disable all forms of attribute caching entirely.  This extracts a
+-server performance penalty but it allows two different NFS clients
+-to get reasonable good results when both clients are actively
+-writing to common filesystem on the server.
++significant performance penalty but it allows two different NFS clients
++to get reasonable results when both clients are actively
++writing to a common export on the server.
++.TP 1.5i
++.I sec=mode
++Set the security flavor for this mount to "mode".
++The default setting is \f3sec=sys\f1, which uses local
++unix uids and gids to authenticate NFS operations (AUTH_SYS).
++Other currently supported settings are:
++\f3sec=krb5\f1, which uses Kerberos V5 instead of local unix uids
++and gids to authenticate users;
++\f3sec=krb5i\f1, which uses Kerberos V5 for user authentication
++and performs integrity checking of NFS operations using secure
++checksums to prevent data tampering; and
++\f3sec=krb5p\f1, which uses Kerberos V5 for user authentication
++and integrity checking, and encrypts NFS traffic to prevent
++traffic sniffing (this is the most secure setting).
++Note that there is a performance penalty when using integrity
++or privacy.
+ .TP 1.5i
+ .I tcp
+ Mount the NFS filesystem using the TCP protocol instead of the
+@@ -208,6 +261,156 @@
+ All of the non-value options have corresponding nooption forms.
+ For example, nointr means don't allow file operations to be
+ interrupted.
++.SS Options for the nfs4 file system type
++.TP 1.5i
++.I rsize=n
++The number of bytes NFS uses when reading files from an NFS server.
++The default value is dependent on the kernel, currently 4096 bytes.
++(However, throughput is improved greatly by asking for
++.IR rsize=32768 .)
++This value is negotiated with the server.
++.TP 1.5i
++.I wsize=n
++The number of bytes NFS uses when writing files to an NFS server.
++The default value is dependent on the kernel, currently 4096 bytes.
++(However, throughput is improved greatly by asking for
++.IR wsize=32768 .)
++This value is negotiated with the server.
++.TP 1.5i
++.I timeo=n
++The value in tenths of a second before sending the
++first retransmission after an RPC timeout.
++The default value depends on whether
++.IR proto=udp
++or
++.IR proto=tcp
++is in effect (see below).
++The default value for UDP is 7 tenths of a second.
++The default value for TCP is 60 seconds.
++After the first timeout,
++the timeout is doubled after each successive timeout until a maximum
++timeout of 60 seconds is reached or the enough retransmissions
++have occured to cause a major timeout.  Then, if the filesystem
++is hard mounted, each new timeout cascade restarts at twice the
++initial value of the previous cascade, again doubling at each
++retransmission.  The maximum timeout is always 60 seconds.
++.TP 1.5i
++.I retrans=n
++The number of minor timeouts and retransmissions that must occur before
++a major timeout occurs.  The default is 5 timeouts for
++.IR proto=udp
++and 2 timeouts for
++.IR proto=tcp .
++When a major timeout
++occurs, the file operation is either aborted or a "server not responding"
++message is printed on the console.
++.TP 1.5i
++.I acregmin=n
++The minimum time in seconds that attributes of a regular file should
++be cached before requesting fresh information from a server.
++The default is 3 seconds.
++.TP 1.5i
++.I acregmax=n
++The maximum time in seconds that attributes of a regular file can
++be cached before requesting fresh information from a server.
++The default is 60 seconds.
++.TP 1.5i
++.I acdirmin=n
++The minimum time in seconds that attributes of a directory should
++be cached before requesting fresh information from a server.
++The default is 30 seconds.
++.TP 1.5i
++.I acdirmax=n
++The maximum time in seconds that attributes of a directory can
++be cached before requesting fresh information from a server.
++The default is 60 seconds.
++.TP 1.5i
++.I actimeo=n
++Using actimeo sets all of
++.I acregmin,
++.I acregmax,
++.I acdirmin,
++and
++.I acdirmax
++to the same value.
++There is no default value.
++.TP 1.5i
++.I retry=n
++The number of minutes to retry an NFS mount operation
++in the foreground or background before giving up.
++The default value is 10000 minutes, which is roughly one week.
++.TP 1.5i
++.I port=n
++The numeric value of the port to connect to the NFS server on.
++If the port number is 0 (the default) then query the
++remote host's portmapper for the port number to use.
++If the remote host's NFS daemon is not registered with
++its portmapper, the standard NFS port number 2049 is
++used instead.
++.TP 1.5i
++.I proto=n
++Mount the NFS filesystem using a specific network protocol
++instead of the default UDP protocol.
++Many NFS version 4 servers only support TCP.
++Valid protocol types are
++.IR udp
++and
++.IR tcp .
++.TP 1.5i
++.I clientaddr=n
++On a multi-homed client, this
++causes the client to use a specific callback address when
++communicating with an NFS version 4 server.
++This option is currently ignored.
++.TP 1.5i
++.I sec=mode
++Same as \f3sec=mode\f1 for the nfs filesystem type (see above).
++.TP 1.5i
++.I bg
++If an NFS mount attempt times out, retry the mount
++in the background.
++After a mount operation is backgrounded, all subsequent mounts
++on the same NFS server will be backgrounded immediately, without
++first attempting the mount.
++A missing mount point is treated as a timeout,
++to allow for nested NFS mounts.
++.TP 1.5i
++.I fg
++If the first NFS mount attempt times out, retry the mount
++in the foreground.
++This is the complement of the
++.I bg
++option, and also the default behavior.
++.TP 1.5i
++.I soft
++If an NFS file operation has a major timeout then report an I/O error to
++the calling program.
++The default is to continue retrying NFS file operations indefinitely.
++.TP 1.5i
++.I hard
++If an NFS file operation has a major timeout then report
++"server not responding" on the console and continue retrying indefinitely.
++This is the default.
++.TP 1.5i
++.I intr
++If an NFS file operation has a major timeout and it is hard mounted,
++then allow signals to interupt the file operation and cause it to
++return EINTR to the calling program.  The default is to not
++allow file operations to be interrupted.
++.TP 1.5i
++.I nocto
++Suppress the retrieval of new attributes when creating a file.
++.TP 1.5i
++.I noac
++Disable attribute caching, and force synchronous writes.
++This extracts a
++server performance penalty but it allows two different NFS clients
++to get reasonable good results when both clients are actively
++writing to common filesystem on the server.
++.P
++All of the non-value options have corresponding nooption forms.
++For example, nointr means don't allow file operations to be
++interrupted.
+ .SH FILES
+ .I /etc/fstab
+ .SH "SEE ALSO"
+diff -urNad --exclude=CVS --exclude=.svn ./mount/nfs_mount4.h /tmp/dpep-work.TJbhsa/2.12r-5.1/mount/nfs_mount4.h
+--- ./mount/nfs_mount4.h	2006-01-18 12:50:08.000000000 -0700
++++ /tmp/dpep-work.TJbhsa/2.12r-5.1/mount/nfs_mount4.h	2006-01-18 12:52:52.000000000 -0700
+@@ -8,7 +8,9 @@
+  * so it is easiest to ignore the kernel altogether (at compile time).
+  */
+ 
+-#define NFS_MOUNT_VERSION	4
++#define NFS_MOUNT_VERSION 6
++#define NFS_MAX_CONTEXT_LEN   256
++
+ 
+ struct nfs2_fh {
+         char                    data[32];
+@@ -36,6 +38,9 @@
+ 	int		namlen;			/* 2 */
+ 	unsigned int	bsize;			/* 3 */
+ 	struct nfs3_fh	root;			/* 4 */
++	int		pseudoflavor;		/* 5 */
++	char    context[NFS_MAX_CONTEXT_LEN + 1]; /* 6 */
++
+ };
+ 
+ /* bits in the flags field */
+@@ -51,4 +56,19 @@
+ #define NFS_MOUNT_KERBEROS	0x0100	/* 3 */
+ #define NFS_MOUNT_NONLM		0x0200	/* 3 */
+ #define NFS_MOUNT_BROKEN_SUID	0x0400	/* 4 */
++#define NFS_MOUNT_SECFLAVOUR	0x2000	/* 5 */
++
++/* security pseudoflavors */
++
++#ifndef AUTH_GSS_KRB5
++#define AUTH_GSS_KRB5		390003
++#define AUTH_GSS_KRB5I		390004
++#define AUTH_GSS_KRB5P		390005
++#define AUTH_GSS_LKEY		390006
++#define AUTH_GSS_LKEYI		390007
++#define AUTH_GSS_LKEYP		390008
++#define AUTH_GSS_SPKM		390009
++#define AUTH_GSS_SPKMI		390010
++#define AUTH_GSS_SPKMP		390011
++#endif
+ 
+diff -urNad --exclude=CVS --exclude=.svn ./mount/nfsmount.c /tmp/dpep-work.TJbhsa/2.12r-5.1/mount/nfsmount.c
+--- ./mount/nfsmount.c	2006-01-18 12:50:08.000000000 -0700
++++ /tmp/dpep-work.TJbhsa/2.12r-5.1/mount/nfsmount.c	2006-01-18 12:52:52.000000000 -0700
+@@ -34,6 +34,7 @@
+ 
+ #include "../defines.h"	/* for HAVE_rpcsvc_nfs_prot_h and HAVE_inet_aton */
+ 
++#include <ctype.h>
+ #include <unistd.h>
+ #include <stdio.h>
+ #include <string.h>
+@@ -72,11 +73,121 @@
+ #define NFS_FHSIZE 32
+ #endif
+ 
++#define MNT_SENDBUFSIZE ((u_int)2048)
++#define MNT_RECVBUFSIZE ((u_int)1024)
++
+ static char *nfs_strerror(int stat);
+ 
+ #define MAKE_VERSION(p,q,r)	(65536*(p) + 256*(q) + (r))
+ 
+ #define MAX_NFSPROT ((nfs_mount_version >= 4) ? 3 : 2)
++#define MAX_MNTPROT ((nfs_mount_version >= 4) ? 3 : 2)
++#define HAVE_RELIABLE_TCP (nfs_mount_version >= 4)
++
++#ifndef HAVE_inet_aton
++#define inet_aton(a,b) (0)
++#endif
++
++typedef dirpath mnt2arg_t;
++typedef dirpath mnt3arg_t;
++typedef dirpath mntarg_t;
++
++typedef struct fhstatus  mnt2res_t;
++typedef struct mountres3 mnt3res_t;
++typedef union {
++	mnt2res_t nfsv2;
++	mnt3res_t nfsv3;
++} mntres_t;
++
++typedef struct {
++	char **hostname;
++	struct sockaddr_in saddr;
++	struct pmap pmap;
++} clnt_addr_t;
++
++/* RPC call timeout values */
++static const struct timeval TIMEOUT = { 20, 0 };
++static const struct timeval RETRY_TIMEOUT = { 3, 0 };
++
++static int nfs_call_umount(clnt_addr_t *mnt_server, dirpath *argp);
++
++int clnt_ping(struct sockaddr_in *, const u_long, const u_long, const u_int);
++
++/* Convert RPC errors into strings */
++void rpc_strerror(void)
++{
++	int cf_stat = rpc_createerr.cf_stat; 
++	int cf_errno = rpc_createerr.cf_error.re_errno;
++	char *ptr, *estr = clnt_sperrno(cf_stat);
++
++	if (estr) {
++		if ((ptr = index(estr, ':')))
++			estr = ++ptr;
++
++		fprintf(stderr, "RPC Error: %d (%s )\n", cf_stat, estr);
++		if (cf_stat == RPC_SYSTEMERROR)
++			fprintf(stderr, "System Error: %d (%s)\n", cf_errno, strerror(cf_errno));
++	}
++}
++
++/* Define the order in which to probe for UDP/TCP services */
++static const u_int *
++proto_probelist(const int use_tcp)
++{
++	static const u_int probe_both[] = { IPPROTO_TCP, IPPROTO_UDP, 0 };
++	static const u_int probe_udponly[] = { IPPROTO_UDP, 0 };
++	if (use_tcp)
++		return probe_both;
++	return probe_udponly;
++}
++
++/* Define the order in which NFS versions are probed on portmapper */
++static const u_long *
++nfs_probelist(const int vers)
++{
++	static const u_long nfs2_probe[] = { 2, 0};
++	static const u_long nfs3_probe[] = { 3, 2, 0};
++	switch (vers) {
++	case 3:
++		return nfs3_probe;
++	default:
++		return nfs2_probe;
++	}
++}
++
++/* Define the order in which Mountd versions are probed on portmapper */
++static const u_long *
++mnt_probelist(const int vers)
++{
++	static const u_long mnt1_probe[] = { 1, 2, 0 };
++	static const u_long mnt3_probe[] = { 3, 1, 2, 0 };
++	switch (vers) {
++	case 3:
++		return mnt3_probe;
++	default:
++		return mnt1_probe;
++	}
++}
++
++/* Map an NFS version into the corresponding Mountd version */
++static u_long
++nfsvers_to_mnt(const u_long vers)
++{
++	static const u_long nfs_to_mnt[] = { 0, 0, 1, 3 };
++	if (vers <= 3)
++		return nfs_to_mnt[vers];
++	return 0;
++}
++
++/* Map a Mountd version into the corresponding NFS version */
++static u_long
++mntvers_to_nfs(const u_long vers)
++{
++	static const u_long mnt_to_nfs[] = { 0, 2, 2, 3 };
++	if (vers <= 3)
++		return mnt_to_nfs[vers];
++	return 0;
++}
+ 
+ static int
+ linux_version_code(void) {
+@@ -102,123 +213,632 @@
+  *	NFS_MOUNT_VERSION: these nfsmount sources at compile time
+  *	nfs_mount_version: version this source and running kernel can handle
+  */
++static int nfs_mount_version = NFS_MOUNT_VERSION;
++
+ static int
+ find_kernel_nfs_mount_version(void) {
+ 	static int kernel_version = -1;
+-	int nfs_mount_version = NFS_MOUNT_VERSION;
++	int mnt_version = NFS_MOUNT_VERSION;
+ 
+ 	if (kernel_version == -1)
+ 		kernel_version = linux_version_code();
+ 
+ 	if (kernel_version) {
+ 	     if (kernel_version < MAKE_VERSION(2,1,32))
+-		  nfs_mount_version = 1;
++		  mnt_version = 1;
+ 	     else if (kernel_version < MAKE_VERSION(2,2,18))
+-		  nfs_mount_version = 3;
++		  mnt_version = 3;
+ 	     else if (kernel_version < MAKE_VERSION(2,3,0))
+-		  nfs_mount_version = 4; /* since 2.2.18pre9 */
++		  mnt_version = 4; /* since 2.2.18pre9 */
+ 	     else if (kernel_version < MAKE_VERSION(2,3,99))
+-		  nfs_mount_version = 3;
++		  mnt_version = 3;
++	     else if (kernel_version < MAKE_VERSION(2,6,3))
++		  mnt_version = 4;
+ 	     else
+-		  nfs_mount_version = 4; /* since 2.3.99pre4 */
++		  mnt_version = 6;
+ 	}
+-	if (nfs_mount_version > NFS_MOUNT_VERSION)
+-	     nfs_mount_version = NFS_MOUNT_VERSION;
+-	return nfs_mount_version;
++	if (mnt_version > NFS_MOUNT_VERSION)
++	     mnt_version = NFS_MOUNT_VERSION;
++	return mnt_version;
+ }
+ 
+-static struct pmap *
+-get_mountport(struct sockaddr_in *server_addr,
+-      long unsigned prog,
+-      long unsigned version,
+-      long unsigned proto,
+-      long unsigned port,
+-      int nfs_mount_version)
++static int
++nfs_gethostbyname(const char *hostname, struct sockaddr_in *saddr)
+ {
+-	struct pmaplist *pmap;
+-	static struct pmap p = {0, 0, 0, 0};
++	struct hostent *hp;
+ 
+-	if (version > MAX_NFSPROT)
+-		version = MAX_NFSPROT;
+-	if (!prog)
+-		prog = MOUNTPROG;
+-	p.pm_prog = prog;
+-	p.pm_vers = version;
+-	p.pm_prot = proto;
+-	p.pm_port = port;
++	saddr->sin_family = AF_INET;
++	if (!inet_aton(hostname, &saddr->sin_addr)) {
++		if ((hp = gethostbyname(hostname)) == NULL) {
++			fprintf(stderr, _("mount: can't get address for %s\n"),
++				hostname);
++			return 0;
++		} else {
++			if (hp->h_length > sizeof(*saddr)) {
++				fprintf(stderr,
++					_("mount: got bad hp->h_length\n"));
++				hp->h_length = sizeof(*saddr);
++			}
++			memcpy(&saddr->sin_addr, hp->h_addr, hp->h_length);
++		}
++	}
++	return 1;
++}
+ 
+-	server_addr->sin_port = PMAPPORT;
+-	pmap = pmap_getmaps(server_addr);
++/*
++ * Sigh... pmap_getport() doesn't actually check the version number.
++ * In order to make sure that the server actually supports the service
++ * we're requesting, we open and RPC client, and fire off a NULL
++ * RPC call.
++ */
++int
++clnt_ping(struct sockaddr_in *saddr, const u_long prog, const u_long vers,
++	  const u_int prot)
++{
++	CLIENT *clnt=NULL;
++	int sock, stat;
++	static char clnt_res;
+ 
+-	while (pmap) {
+-		if (pmap->pml_map.pm_prog != prog)
+-			goto next;
+-		if (!version && p.pm_vers > pmap->pml_map.pm_vers)
+-			goto next;
+-		if (version > 2 && pmap->pml_map.pm_vers != version)
+-			goto next;
+-		if (version && version <= 2 && pmap->pml_map.pm_vers > 2)
+-			goto next;
+-		if (pmap->pml_map.pm_vers > MAX_NFSPROT ||
+-		    (proto && p.pm_prot && pmap->pml_map.pm_prot != proto) ||
+-		    (port && pmap->pml_map.pm_port != port))
+-			goto next;
+-		memcpy(&p, &pmap->pml_map, sizeof(p));
+-	next:
+-		pmap = pmap->pml_next;
++	rpc_createerr.cf_stat = stat = 0;
++	sock = RPC_ANYSOCK;
++	switch(prot) {
++	case IPPROTO_UDP:
++		clnt = clntudp_bufcreate(saddr, prog, vers,
++					 RETRY_TIMEOUT, &sock,
++					 RPCSMALLMSGSIZE, RPCSMALLMSGSIZE);
++		break;
++	case IPPROTO_TCP:
++		clnt = clnttcp_create(saddr, prog, vers, &sock,
++				      RPCSMALLMSGSIZE, RPCSMALLMSGSIZE);
++		break;
++	default:
++		goto out_bad;
+ 	}
+-	if (!p.pm_vers)
+-		p.pm_vers = MOUNTVERS;
+-	if (!p.pm_prot)
+-		p.pm_prot = IPPROTO_TCP;
+-#if 0
+-	if (!p.pm_port) {
+-		p.pm_port = pmap_getport(server_addr, p.pm_prog, p.pm_vers,
+-					 p.pm_prot);
++	if (!clnt)
++		goto out_bad;
++	memset(&clnt_res, 0, sizeof(clnt_res));
++	stat = clnt_call(clnt, NULLPROC,
++			 (xdrproc_t)xdr_void, (caddr_t)NULL,
++			 (xdrproc_t)xdr_void, (caddr_t)&clnt_res,
++			 TIMEOUT);
++	clnt_destroy(clnt);
++	close(sock);
++	if (stat != RPC_PROGVERSMISMATCH)
++		return 1;
++
++ out_bad:
++	return 0;
++}
++
++/*
++ * Use the portmapper to discover whether or not the service we want is
++ * available. The lists 'versions' and 'protos' define ordered sequences
++ * of service versions and udp/tcp protocols to probe for.
++ */
++static int
++probe_port(clnt_addr_t *server, 
++	   const u_long *versions,
++	   const u_int *protos)
++{
++	struct sockaddr_in *saddr = &server->saddr;
++	struct pmap *pmap = &server->pmap;
++	const u_long prog = pmap->pm_prog,
++		vers = pmap->pm_vers,
++		*p_vers;
++	const u_int prot = (u_int)pmap->pm_prot,
++		*p_prot;
++	const u_short port = (u_short) pmap->pm_port;
++	u_short p_port;
++	p_prot = prot ? &prot : protos;
++	p_vers = vers ? &vers : versions;
++	rpc_createerr.cf_stat = 0;
++	for (;;) {
++		saddr->sin_port = htons(PMAPPORT);
++		p_port = pmap_getport(saddr, prog, *p_vers, *p_prot);
++		if (p_port) {
++			if (!port || port == p_port) {
++				saddr->sin_port = htons(port);
++				if (clnt_ping(saddr, prog, *p_vers, *p_prot))
++					goto out_ok;
++			}
++		} else if (rpc_createerr.cf_stat != RPC_PROGNOTREGISTERED)
++			break;
++		if (!prot) {
++			if (*++p_prot)
++				continue;
++			p_prot = protos;
++		}
++		if (vers || !*++p_vers)
++			break;
+ 	}
++	return 0;
++ out_ok:
++	if (!vers)
++		pmap->pm_vers = *p_vers;
++	if (!prot)
++		pmap->pm_prot = *p_prot;
++	if (!port)
++		pmap->pm_port = p_port;
++	rpc_createerr.cf_stat = 0;
++	return 1;
++}
++
++static int
++probe_nfsport(clnt_addr_t *nfs_server)
++{
++	const struct pmap *pmap = &nfs_server->pmap;
++	const u_long *probe_vers;
++	const u_int *probe_prot;
++
++	if (pmap->pm_vers && pmap->pm_prot && pmap->pm_port)
++		return 1;
++	probe_vers = nfs_probelist(MAX_NFSPROT);
++	probe_prot = proto_probelist(HAVE_RELIABLE_TCP);
++	return probe_port(nfs_server, probe_vers, probe_prot);
++}
++
++static int
++probe_mntport(clnt_addr_t *mnt_server)
++{
++	const struct pmap *pmap = &mnt_server->pmap;
++	const u_long *probe_vers;
++	const u_int *probe_prot;
++
++	if (pmap->pm_vers && pmap->pm_prot && pmap->pm_port)
++		return 1;
++	probe_vers = mnt_probelist(MAX_MNTPROT);
++	probe_prot = proto_probelist(HAVE_RELIABLE_TCP);
++	return probe_port(mnt_server, probe_vers, probe_prot);
++}
++
++static int
++probe_bothports(clnt_addr_t *mnt_server, clnt_addr_t *nfs_server)
++{
++	struct pmap *nfs_pmap = &nfs_server->pmap;
++	struct pmap *mnt_pmap = &mnt_server->pmap;
++	struct pmap save_nfs, save_mnt;
++	int res;
++	const u_long *probe_vers;
++
++	if (mnt_pmap->pm_vers && !nfs_pmap->pm_vers)
++		nfs_pmap->pm_vers = mntvers_to_nfs(mnt_pmap->pm_vers);
++	else if (nfs_pmap->pm_vers && !mnt_pmap->pm_vers)
++		mnt_pmap->pm_vers = nfsvers_to_mnt(nfs_pmap->pm_vers);
++	if (nfs_pmap->pm_vers)
++		goto version_fixed;
++	memcpy(&save_nfs, nfs_pmap, sizeof(save_nfs));
++	memcpy(&save_mnt, mnt_pmap, sizeof(save_mnt));
++	for (probe_vers = mnt_probelist(MAX_MNTPROT); *probe_vers; probe_vers++) {
++		nfs_pmap->pm_vers = mntvers_to_nfs(*probe_vers);
++		if ((res = probe_nfsport(nfs_server) != 0)) {
++			mnt_pmap->pm_vers = *probe_vers;
++			if ((res = probe_mntport(mnt_server)) != 0)
++				return 1;
++			memcpy(mnt_pmap, &save_mnt, sizeof(*mnt_pmap));
++		}
++		if (rpc_createerr.cf_stat != RPC_PROGNOTREGISTERED)
++			break;
++		memcpy(nfs_pmap, &save_nfs, sizeof(*nfs_pmap));
++	}
++ out_bad:
++	return 0;
++ version_fixed:
++	if (!probe_nfsport(nfs_server))
++		goto out_bad;
++	return probe_mntport(mnt_server);
++}
++
++static CLIENT *
++mnt_openclnt(clnt_addr_t *mnt_server, int *msock, const int report_errs)
++{
++	struct sockaddr_in *mnt_saddr = &mnt_server->saddr;
++	struct pmap *mnt_pmap = &mnt_server->pmap;
++	CLIENT *clnt;
++
++	/* contact the mount daemon via TCP */
++	mnt_saddr->sin_port = htons((u_short)mnt_pmap->pm_port);
++	*msock = RPC_ANYSOCK;
++
++	switch (mnt_pmap->pm_prot) {
++	case IPPROTO_UDP:
++		clnt = clntudp_bufcreate(mnt_saddr,
++					 mnt_pmap->pm_prog, mnt_pmap->pm_vers,
++					 RETRY_TIMEOUT, msock,
++					 MNT_SENDBUFSIZE, MNT_RECVBUFSIZE);
++		break;
++	case IPPROTO_TCP:
++		clnt = clnttcp_create(mnt_saddr,
++				      mnt_pmap->pm_prog, mnt_pmap->pm_vers,
++				      msock,
++				      MNT_SENDBUFSIZE, MNT_RECVBUFSIZE);
++		break;
++	default:
++		goto out_bad;
++	}
++	if (!clnt)
++		goto report_err;
++	/* try to mount hostname:dirname */
++	clnt->cl_auth = authunix_create_default();
++	return clnt;
++ report_err:
++	if (report_errs)
++		clnt_pcreateerror("mount");
++ out_bad:
++	return NULL;
++}
++
++static inline void
++mnt_closeclnt(CLIENT *clnt, int msock)
++{
++	auth_destroy(clnt->cl_auth);
++	clnt_destroy(clnt);
++	close(msock);
++}
++
++static inline enum clnt_stat
++nfs3_mount(CLIENT *clnt, mnt3arg_t *mnt3arg, mnt3res_t *mnt3res)
++{
++	return clnt_call(clnt, MOUNTPROC3_MNT,
++			 (xdrproc_t) xdr_dirpath, (caddr_t) mnt3arg,
++			 (xdrproc_t) xdr_mountres3, (caddr_t) mnt3res,
++			 TIMEOUT);
++}
++
++static inline enum clnt_stat
++nfs2_mount(CLIENT *clnt, mnt2arg_t *mnt2arg, mnt2res_t *mnt2res)
++{
++	return clnt_call(clnt, MOUNTPROC_MNT,
++			 (xdrproc_t) xdr_dirpath, (caddr_t) mnt2arg,
++			 (xdrproc_t) xdr_fhstatus, (caddr_t) mnt2res,
++			 TIMEOUT);
++}
++
++static int
++nfs_call_mount(clnt_addr_t *mnt_server, clnt_addr_t *nfs_server,
++	       mntarg_t *mntarg, mntres_t *mntres, const int report_errs)
++{
++	CLIENT *clnt;
++	enum clnt_stat stat;
++	int msock;
++
++	if (!probe_bothports(mnt_server, nfs_server)) {
++		if (report_errs) {
++			fprintf(stderr, "mount to NFS server '%s' failed", 
++				*nfs_server->hostname);
++			if (rpc_createerr.cf_stat != RPC_PROGNOTREGISTERED) {
++				fprintf(stderr, ": server is down.\n");
++			} else  if (nfs_server->pmap.pm_prot) {
++				fprintf(stderr, ": possible invalid protocol.\n");
++			} else if (nfs_server->pmap.pm_port) {
++				fprintf(stderr, ": possible invalid port.\n");
++			} else {
++				fprintf(stderr, ".\n");
++			}
++			if (verbose) {
++				rpc_strerror();
++			}
++		}
++		goto out_bad;
++	}
++
++	clnt = mnt_openclnt(mnt_server, &msock, report_errs);
++	if (!clnt)
++		goto out_bad;
++	/* make pointers in xdr_mountres3 NULL so
++	 * that xdr_array allocates memory for us
++	 */
++	memset(mntres, 0, sizeof(*mntres));
++	switch (mnt_server->pmap.pm_vers) {
++	case 3:
++		stat = nfs3_mount(clnt, mntarg, &mntres->nfsv3);
++		break;
++	case 2:
++	case 1:
++		stat = nfs2_mount(clnt, mntarg, &mntres->nfsv2);
++		break;
++	default:
++		goto out_bad;
++	}
++	if (stat != RPC_SUCCESS && report_errs)
++		clnt_perror(clnt, "mount");
++	mnt_closeclnt(clnt, msock);
++	if (stat == RPC_SUCCESS)
++		return 1;
++ out_bad:
++	return 0;
++}
++
++static int
++parse_options(char *old_opts, struct nfs_mount_data *data,
++	      int *bg, int *retry, clnt_addr_t *mnt_server,
++	      clnt_addr_t *nfs_server, char *new_opts, const int opt_size)
++{
++	struct sockaddr_in *mnt_saddr = &mnt_server->saddr;
++	struct pmap *mnt_pmap = &mnt_server->pmap;
++	struct pmap *nfs_pmap = &nfs_server->pmap;
++	int len;
++	char *opt, *opteq;
++	char *mounthost = NULL;
++	char cbuf[128];
++
++	data->flags = 0;
++	*bg = 0;
++
++	len = strlen(new_opts);
++	for (opt = strtok(old_opts, ","); opt; opt = strtok(NULL, ",")) {
++		if (strlen(opt) >= sizeof(cbuf))
++			goto bad_parameter;
++		if ((opteq = strchr(opt, '=')) && isdigit(opteq[1])) {
++			int val = atoi(opteq + 1);	
++			*opteq = '\0';
++/* printf("opt=%s\n", opt); */
++			if (!strcmp(opt, "rsize"))
++				data->rsize = val;
++			else if (!strcmp(opt, "wsize"))
++				data->wsize = val;
++			else if (!strcmp(opt, "timeo"))
++				data->timeo = val;
++			else if (!strcmp(opt, "retrans"))
++				data->retrans = val;
++			else if (!strcmp(opt, "acregmin"))
++				data->acregmin = val;
++			else if (!strcmp(opt, "acregmax"))
++				data->acregmax = val;
++			else if (!strcmp(opt, "acdirmin"))
++				data->acdirmin = val;
++			else if (!strcmp(opt, "acdirmax"))
++				data->acdirmax = val;
++			else if (!strcmp(opt, "actimeo")) {
++				data->acregmin = val;
++				data->acregmax = val;
++				data->acdirmin = val;
++				data->acdirmax = val;
++			}
++			else if (!strcmp(opt, "retry"))
++				*retry = val;
++			else if (!strcmp(opt, "port"))
++				nfs_pmap->pm_port = val;
++			else if (!strcmp(opt, "mountport"))
++			        mnt_pmap->pm_port = val;
++			else if (!strcmp(opt, "mountprog"))
++				mnt_pmap->pm_prog = val;
++			else if (!strcmp(opt, "mountvers"))
++				mnt_pmap->pm_vers = val;
++			else if (!strcmp(opt, "mounthost"))
++				mounthost=xstrndup(opteq+1, strcspn(opteq+1," \t\n\r,"));
++			else if (!strcmp(opt, "nfsprog"))
++				nfs_pmap->pm_prog = val;
++			else if (!strcmp(opt, "nfsvers") ||
++				 !strcmp(opt, "vers")) {
++				nfs_pmap->pm_vers = val;
++				opt = "nfsvers";
++#if NFS_MOUNT_VERSION >= 2
++			} else if (!strcmp(opt, "namlen")) {
++				if (nfs_mount_version >= 2)
++					data->namlen = val;
++				else if (!sloppy)
++					goto bad_parameter;
+ #endif
+-#if 0
+-#define MOUNTPORT 635
+-	/* HJLu wants to remove all traces of the old default port.
+-	   Are there still people running a mount RPC service on this
+-	   port without having a portmapper? */
+-	if (!p.pm_port)
+-		p.pm_port = MOUNTPORT;
++			} else if (!strcmp(opt, "addr")) {
++				/* ignore */;
++				continue;
++ 			} else if (!sloppy)
++				goto bad_parameter;
++			sprintf(cbuf, "%s=%s,", opt, opteq+1);
++		} else if (opteq) {
++			*opteq = '\0';
++			if (!strcmp(opt, "proto")) {
++				if (!strcmp(opteq+1, "udp")) {
++					nfs_pmap->pm_prot = IPPROTO_UDP;
++#if NFS_MOUNT_VERSION >= 2
++					data->flags &= ~NFS_MOUNT_TCP;
++				} else if (!strcmp(opteq+1, "tcp") &&
++					   nfs_mount_version > 2) {
++					nfs_pmap->pm_prot = IPPROTO_TCP;
++					data->flags |= NFS_MOUNT_TCP;
+ #endif
+-	return &p;
++				} else if (!sloppy)
++					goto bad_parameter;
++#if NFS_MOUNT_VERSION >= 5
++			} else if (!strcmp(opt, "sec")) {
++				char *secflavor = opteq+1;
++				/* see RFC 2623 */
++				if (nfs_mount_version < 5) {
++					printf(_("Warning: ignoring sec=%s option\n"), secflavor);
++					continue;
++				} else if (!strcmp(secflavor, "sys"))
++					data->pseudoflavor = AUTH_SYS;
++				else if (!strcmp(secflavor, "krb5"))
++					data->pseudoflavor = AUTH_GSS_KRB5;
++				else if (!strcmp(secflavor, "krb5i"))
++					data->pseudoflavor = AUTH_GSS_KRB5I;
++				else if (!strcmp(secflavor, "krb5p"))
++					data->pseudoflavor = AUTH_GSS_KRB5P;
++				else if (!strcmp(secflavor, "lipkey"))
++					data->pseudoflavor = AUTH_GSS_LKEY;
++				else if (!strcmp(secflavor, "lipkey-i"))
++					data->pseudoflavor = AUTH_GSS_LKEYI;
++				else if (!strcmp(secflavor, "lipkey-p"))
++					data->pseudoflavor = AUTH_GSS_LKEYP;
++				else if (!strcmp(secflavor, "spkm3"))
++					data->pseudoflavor = AUTH_GSS_SPKM;
++				else if (!strcmp(secflavor, "spkm3i"))
++					data->pseudoflavor = AUTH_GSS_SPKMI;
++				else if (!strcmp(secflavor, "spkm3p"))
++					data->pseudoflavor = AUTH_GSS_SPKMP;
++				else if(!sloppy) {
++					printf(_("Warning: Unrecognized security flavor %s.\n"),
++						secflavor);
++					goto bad_parameter;
++				}
++				data->flags |= NFS_MOUNT_SECFLAVOUR;
++#endif
++			} else if (!strcmp(opt, "mounthost"))
++			        mounthost=xstrndup(opteq+1,
++						   strcspn(opteq+1," \t\n\r,"));
++			 else if (!strcmp(opt, "context")) {
++ 				char *context = opteq + 1;
++ 				
++ 				if (strlen(context) > NFS_MAX_CONTEXT_LEN) {
++ 					printf(_("context parameter exceeds limit of %d\n"),
++ 						 NFS_MAX_CONTEXT_LEN);
++					goto bad_parameter;
++ 				}
++ 				strncpy(data->context, context, NFS_MAX_CONTEXT_LEN);
++ 			} else if (!sloppy)
++				goto bad_parameter;
++			sprintf(cbuf, "%s=%s,", opt, opteq+1);
++		} else {
++			int val = 1;
++			if (!strncmp(opt, "no", 2)) {
++				val = 0;
++				opt += 2;
++			}
++			if (!strcmp(opt, "bg")) 
++				*bg = val;
++			else if (!strcmp(opt, "fg")) 
++				*bg = !val;
++			else if (!strcmp(opt, "soft")) {
++				data->flags &= ~NFS_MOUNT_SOFT;
++				if (val)
++					data->flags |= NFS_MOUNT_SOFT;
++			} else if (!strcmp(opt, "hard")) {
++				data->flags &= ~NFS_MOUNT_SOFT;
++				if (!val)
++					data->flags |= NFS_MOUNT_SOFT;
++			} else if (!strcmp(opt, "intr")) {
++				data->flags &= ~NFS_MOUNT_INTR;
++				if (val)
++					data->flags |= NFS_MOUNT_INTR;
++			} else if (!strcmp(opt, "posix")) {
++				data->flags &= ~NFS_MOUNT_POSIX;
++				if (val)
++					data->flags |= NFS_MOUNT_POSIX;
++			} else if (!strcmp(opt, "cto")) {
++				data->flags &= ~NFS_MOUNT_NOCTO;
++				if (!val)
++					data->flags |= NFS_MOUNT_NOCTO;
++			} else if (!strcmp(opt, "ac")) {
++				data->flags &= ~NFS_MOUNT_NOAC;
++				if (!val)
++					data->flags |= NFS_MOUNT_NOAC;
++#if NFS_MOUNT_VERSION >= 2
++			} else if (!strcmp(opt, "tcp")) {
++				data->flags &= ~NFS_MOUNT_TCP;
++				if (val) {
++					if (nfs_mount_version < 2)
++						goto bad_option;
++					nfs_pmap->pm_prot = IPPROTO_TCP;
++					data->flags |= NFS_MOUNT_TCP;
++				} else
++					nfs_pmap->pm_prot = IPPROTO_UDP;
++			} else if (!strcmp(opt, "udp")) {
++				data->flags &= ~NFS_MOUNT_TCP;
++				if (!val) {
++					if (nfs_mount_version < 2)
++						goto bad_option;
++					nfs_pmap->pm_prot = IPPROTO_TCP;
++					data->flags |= NFS_MOUNT_TCP;
++				} else
++					nfs_pmap->pm_prot = IPPROTO_UDP;
++#endif
++#if NFS_MOUNT_VERSION >= 3
++			} else if (!strcmp(opt, "lock")) {
++				data->flags &= ~NFS_MOUNT_NONLM;
++				if (!val) {
++					if (nfs_mount_version < 3)
++						goto bad_option;
++					data->flags |= NFS_MOUNT_NONLM;
++				}
++#endif
++#if NFS_MOUNT_VERSION >= 4
++			} else if (!strcmp(opt, "broken_suid")) {
++				data->flags &= ~NFS_MOUNT_BROKEN_SUID;
++				if (val) {
++					if (nfs_mount_version < 4)
++						goto bad_option;
++					data->flags |= NFS_MOUNT_BROKEN_SUID;
++				}
++#endif
++			} else {
++			bad_option:
++				if (!sloppy) {
++					printf(_("Unsupported nfs mount option: "
++						 "%s%s\n"), val ? "" : "no", opt);
++					goto out_bad;
++				}
++			}
++			sprintf(cbuf, val ? "%s,":"no%s,", opt);
++		}
++		len += strlen(cbuf);
++		if (len >= opt_size) {
++			printf(_("mount: excessively long option argument\n"));
++			goto out_bad;
++		}
++		strcat(new_opts, cbuf);
++	}
++	/* See if the nfs host = mount host. */
++	if (mounthost) {
++		if (!nfs_gethostbyname(mounthost, mnt_saddr))
++			goto out_bad;
++		*mnt_server->hostname = mounthost;
++	}
++	return 1;
++ bad_parameter:
++	printf(_("Bad nfs mount parameter: %s\n"), opt);
++ out_bad:
++	return 0;
+ }
+ 
+-int nfsmount(const char *spec, const char *node, int *flags,
+-	     char **extra_opts, char **mount_opts, int *nfs_mount_vers,
+-	     int running_bg)
++static inline int
++nfsmnt_check_compat(const struct pmap *nfs_pmap, const struct pmap *mnt_pmap)
++{
++	if (nfs_pmap->pm_vers && 
++		(nfs_pmap->pm_vers > MAX_NFSPROT || nfs_pmap->pm_vers < 2)) {
++		if (nfs_pmap->pm_vers == 4)
++			fprintf(stderr, _("'vers=4' is not supported.  "
++				"Use '-t nfs4' instead.\n"));
++		else
++			fprintf(stderr, _("NFS version %ld is not supported.\n"), 
++				nfs_pmap->pm_vers);
++		goto out_bad;
++	}
++	if (mnt_pmap->pm_vers > MAX_MNTPROT) {
++		fprintf(stderr, _("NFS mount version %ld s not supported.\n"), 
++			mnt_pmap->pm_vers);
++		goto out_bad;
++	}
++	return 1;
++ out_bad:
++	return 0;
++}
++
++int
++nfsmount(const char *spec, const char *node, int *flags,
++	 char **extra_opts, char **mount_opts, int *nfs_mount_vers,
++	 int running_bg)
+ {
+ 	static char *prev_bg_host;
+ 	char hostdir[1024];
+-	CLIENT *mclient;
+ 	char *hostname, *dirname, *old_opts, *mounthost = NULL;
+-	char new_opts[1024];
+-	struct timeval total_timeout;
+-	enum clnt_stat clnt_stat;
++	char new_opts[1024], cbuf[1024];
+ 	static struct nfs_mount_data data;
+-	char *opt, *opteq;
+-	int nfs_mount_version;
+ 	int val;
+-	struct hostent *hp;
+-	struct sockaddr_in server_addr;
+-	struct sockaddr_in mount_server_addr;
+-	struct pmap *pm_mnt;
+-	int msock, fsock;
+-	struct timeval retry_timeout;
+-	union {
+-		struct fhstatus nfsv2;
+-		struct mountres3 nfsv3;
+-	} status;
++
++	clnt_addr_t mnt_server = { &mounthost, };
++	clnt_addr_t nfs_server = { &hostname, };
++	struct sockaddr_in *nfs_saddr = &nfs_server.saddr;
++	struct pmap  *mnt_pmap = &mnt_server.pmap, 
++		     *nfs_pmap = &nfs_server.pmap;
++	struct pmap  save_mnt, save_nfs;
++
++	int fsock;
++
++	mntres_t mntres;
++
+ 	struct stat statbuf;
+ 	char *s;
+-	int port, mountport, proto, bg, soft, intr;
+-	int posix, nocto, noac, nolock, broken_suid;
+-	int retry, tcp;
+-	int mountprog, mountvers, nfsprog, nfsvers;
++	int bg, retry;
+ 	int retval;
+ 	time_t t;
+ 	time_t prevt;
+@@ -231,8 +851,7 @@
+ 	nfs_mount_version = *nfs_mount_vers;
+ 
+ 	retval = EX_FAIL;
+-	msock = fsock = -1;
+-	mclient = NULL;
++	fsock = -1;
+ 	if (strlen(spec) >= sizeof(hostdir)) {
+ 		fprintf(stderr, _("mount: "
+ 				  "excessively long host:dir argument\n"));
+@@ -258,49 +877,23 @@
+ 		goto fail;
+ 	}
+ 
+-	server_addr.sin_family = AF_INET;
+-#ifdef HAVE_inet_aton
+-	if (!inet_aton(hostname, &server_addr.sin_addr))
+-#endif
+-	{
+-		if ((hp = gethostbyname(hostname)) == NULL) {
+-			fprintf(stderr, _("mount: can't get address for %s\n"),
+-				hostname);
+-			goto fail;
+-		} else {
+-			if (hp->h_length > sizeof(struct in_addr)) {
+-				fprintf(stderr,
+-					_("mount: got bad hp->h_length\n"));
+-				hp->h_length = sizeof(struct in_addr);
+-			}
+-			memcpy(&server_addr.sin_addr,
+-			       hp->h_addr, hp->h_length);
+-		}
+-	}
+-
+-	memcpy (&mount_server_addr, &server_addr, sizeof (mount_server_addr));
++	if (!nfs_gethostbyname(hostname, nfs_saddr))
++		goto fail;
++	mounthost = hostname;
++	memcpy (&mnt_server.saddr, nfs_saddr, sizeof (mnt_server.saddr));
+ 
+ 	/* add IP address to mtab options for use when unmounting */
+ 
+-	s = inet_ntoa(server_addr.sin_addr);
++	s = inet_ntoa(nfs_saddr->sin_addr);
+ 	old_opts = *extra_opts;
+ 	if (!old_opts)
+ 		old_opts = "";
+-	if (strlen(old_opts) + strlen(s) + 10 >= sizeof(new_opts)) {
+-		fprintf(stderr, _("mount: "
+-				  "excessively long option argument\n"));
+-		goto fail;
+-	}
+-	sprintf(new_opts, "%s%saddr=%s",
+-		old_opts, *old_opts ? "," : "", s);
+-	*extra_opts = xstrdup(new_opts);
+ 
+ 	/* Set default options.
+ 	 * rsize/wsize (and bsize, for ver >= 3) are left 0 in order to
+ 	 * let the kernel decide.
+ 	 * timeo is filled in after we know whether it'll be TCP or UDP. */
+ 	memset(&data, 0, sizeof(data));
+-	data.retrans	= 3;
+ 	data.acregmin	= 3;
+ 	data.acregmax	= 60;
+ 	data.acdirmin	= 30;
+@@ -308,169 +901,24 @@
+ #if NFS_MOUNT_VERSION >= 2
+ 	data.namlen	= NAME_MAX;
+ #endif
++	data.pseudoflavor = AUTH_SYS;
+ 
+ 	bg = 0;
+-	soft = 0;
+-	intr = 0;
+-	posix = 0;
+-	nocto = 0;
+-	nolock = 0;
+-	broken_suid = 0;
+-	noac = 0;
+ 	retry = 10000;		/* 10000 minutes ~ 1 week */
+-	tcp = 0;
+ 
+-	mountprog = MOUNTPROG;
+-	mountvers = 0;
+-	port = 0;
+-	mountport = 0;
+-	nfsprog = NFS_PROGRAM;
+-	nfsvers = 0;
++	memset(mnt_pmap, 0, sizeof(*mnt_pmap));
++	mnt_pmap->pm_prog = MOUNTPROG;
++	memset(nfs_pmap, 0, sizeof(*nfs_pmap));
++	nfs_pmap->pm_prog = NFS_PROGRAM;
+ 
+ 	/* parse options */
++	new_opts[0] = 0;
++	if (!parse_options(old_opts, &data, &bg, &retry, &mnt_server, &nfs_server,
++			   new_opts, sizeof(new_opts)))
++		goto fail;
++	if (!nfsmnt_check_compat(nfs_pmap, mnt_pmap))
++		goto fail;
+ 
+-	for (opt = strtok(old_opts, ","); opt; opt = strtok(NULL, ",")) {
+-		if ((opteq = strchr(opt, '='))) {
+-			val = atoi(opteq + 1);	
+-			*opteq = '\0';
+-			if (!strcmp(opt, "rsize"))
+-				data.rsize = val;
+-			else if (!strcmp(opt, "wsize"))
+-				data.wsize = val;
+-			else if (!strcmp(opt, "timeo"))
+-				data.timeo = val;
+-			else if (!strcmp(opt, "retrans"))
+-				data.retrans = val;
+-			else if (!strcmp(opt, "acregmin"))
+-				data.acregmin = val;
+-			else if (!strcmp(opt, "acregmax"))
+-				data.acregmax = val;
+-			else if (!strcmp(opt, "acdirmin"))
+-				data.acdirmin = val;
+-			else if (!strcmp(opt, "acdirmax"))
+-				data.acdirmax = val;
+-			else if (!strcmp(opt, "actimeo")) {
+-				data.acregmin = val;
+-				data.acregmax = val;
+-				data.acdirmin = val;
+-				data.acdirmax = val;
+-			}
+-			else if (!strcmp(opt, "retry"))
+-				retry = val;
+-			else if (!strcmp(opt, "port"))
+-				port = val;
+-			else if (!strcmp(opt, "mountport"))
+-			        mountport = val;
+-			else if (!strcmp(opt, "mounthost"))
+-			        mounthost=xstrndup(opteq+1,
+-						   strcspn(opteq+1," \t\n\r,"));
+-			else if (!strcmp(opt, "mountprog"))
+-				mountprog = val;
+-			else if (!strcmp(opt, "mountvers"))
+-				mountvers = val;
+-			else if (!strcmp(opt, "nfsprog"))
+-				nfsprog = val;
+-			else if (!strcmp(opt, "nfsvers") ||
+-				 !strcmp(opt, "vers"))
+-				nfsvers = val;
+-			else if (!strcmp(opt, "proto")) {
+-				if (!strncmp(opteq+1, "tcp", 3))
+-					tcp = 1;
+-				else if (!strncmp(opteq+1, "udp", 3))
+-					tcp = 0;
+-				else
+-					printf(_("Warning: Unrecognized proto= option.\n"));
+-			} else if (!strcmp(opt, "namlen")) {
+-#if NFS_MOUNT_VERSION >= 2
+-				if (nfs_mount_version >= 2)
+-					data.namlen = val;
+-				else
+-#endif
+-					printf(_("Warning: Option namlen is not supported.\n"));
+-			} else if (!strcmp(opt, "addr")) {
+-				/* ignore */;
+-			} else {
+-				printf(_("unknown nfs mount parameter: "
+-					 "%s=%d\n"), opt, val);
+-				goto fail;
+-			}
+-		} else {
+-			val = 1;
+-			if (!strncmp(opt, "no", 2)) {
+-				val = 0;
+-				opt += 2;
+-			}
+-			if (!strcmp(opt, "bg")) 
+-				bg = val;
+-			else if (!strcmp(opt, "fg")) 
+-				bg = !val;
+-			else if (!strcmp(opt, "soft"))
+-				soft = val;
+-			else if (!strcmp(opt, "hard"))
+-				soft = !val;
+-			else if (!strcmp(opt, "intr"))
+-				intr = val;
+-			else if (!strcmp(opt, "posix"))
+-				posix = val;
+-			else if (!strcmp(opt, "cto"))
+-				nocto = !val;
+-			else if (!strcmp(opt, "ac"))
+-				noac = !val;
+-			else if (!strcmp(opt, "tcp"))
+-				tcp = val;
+-			else if (!strcmp(opt, "udp"))
+-				tcp = !val;
+-			else if (!strcmp(opt, "lock")) {
+-				if (nfs_mount_version >= 3)
+-					nolock = !val;
+-				else
+-					printf(_("Warning: option nolock is not supported.\n"));
+-			} else if (!strcmp(opt, "broken_suid")) {
+-				broken_suid = val;
+-			} else {
+-				if (!sloppy) {
+-					printf(_("unknown nfs mount option: "
+-						 "%s%s\n"), val ? "" : "no", opt);
+-					goto fail;
+-				}
+-			}
+-		}
+-	}
+-	proto = (tcp) ? IPPROTO_TCP : IPPROTO_UDP;
+-
+-	data.flags = (soft ? NFS_MOUNT_SOFT : 0)
+-		| (intr ? NFS_MOUNT_INTR : 0)
+-		| (posix ? NFS_MOUNT_POSIX : 0)
+-		| (nocto ? NFS_MOUNT_NOCTO : 0)
+-		| (noac ? NFS_MOUNT_NOAC : 0);
+-#if NFS_MOUNT_VERSION >= 2
+-	if (nfs_mount_version >= 2)
+-		data.flags |= (tcp ? NFS_MOUNT_TCP : 0);
+-#endif
+-#if NFS_MOUNT_VERSION >= 3
+-	if (nfs_mount_version >= 3)
+-		data.flags |= (nolock ? NFS_MOUNT_NONLM : 0);
+-#endif
+-#if NFS_MOUNT_VERSION >= 4
+-	if (nfs_mount_version >= 4)
+-		data.flags |= (broken_suid ? NFS_MOUNT_BROKEN_SUID : 0);
+-#endif
+-	if (nfsvers > MAX_NFSPROT) {
+-		fprintf(stderr, "NFSv%d not supported!\n", nfsvers);
+-		return 0;
+-	}
+-	if (mountvers > MAX_NFSPROT) {
+-		fprintf(stderr, "NFSv%d not supported!\n", nfsvers);
+-		return 0;
+-	}
+-	if (nfsvers && !mountvers)
+-		mountvers = (nfsvers < 3) ? 1 : nfsvers;
+-	if (nfsvers && nfsvers < mountvers)
+-		mountvers = nfsvers;
+-
+-	/* Adjust options if none specified */
+-	if (!data.timeo)
+-		data.timeo = tcp ? 70 : 7;
+ 
+ #ifdef NFS_MOUNT_DEBUG
+ 	printf("rsize = %d, wsize = %d, timeo = %d, retrans = %d\n",
+@@ -478,9 +926,10 @@
+ 	printf("acreg (min, max) = (%d, %d), acdir (min, max) = (%d, %d)\n",
+ 	       data.acregmin, data.acregmax, data.acdirmin, data.acdirmax);
+ 	printf("port = %d, bg = %d, retry = %d, flags = %.8x\n",
+-	       port, bg, retry, data.flags);
++	       nfs_pmap->pm_port, bg, retry, data.flags);
+ 	printf("mountprog = %d, mountvers = %d, nfsprog = %d, nfsvers = %d\n",
+-	       mountprog, mountvers, nfsprog, nfsvers);
++	       mnt_pmap->pm_prog, mnt_pmap->pm_vers,
++	       nfs_pmap->pm_prog, nfs_pmap->pm_vers);
+ 	printf("soft = %d, intr = %d, posix = %d, nocto = %d, noac = %d\n",
+ 	       (data.flags & NFS_MOUNT_SOFT) != 0,
+ 	       (data.flags & NFS_MOUNT_INTR) != 0,
+@@ -491,13 +940,16 @@
+ 	printf("tcp = %d\n",
+ 	       (data.flags & NFS_MOUNT_TCP) != 0);
+ #endif
++#if NFS_MOUNT_VERSION >= 5
++	printf("sec = %u\n", data.pseudoflavor);
++#endif
+ #endif
+ 
+ 	data.version = nfs_mount_version;
+ 	*mount_opts = (char *) &data;
+ 
+ 	if (*flags & MS_REMOUNT)
+-		return 0;
++		goto out_ok;
+ 
+ 	/*
+ 	 * If the previous mount operation on the same host was
+@@ -512,28 +964,6 @@
+ 	}
+ 
+ 	/* create mount deamon client */
+-	/* See if the nfs host = mount host. */
+-	if (mounthost) {
+-		if (mounthost[0] >= '0' && mounthost[0] <= '9') {
+-			mount_server_addr.sin_family = AF_INET;
+-			mount_server_addr.sin_addr.s_addr = inet_addr(hostname);
+-		} else {
+-			if ((hp = gethostbyname(mounthost)) == NULL) {
+-				fprintf(stderr, _("mount: can't get address for %s\n"),
+-					mounthost);
+-				goto fail;
+-			} else {
+-				if (hp->h_length > sizeof(struct in_addr)) {
+-					fprintf(stderr,
+-						_("mount: got bad hp->h_length?\n"));
+-					hp->h_length = sizeof(struct in_addr);
+-				}
+-				mount_server_addr.sin_family = AF_INET;
+-				memcpy(&mount_server_addr.sin_addr,
+-				       hp->h_addr, hp->h_length);
+-			}
+-		}
+-	}
+ 
+ 	/*
+ 	 * The following loop implements the mount retries. On the first
+@@ -551,15 +981,13 @@
+ 	 *
+ 	 * Only the first error message will be displayed.
+ 	 */
+-	retry_timeout.tv_sec = 3;
+-	retry_timeout.tv_usec = 0;
+-	total_timeout.tv_sec = 20;
+-	total_timeout.tv_usec = 0;
+ 	timeout = time(NULL) + 60 * retry;
+ 	prevt = 0;
+ 	t = 30;
+ 	val = 1;
+ 
++	memcpy(&save_nfs, nfs_pmap, sizeof(save_nfs));
++	memcpy(&save_mnt, mnt_pmap, sizeof(save_mnt));
+ 	for (;;) {
+ 		if (bg && stat(node, &statbuf) == -1) {
+ 			/* no mount point yet - sleep */
+@@ -570,89 +998,18 @@
+ 					val = 30;
+ 			}
+ 		} else {
++			int stat;
+ 			/* be careful not to use too many CPU cycles */
+ 			if (t - prevt < 30)
+ 				sleep(30);
+ 
+-			pm_mnt = get_mountport(&mount_server_addr,
+-					       mountprog,
+-					       mountvers,
+-					       proto,
+-					       mountport,
+-					       nfs_mount_version);
+-
+-			/* contact the mount daemon via TCP */
+-			mount_server_addr.sin_port = htons(pm_mnt->pm_port);
+-			msock = RPC_ANYSOCK;
+-
+-			switch (pm_mnt->pm_prot) {
+-			case IPPROTO_UDP:
+-				mclient = clntudp_create(&mount_server_addr,
+-							 pm_mnt->pm_prog,
+-							 pm_mnt->pm_vers,
+-							 retry_timeout,
+-							 &msock);
+-				if (mclient)
+-					break;
+-				mount_server_addr.sin_port =
+-					htons(pm_mnt->pm_port);
+-				msock = RPC_ANYSOCK;
+-			case IPPROTO_TCP:
+-				mclient = clnttcp_create(&mount_server_addr,
+-							 pm_mnt->pm_prog,
+-							 pm_mnt->pm_vers,
+-							 &msock, 0, 0);
++			stat = nfs_call_mount(&mnt_server, &nfs_server,
++					      &dirname, &mntres,
++					      !running_bg && prevt == 0);
++			if (stat)
+ 				break;
+-			default:
+-				mclient = 0;
+-			}
+-
+-			if (mclient) {
+-				/* try to mount hostname:dirname */
+-				mclient->cl_auth = authunix_create_default();
+-
+-				/* make pointers in xdr_mountres3 NULL so
+-				 * that xdr_array allocates memory for us
+-				 */
+-				memset(&status, 0, sizeof(status));
+-
+-				if (pm_mnt->pm_vers == 3)
+-					clnt_stat = clnt_call(mclient,
+-						     MOUNTPROC3_MNT,
+-						     (xdrproc_t) xdr_dirpath,
+-						     (caddr_t) &dirname,
+-						     (xdrproc_t) xdr_mountres3,
+-						     (caddr_t) &status,
+-						     total_timeout);
+-				else
+-					clnt_stat = clnt_call(mclient,
+-						     MOUNTPROC_MNT,
+-						     (xdrproc_t) xdr_dirpath,
+-						     (caddr_t) &dirname,
+-						     (xdrproc_t) xdr_fhstatus,
+-						     (caddr_t) &status,
+-						     total_timeout);
+-
+-				if (clnt_stat == RPC_SUCCESS)
+-					break;		/* we're done */
+-#if 0
+-				/* errno? who sets errno? */
+-				/* this fragment breaks bg mounting */
+-				if (errno != ECONNREFUSED) {
+-					clnt_perror(mclient, "mount");
+-					goto fail;	/* don't retry */
+-				}
+-#endif
+-				if (!running_bg && prevt == 0)
+-					clnt_perror(mclient, "mount");
+-				auth_destroy(mclient->cl_auth);
+-				clnt_destroy(mclient);
+-				mclient = 0;
+-				close(msock);
+-			} else {
+-				if (!running_bg && prevt == 0)
+-					clnt_pcreateerror("mount");
+-			}
++			memcpy(nfs_pmap, &save_nfs, sizeof(*nfs_pmap));
++			memcpy(mnt_pmap, &save_mnt, sizeof(*mnt_pmap));
+ 			prevt = t;
+ 		}
+ 
+@@ -668,36 +1025,63 @@
+ 		if (t >= timeout)
+ 			goto fail;
+ 	}
+-	nfsvers = (pm_mnt->pm_vers < 2) ? 2 : pm_mnt->pm_vers;
+ 
+-	if (nfsvers == 2) {
+-		if (status.nfsv2.fhs_status != 0) {
++	if (nfs_pmap->pm_vers == 2) {
++		if (mntres.nfsv2.fhs_status != 0) {
+ 			fprintf(stderr,
+-				"mount: %s:%s failed, reason given by server: %s\n",
++				_("mount: %s:%s failed, reason given by server: %s\n"),
+ 				hostname, dirname,
+-				nfs_strerror(status.nfsv2.fhs_status));
++				nfs_strerror(mntres.nfsv2.fhs_status));
+ 			goto fail;
+ 		}
+ 		memcpy(data.root.data,
+-		       (char *) status.nfsv2.fhstatus_u.fhs_fhandle,
++		       (char *) mntres.nfsv2.fhstatus_u.fhs_fhandle,
+ 		       NFS_FHSIZE);
+ #if NFS_MOUNT_VERSION >= 4
+ 		data.root.size = NFS_FHSIZE;
+ 		memcpy(data.old_root.data,
+-		       (char *) status.nfsv2.fhstatus_u.fhs_fhandle,
++		       (char *) mntres.nfsv2.fhstatus_u.fhs_fhandle,
+ 		       NFS_FHSIZE);
+ #endif
+ 	} else {
+ #if NFS_MOUNT_VERSION >= 4
++		mountres3_ok *mountres;
+ 		fhandle3 *fhandle;
+-		if (status.nfsv3.fhs_status != 0) {
++		int i, *flavor, yum = 0;
++		if (mntres.nfsv3.fhs_status != 0) {
+ 			fprintf(stderr,
+-				"mount: %s:%s failed, reason given by server: %s\n",
++				_("mount: %s:%s failed, reason given by server: %s\n"),
+ 				hostname, dirname,
+-				nfs_strerror(status.nfsv3.fhs_status));
++				nfs_strerror(mntres.nfsv3.fhs_status));
+ 			goto fail;
+ 		}
+-		fhandle = &status.nfsv3.mountres3_u.mountinfo.fhandle;
++#if NFS_MOUNT_VERSION >= 5
++		mountres = &mntres.nfsv3.mountres3_u.mountinfo;
++		i = mountres->auth_flavours.auth_flavours_len;
++		if (i <= 0) 
++			goto noauth_flavours;
++
++		flavor = mountres->auth_flavours.auth_flavours_val;
++		while (--i >= 0) {
++			if (flavor[i] == data.pseudoflavor)
++				yum = 1;
++#ifdef NFS_MOUNT_DEBUG
++			printf("auth flavor %d: %d\n",
++				i, flavor[i]);
++#endif
++		}
++		if (!yum) {
++			fprintf(stderr,
++				"mount: %s:%s failed, "
++				"security flavor not supported\n",
++				hostname, dirname);
++			/* server has registered us in mtab, send umount */
++			nfs_call_umount(&mnt_server, &dirname);
++			goto fail;
++		}
++noauth_flavours:
++#endif
++		fhandle = &mntres.nfsv3.mountres3_u.mountinfo.fhandle;
+ 		memset(data.old_root.data, 0, NFS_FHSIZE);
+ 		memset(&data.root, 0, sizeof(data.root));
+ 		data.root.size = fhandle->fhandle3_len;
+@@ -711,13 +1095,9 @@
+ 
+ 	/* create nfs socket for kernel */
+ 
+-	if (tcp) {
+-		if (nfs_mount_version < 3) {
+-	     		printf(_("NFS over TCP is not supported.\n"));
+-			goto fail;
+-		}
++	if (nfs_pmap->pm_prot == IPPROTO_TCP)
+ 		fsock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
+-	} else
++	else
+ 		fsock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
+ 	if (fsock < 0) {
+ 		perror(_("nfs socket"));
+@@ -727,72 +1107,163 @@
+ 		perror(_("nfs bindresvport"));
+ 		goto fail;
+ 	}
+-	if (port == 0) {
+-		server_addr.sin_port = PMAPPORT;
+-		port = pmap_getport(&server_addr, nfsprog, nfsvers,
+-				    tcp ? IPPROTO_TCP : IPPROTO_UDP);
+-#if 1
+-		/* Here we check to see if user is mounting with the
+-		 * tcp option.  If so, and if the portmap returns a
+-		 * '0' for port (service unavailable), we then exit,
+-		 * notifying the user, rather than hanging up mount.
+-		 */
+-		if (port == 0 && tcp == 1) {
+-			perror(_("nfs server reported service unavailable"));
+-			goto fail;
+-		}
+-#endif
+-
+-		if (port == 0)
+-			port = NFS_PORT;
+-#ifdef NFS_MOUNT_DEBUG
+-		else
+-			printf(_("used portmapper to find NFS port\n"));
+-#endif
+-	}
+ #ifdef NFS_MOUNT_DEBUG
+-	printf(_("using port %d for nfs deamon\n"), port);
++	printf(_("using port %d for nfs deamon\n"), nfs_pmap->pm_port);
+ #endif
+-	server_addr.sin_port = htons(port);
++	nfs_saddr->sin_port = htons(nfs_pmap->pm_port);
+ 	/*
+ 	 * connect() the socket for kernels 1.3.10 and below only,
+ 	 * to avoid problems with multihomed hosts.
+ 	 * --Swen
+ 	 */
+ 	if (linux_version_code() <= 66314
+-	    && connect(fsock, (struct sockaddr *) &server_addr,
+-		       sizeof (server_addr)) < 0) {
++	    && connect(fsock, (struct sockaddr *) nfs_saddr,
++		       sizeof (*nfs_saddr)) < 0) {
+ 		perror(_("nfs connect"));
+ 		goto fail;
+ 	}
+ 
++#if NFS_MOUNT_VERSION >= 2
++	if (nfs_pmap->pm_prot == IPPROTO_TCP)
++		data.flags |= NFS_MOUNT_TCP;
++	else
++		data.flags &= ~NFS_MOUNT_TCP;
++#endif
++
+ 	/* prepare data structure for kernel */
+ 
+ 	data.fd = fsock;
+-	memcpy((char *) &data.addr, (char *) &server_addr, sizeof(data.addr));
++	memcpy((char *) &data.addr, (char *) nfs_saddr, sizeof(data.addr));
+ 	strncpy(data.hostname, hostname, sizeof(data.hostname));
+ 
+-	/* clean up */
++ out_ok:
++	/* Ensure we have enough padding for the following strcat()s */
++	if (strlen(new_opts) + strlen(s) + 30 >= sizeof(new_opts)) {
++		fprintf(stderr, _("mount: "
++				  "excessively long option argument\n"));
++		goto fail;
++	}
+ 
+-	auth_destroy(mclient->cl_auth);
+-	clnt_destroy(mclient);
+-	close(msock);
++	snprintf(cbuf, sizeof(cbuf)-1, "addr=%s", s);
++	strcat(new_opts, cbuf);
++
++	*extra_opts = xstrdup(new_opts);
+ 	return 0;
+ 
+ 	/* abort */
+-
+  fail:
+-	if (msock != -1) {
+-		if (mclient) {
+-			auth_destroy(mclient->cl_auth);
+-			clnt_destroy(mclient);
+-		}
+-		close(msock);
+-	}
+ 	if (fsock != -1)
+ 		close(fsock);
+ 	return retval;
+-}	
++}
++
++static inline enum clnt_stat
++nfs3_umount(dirpath *argp, CLIENT *clnt)
++{
++	static char clnt_res;
++	memset (&clnt_res, 0, sizeof(clnt_res));
++	return clnt_call(clnt, MOUNTPROC_UMNT,
++			 (xdrproc_t) xdr_dirpath, (caddr_t)argp,
++			 (xdrproc_t) xdr_void, (caddr_t) &clnt_res,
++			 TIMEOUT);
++}
++
++static inline enum clnt_stat
++nfs2_umount(dirpath *argp, CLIENT *clnt)
++{
++	static char clnt_res;
++	memset (&clnt_res, 0, sizeof(clnt_res));
++	return clnt_call(clnt, MOUNTPROC_UMNT,
++			 (xdrproc_t) xdr_dirpath, (caddr_t)argp,
++			 (xdrproc_t) xdr_void, (caddr_t) &clnt_res,
++			 TIMEOUT);
++}
++
++static int
++nfs_call_umount(clnt_addr_t *mnt_server, dirpath *argp)
++{
++	CLIENT *clnt;
++	enum clnt_stat res = 0;
++	int msock;
++
++	clnt = mnt_openclnt(mnt_server, &msock, 1);
++	if (!clnt)
++		goto out_bad;
++	switch (mnt_server->pmap.pm_vers) {
++	case 3:
++		res = nfs3_umount(argp, clnt);
++		break;
++	case 2:
++	case 1:
++		res = nfs2_umount(argp, clnt);
++		break;
++	default:
++		break;
++	}
++	mnt_closeclnt(clnt, msock);
++	if (res == RPC_SUCCESS)
++		return 1;
++ out_bad:
++	return 0;
++}
++
++int
++nfsumount(const char *spec, const char *opts)
++{
++	char *hostname;
++	char *dirname;
++	clnt_addr_t mnt_server = { &hostname, };
++	struct pmap *pmap = &mnt_server.pmap;
++	char *p;
++
++	nfs_mount_version = find_kernel_nfs_mount_version();
++	if (spec == NULL || (p = strchr(spec,':')) == NULL)
++		goto out_bad;
++	hostname = xstrndup(spec, p-spec);
++	dirname = xstrdup(p+1);
++#ifdef NFS_MOUNT_DEBUG
++	printf(_("host: %s, directory: %s\n"), hostname, dirname);
++#endif
++
++	if (opts && (p = strstr(opts, "addr="))) {
++		char *q;
++
++		free(hostname);
++		p += 5;
++		q = p;
++		while (*q && *q != ',') q++;
++		hostname = xstrndup(p,q-p);
++	}
++
++	if (opts && (p = strstr(opts, "mounthost="))) {
++		char *q;
++
++		free(hostname);
++		p += 10;
++		q = p;
++		while (*q && *q != ',') q++;
++		hostname = xstrndup(p,q-p);
++	}
++
++	pmap->pm_prog = MOUNTPROG;
++	pmap->pm_vers = MOUNTVERS;
++	if (opts && (p = strstr(opts, "mountprog=")) && isdigit(*(p+10)))
++		pmap->pm_prog = atoi(p+10);
++	if (opts && (p = strstr(opts, "mountport=")) && isdigit(*(p+10)))
++		pmap->pm_port = atoi(p+10);
++	if (opts && (p = strstr(opts, "nfsvers=")) && isdigit(*(p+8)))
++		pmap->pm_vers = nfsvers_to_mnt(atoi(p+8));
++	if (opts && (p = strstr(opts, "mountvers=")) && isdigit(*(p+10)))
++		pmap->pm_vers = atoi(p+10);
++
++	if (!nfs_gethostbyname(hostname, &mnt_server.saddr))
++		goto out_bad;
++	if (!probe_mntport(&mnt_server))
++		goto out_bad;
++	return nfs_call_umount(&mnt_server, &dirname);
++ out_bad:
++	return 0;
++}
+ 
+ /*
+  * We need to translate between nfs status return values and
+diff -urNad --exclude=CVS --exclude=.svn ./mount/sundries.h /tmp/dpep-work.TJbhsa/2.12r-5.1/mount/sundries.h
+--- ./mount/sundries.h	2006-01-18 12:50:08.000000000 -0700
++++ /tmp/dpep-work.TJbhsa/2.12r-5.1/mount/sundries.h	2006-01-18 12:52:52.000000000 -0700
+@@ -37,6 +37,9 @@
+ #ifdef HAVE_NFS
+ int nfsmount (const char *spec, const char *node, int *flags,
+ 	      char **orig_opts, char **opt_args, int *version, int running_bg);
++int nfs4mount (const char *spec, const char *node, int *flags,
++		char **orig_opts, char **opt_args, int running_bg);
++int nfsumount(const char *spec, const char *opts);
+ #endif
+ 
+ /* exit status - bits below are ORed */
+diff -urNad --exclude=CVS --exclude=.svn ./mount/umount.c /tmp/dpep-work.TJbhsa/2.12r-5.1/mount/umount.c
+--- ./mount/umount.c	2006-01-18 12:52:52.000000000 -0700
++++ /tmp/dpep-work.TJbhsa/2.12r-5.1/mount/umount.c	2006-01-18 12:52:52.000000000 -0700
+@@ -90,6 +90,11 @@
+ /* True if ruid != euid.  */
+ int suid = 0;
+ 
++/* Needed by nfs4mount.c */
++int sloppy = 0;
++
++
++
+ /*
+  * check_special_umountprog()
+  *	If there is a special umount program for this type, exec it.
+@@ -297,7 +302,7 @@
+ 	/* Ignore any RPC errors, so that you can umount the filesystem
+ 	   if the server is down.  */
+ 	if (strcasecmp(type, "nfs") == 0)
+-		nfs_umount_rpc_call(spec, opts);
++		nfsumount(spec, opts);
+ #endif
+  
+ 	umnt_err = umnt_err2 = 0;
--- util-linux-2.12r.orig/debian/patches/30swsusp-resume.dpatch
+++ util-linux-2.12r/debian/patches/30swsusp-resume.dpatch
@@ -0,0 +1,172 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 30swsusp-resume.dpatch by Jeff Bailey <jbailey@ubuntu.com>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: agetty changes in Debian.  The biggest part is switching from
+## DP: termio to termios.  The only other thing is a block of turned-off
+## DP: code trying to interoperate better with gdm.
+
+@DPATCH@
+diff -urNad --exclude=CVS --exclude=.svn ./mount/get_label_uuid.c /tmp/dpep-work.5ak7Cm/util-linux/mount/get_label_uuid.c
+--- ./mount/get_label_uuid.c	2004-12-22 08:44:32.000000000 -0700
++++ /tmp/dpep-work.5ak7Cm/util-linux/mount/get_label_uuid.c	2005-12-06 11:54:33.000000000 -0700
+@@ -93,7 +93,24 @@
+ 	}
+ 	return 0;
+ }
+-	    
++
++static int
++is_swsuspend_partition(int fd, char **label, char *uuid) {
++	int n = getpagesize();
++	char *buf = xmalloc(n);
++	struct swap_header_v1_2 *p = (struct swap_header_v1_2 *) buf;
++
++	if (lseek(fd, 0, SEEK_SET) == 0
++	    && read(fd, buf, n) == n
++	    && (strncmp(buf+n-10, "S1SUSPEND", 9)==0 || 
++		    strncmp(buf+n-10, "S2SUSPEND", 9)==0)
++	    && p->version == 1) {
++		store_uuid(uuid, p->uuid);
++		store_label(label, p->volume_name, 16);
++		return 1;
++	}
++	return 0;
++}
+ 
+ /*
+  * Get both label and uuid.
+@@ -126,6 +143,8 @@
+ 
+ 	if (is_v1_swap_partition(fd, label, uuid))
+ 		goto done;
++	if (is_swsuspend_partition(fd, label, uuid))
++		goto done;
+ 
+ 	if (lseek(fd, 1024, SEEK_SET) == 1024
+ 	    && read(fd, (char *) &e2sb, sizeof(e2sb)) == sizeof(e2sb)
+diff -urNad --exclude=CVS --exclude=.svn ./mount/swapon.c /tmp/dpep-work.5ak7Cm/util-linux/mount/swapon.c
+--- ./mount/swapon.c	2004-12-22 08:44:32.000000000 -0700
++++ /tmp/dpep-work.5ak7Cm/util-linux/mount/swapon.c	2005-12-06 11:54:33.000000000 -0700
+@@ -11,6 +11,9 @@
+ #include <mntent.h>
+ #include <errno.h>
+ #include <sys/stat.h>
++#include <sys/types.h>
++#include <sys/wait.h>
++#include <fcntl.h>
+ #include "xmalloc.h"
+ #include "swap_constants.h"
+ #include "swapargs.h"
+@@ -22,6 +25,7 @@
+ 
+ #define	_PATH_FSTAB     "/etc/fstab"
+ #define PROC_SWAPS      "/proc/swaps"
++#define PATH_MKSWAP	"/sbin/mkswap"
+ 
+ #define SWAPON_NEEDS_TWO_ARGS
+ 
+@@ -164,6 +168,84 @@
+        return 0 ;
+ }
+ 
++/*
++ * It's better do swsuspend detection by follow routine than
++ * include huge mount_guess_fstype.o to swapon. We need only
++ * swsuspend and no the others filesystems.
++ */
++#ifdef HAVE_LIBBLKID
++static int
++swap_is_swsuspend(const char *device) {
++	const char *type = blkid_get_tag_value(blkid, "TYPE", device);
++	
++	if (type && strcmp(type, "swsuspend")==0)
++		return 0;
++	return 1;
++}
++#else
++static int
++swap_is_swsuspend(const char *device) {
++	int fd, re = 1, n = getpagesize() - 10;
++	char buf[10];
++	
++	fd = open(device, O_RDONLY);
++	if (fd < 0)
++		return -1;
++
++	if (lseek(fd, n, SEEK_SET) >= 0 &&
++	    read(fd, buf, sizeof buf) == sizeof buf &&
++	    (memcmp("S1SUSPEND", buf, 9)==0 ||
++			memcmp("S2SUSPEND", buf, 9)==0))
++		re = 0;
++
++	close(fd);
++	return re;
++}
++#endif
++
++/* calls mkswap */
++static int
++swap_reinitialize(const char *device) {
++	const char *label = mount_get_volume_label_by_spec(device);
++	pid_t pid;
++	
++	switch((pid=fork())) {
++		case -1: /* fork error */
++			fprintf(stderr, _("%s: cannot fork: %s\n"),
++				progname, strerror(errno));
++			return -1;
++			
++		case 0:	/* child */
++			if (label && *label)
++				execl(PATH_MKSWAP, PATH_MKSWAP, "-L", label, device, NULL);
++			else
++				execl(PATH_MKSWAP, PATH_MKSWAP, device, NULL);
++			exit(1); /* error  */
++			
++		default: /* parent */
++		{
++			int status;
++			int ret;
++
++			do {
++				if ((ret = waitpid(pid, &status, 0)) < 0 
++						&& errno == EINTR)
++					continue;
++				else if (ret < 0) {
++					fprintf(stderr, _("%s: waitpid: %s\n"),
++						progname, strerror(errno));
++					return -1;
++		      		}
++			} while (0);
++
++			/* mkswap returns: 0=suss, 1=error */
++			if (WIFEXITED(status) && WEXITSTATUS(status)==0)
++				return 0; /* ok */
++		}
++	}
++	return -1; /* error */
++}
++	
+ static int
+ do_swapon(const char *orig_special, int prio) {
+ 	int status;
+@@ -187,6 +269,18 @@
+ 		return -1;
+ 	}
+ 
++	/* We have to reinitialize swap with old (=useless) software suspend 
++	 * data. The problem is that if we don't do it, then we get data 
++	 * corruption the next time with suspended on.
++	 */
++	if (swap_is_swsuspend(special)==0) {
++		fprintf(stdout, _("%s: %s: software suspend data detected. "
++					"Reinitializing the swap.\n"), 
++			progname, special);
++		if (swap_reinitialize(special) < 0)
++			return -1;
++	}
++	
+ 	/* people generally dislike this warning - now it is printed
+ 	   only when `verbose' is set */
+ 	if (verbose) {
--- util-linux-2.12r.orig/debian/patches/50hurd.dpatch
+++ util-linux-2.12r/debian/patches/50hurd.dpatch
@@ -0,0 +1,2362 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 50hurd.dpatch by LaMont Jones <lamont@debian.org>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Add hurd support
+
+@DPATCH@
+diff -urNad util-linux/login-utils/agetty.c /tmp/dpep.xj6GpA/util-linux/login-utils/agetty.c
+--- util-linux/login-utils/agetty.c	2002-07-29 01:36:42.000000000 -0600
++++ /tmp/dpep.xj6GpA/util-linux/login-utils/agetty.c	2004-12-15 07:03:54.720029395 -0700
+@@ -17,8 +17,7 @@
+ #include <unistd.h>
+ #include <stdlib.h>
+ #include <string.h>
+-#include <sys/ioctl.h>
+-#include <termio.h>
++#include <termios.h>
+ #include <signal.h>
+ #include <errno.h>
+ #include <sys/types.h>
+@@ -93,27 +95,6 @@
+ #define DEF_SWITCH	0		/* default switch char */
+ 
+  /*
+-  * SunOS 4.1.1 termio is broken. We must use the termios stuff instead,
+-  * because the termio -> termios translation does not clear the termios
+-  * CIBAUD bits. Therefore, the tty driver would sometimes report that input
+-  * baud rate != output baud rate. I did not notice that problem with SunOS
+-  * 4.1. We will use termios where available, and termio otherwise.
+-  */
+-
+-/* linux 0.12 termio is broken too, if we use it c_cc[VERASE] isn't set
+-   properly, but all is well if we use termios?! */
+-
+-#ifdef	TCGETS
+-#undef	TCGETA
+-#undef	TCSETA
+-#undef	TCSETAW
+-#define	termio	termios
+-#define	TCGETA	TCGETS
+-#define	TCSETA	TCSETS
+-#define	TCSETAW	TCSETSW
+-#endif
+-
+- /*
+   * This program tries to not use the standard-i/o library.  This keeps the
+   * executable small on systems that do not have shared libraries (System V
+   * Release <3).
+@@ -221,13 +202,13 @@
+ void parse_args P_((int argc, char **argv, struct options *op));
+ void parse_speeds P_((struct options *op, char *arg));
+ void update_utmp P_((char *line));
+-void open_tty P_((char *tty, struct termio *tp, int local));
+-void termio_init P_((struct termio *tp, int speed, struct options *op));
+-void auto_baud P_((struct termio *tp));
+-void do_prompt P_((struct options *op, struct termio *tp));
+-void next_speed P_((struct termio *tp, struct options *op));
+-char *get_logname P_((struct options *op, struct chardata *cp, struct termio *tp));
+-void termio_final P_((struct options *op, struct termio *tp, struct chardata *cp));
++void open_tty P_((char *tty, struct termios *tp, int local));
++void termios_init P_((struct termios *tp, int speed, struct options *op));
++void auto_baud P_((struct termios *tp));
++void do_prompt P_((struct options *op, struct termios *tp));
++void next_speed P_((struct termios *tp, struct options *op));
++char *get_logname P_((struct options *op, struct chardata *cp, struct termios *tp));
++void termios_final P_((struct options *op, struct termios *tp, struct chardata *cp));
+ int caps_lock P_((char *s));
+ int bcode P_((char *s));
+ void usage P_((void));
+@@ -256,7 +237,7 @@
+ {
+     char   *logname = NULL;		/* login name, given to /bin/login */
+     struct chardata chardata;		/* set by get_logname() */
+-    struct termio termio;		/* terminal mode bits */
++    struct termios termios;		/* terminal mode bits */
+     static struct options options = {
+ 	F_ISSUE,			/* show /etc/issue (SYSV_STYLE) */
+ 	0,				/* no timeout */
+@@ -311,19 +292,19 @@
+ 
+     debug(_("calling open_tty\n"));
+     /* Open the tty as standard { input, output, error }. */
+-    open_tty(options.tty, &termio, options.flags & F_LOCAL);
++    open_tty(options.tty, &termios, options.flags & F_LOCAL);
+ 
+ #ifdef __linux__
+ 	{
+ 		int iv;
+ 		
+ 		iv = getpid();
+-		(void) ioctl(0, TIOCSPGRP, &iv);
++		(void) tcsetpgrp(0, iv);
+ 	}
+ #endif
+-    /* Initialize the termio settings (raw mode, eight-bit, blocking i/o). */
+-    debug(_("calling termio_init\n"));
+-    termio_init(&termio, options.speeds[FIRST_SPEED], &options);
++    /* Initialize the termios settings (raw mode, eight-bit, blocking i/o). */
++    debug(_("calling termios_init\n"));
++    termios_init(&termios, options.speeds[FIRST_SPEED], &options);
+ 
+     /* write the modem init string and DON'T flush the buffers */
+     if (options.flags & F_INITSTRING) {
+@@ -339,7 +320,7 @@
+     /* Optionally detect the baud rate from the modem status message. */
+     debug(_("before autobaud\n"));
+     if (options.flags & F_PARSE)
+-	auto_baud(&termio);
++	auto_baud(&termios);
+ 
+     /* Set the optional timer. */
+     if (options.timeout)
+@@ -363,8 +344,8 @@
+     if (!(options.flags & F_NOPROMPT)) {
+ 	/* Read the login name. */
+ 	debug(_("reading login name\n"));
+-	while ((logname = get_logname(&options, &chardata, &termio)) == 0)
+-	  next_speed(&termio, &options);
++	while ((logname = get_logname(&options, &chardata, &termios)) == 0)
++	  next_speed(&termios, &options);
+     }
+ 
+     /* Disable timer. */
+@@ -372,9 +353,9 @@
+     if (options.timeout)
+ 	(void) alarm(0);
+ 
+-    /* Finalize the termio settings. */
++    /* Finalize the termios settings. */
+ 
+-    termio_final(&options, &termio, &chardata);
++    termios_final(&options, &termios, &chardata);
+ 
+     /* Now the newline character should be properly written. */
+ 
+@@ -629,7 +610,7 @@
+ void
+ open_tty(tty, tp, local)
+      char   *tty;
+-     struct termio *tp;
++     struct termios *tp;
+      int    local;
+ {
+     /* Get rid of the present standard { output, error} if any. */
+@@ -678,7 +744,7 @@
+ 	error(_("%s: dup problem: %m"), tty);	/* we have a problem */
+ 
+     /*
+-     * The following ioctl will fail if stdin is not a tty, but also when
++     * The following function will fail if stdin is not a tty, but also when
+      * there is noise on the modem control lines. In the latter case, the
+      * common course of action is (1) fix your cables (2) give the modem more
+      * time to properly reset after hanging up. SunOS users can achieve (2)
+@@ -686,8 +752,8 @@
+      * 5 seconds seems to be a good value.
+      */
+ 
+-    if (ioctl(0, TCGETA, tp) < 0)
+-	error("%s: ioctl: %m", tty);
++    if (tcgetattr(0, tp) < 0)
++	error("%s: tcgetattr: %m", tty);
+ 
+     /*
+      * It seems to be a terminal. Set proper protections and ownership. Mode
+@@ -705,27 +771,27 @@
+     errno = 0;					/* ignore above errors */
+ }
+ 
+-/* termio_init - initialize termio settings */
++/* termios_init - initialize termios settings */
+ 
+ char gbuf[1024];
+ char area[1024];
+ 
+ void
+-termio_init(tp, speed, op)
+-     struct termio *tp;
++termios_init(tp, speed, op)
++     struct termios *tp;
+      int     speed;
+      struct options *op;
+ {
+ 
+     /*
+-     * Initial termio settings: 8-bit characters, raw-mode, blocking i/o.
++     * Initial termios settings: 8-bit characters, raw-mode, blocking i/o.
+      * Special characters are set after we have read the login name; all
+      * reads will be done in raw mode anyway. Errors will be dealt with
+      * lateron.
+      */
+ #ifdef __linux__
+     /* flush input and output queues, important for modems! */
+-    (void) ioctl(0, TCFLSH, TCIOFLUSH);
++    (void) tcflush(0, TCIOFLUSH);
+ #endif
+ 
+     tp->c_cflag = CS8 | HUPCL | CREAD | speed;
+@@ -733,7 +799,8 @@
+ 	tp->c_cflag |= CLOCAL;
+     }
+ 
+-    tp->c_iflag = tp->c_lflag = tp->c_oflag = tp->c_line = 0;
++    tp->c_iflag = tp->c_lflag = tp->c_oflag = 0;
++    tp->c_line = 0;
+     tp->c_cc[VMIN] = 1;
+     tp->c_cc[VTIME] = 0;
+ 
+@@ -744,7 +811,7 @@
+ 	tp->c_cflag |= CRTSCTS;
+ #endif
+ 
+-    (void) ioctl(0, TCSETA, tp);
++    (void) tcsetattr(0, TCSANOW, tp);
+ 
+     /* go to blocking input even in local mode */
+     fcntl(0, F_SETFL, fcntl(0, F_GETFL, 0) & ~O_NONBLOCK);
+@@ -755,7 +822,7 @@
+ /* auto_baud - extract baud rate from modem status message */
+ void
+ auto_baud(tp)
+-     struct termio *tp;
++     struct termios *tp;
+ {
+     int     speed;
+     int     vmin;
+@@ -788,7 +855,7 @@
+     tp->c_iflag |= ISTRIP;			/* enable 8th-bit stripping */
+     vmin = tp->c_cc[VMIN];
+     tp->c_cc[VMIN] = 0;				/* don't block if queue empty */
+-    (void) ioctl(0, TCSETA, tp);
++    (void) tcsetattr(0, TCSANOW, tp);
+ 
+     /*
+      * Wait for a while, then read everything the modem has said so far and
+@@ -801,8 +868,7 @@
+ 	for (bp = buf; bp < buf + nread; bp++) {
+ 	    if (isascii(*bp) && isdigit(*bp)) {
+ 		if ((speed = bcode(bp))) {
+-		    tp->c_cflag &= ~CBAUD;
+-		    tp->c_cflag |= speed;
++		    (void) cfsetospeed(tp, speed);
+ 		}
+ 		break;
+ 	    }
+@@ -812,14 +878,14 @@
+ 
+     tp->c_iflag = iflag;
+     tp->c_cc[VMIN] = vmin;
+-    (void) ioctl(0, TCSETA, tp);
++    (void) tcsetattr(0, TCSANOW, tp);
+ }
+ 
+ /* do_prompt - show login prompt, optionally preceded by /etc/issue contents */
+ void
+ do_prompt(op, tp)
+      struct options *op;
+-     struct termio *tp;
++     struct termios *tp;
+ {
+ #ifdef	ISSUE
+     FILE    *fd;
+@@ -835,7 +901,7 @@
+     if ((op->flags & F_ISSUE) && (fd = fopen(op->issue, "r"))) {
+ 	oflag = tp->c_oflag;			/* save current setting */
+ 	tp->c_oflag |= (ONLCR | OPOST);		/* map NL in output to CR-NL */
+-	(void) ioctl(0, TCSETAW, tp);
++	(void) tcsetattr(0, TCSADRAIN, tp);
+ 
+ 
+ 	while ((c = getc(fd)) != EOF)
+@@ -915,7 +981,7 @@
+ 			int i;
+ 
+ 			for (i = 0; speedtab[i].speed; i++) {
+-			    if (speedtab[i].code == (tp->c_cflag & CBAUD)) {
++			    if (speedtab[i].code == cfgetospeed(tp)) {
+ 				printf("%ld", speedtab[i].speed);
+ 				break;
+ 			    }
+@@ -947,7 +1013,7 @@
+ 	fflush(stdout);
+ 
+ 	tp->c_oflag = oflag;			/* restore settings */
+-	(void) ioctl(0, TCSETAW, tp);		/* wait till output is gone */
++	(void) tcsetattr(0, TCSADRAIN, tp);	/* wait till output is gone */
+ 	(void) fclose(fd);
+     }
+ #endif
+@@ -965,15 +1031,14 @@
+ /* next_speed - select next baud rate */
+ void
+ next_speed(tp, op)
+-     struct termio *tp;
++     struct termios *tp;
+      struct options *op;
+ {
+     static int baud_index = FIRST_SPEED;/* current speed index */
+ 
+     baud_index = (baud_index + 1) % op->numspeed;
+-    tp->c_cflag &= ~CBAUD;
+-    tp->c_cflag |= op->speeds[baud_index];
+-    (void) ioctl(0, TCSETA, tp);
++    (void) cfsetospeed(0, op->speeds[baud_index]);
++    (void) tcsetattr(0, TCSANOW, tp);
+ }
+ 
+ /* get_logname - get user name, establish parity, speed, erase, kill, eol */
+@@ -981,7 +1046,7 @@
+ char   *get_logname(op, cp, tp)
+      struct options *op;
+      struct chardata *cp;
+-     struct termio *tp;
++     struct termios *tp;
+ {
+     static char logname[BUFSIZ];
+     char   *bp;
+@@ -1003,7 +1068,7 @@
+     /* Flush pending input (esp. after parsing or switching the baud rate). */
+ 
+     (void) sleep(1);
+-    (void) ioctl(0, TCFLSH, TCIFLUSH);
++    (void) tcflush(0, TCIFLUSH);
+ 
+     /* Prompt for and read a login name. */
+ 
+@@ -1087,11 +1152,11 @@
+     return (logname);
+ }
+ 
+-/* termio_final - set the final tty mode bits */
++/* termios_final - set the final tty mode bits */
+ void
+-termio_final(op, tp, cp)
++termios_final(op, tp, cp)
+      struct options *op;
+-     struct termio *tp;
++     struct termios *tp;
+      struct chardata *cp;
+ {
+     /* General terminal-independent stuff. */
+@@ -1107,7 +1172,7 @@
+     tp->c_cc[VEOL] = DEF_EOL;
+ #ifdef __linux__
+     tp->c_cc[VSWTC] = DEF_SWITCH;		/* default switch character */
+-#else
++#elif defined(VSWTCH)
+     tp->c_cc[VSWTCH] = DEF_SWITCH;		/* default switch character */
+ #endif
+ 
+@@ -1139,11 +1204,13 @@
+     }
+     /* Account for upper case without lower case. */
+ 
++#if defined(IUCLC) && defined(XCASE) && defined(OLCUC)
+     if (cp->capslock) {
+ 	tp->c_iflag |= IUCLC;
+ 	tp->c_lflag |= XCASE;
+ 	tp->c_oflag |= OLCUC;
+     }
++#endif
+     /* Optionally enable hardware flow control */
+ 
+ #ifdef	CRTSCTS
+@@ -1153,8 +1220,8 @@
+ 
+     /* Finally, make the new settings effective */
+ 
+-    if (ioctl(0, TCSETA, tp) < 0)
+-	error("%s: ioctl: TCSETA: %m", op->tty);
++    if (tcsetattr(0, TCSADRAIN, tp) < 0)
++	error("%s: tcsetattr: %m", op->tty);
+ }
+ 
+ /* caps_lock - string contains upper case without lower case */
+diff -urNad util-linux/disk-utils/Makefile /tmp/dpep.Eu8Nvo/util-linux/disk-utils/Makefile
+--- util-linux/disk-utils/Makefile	2004-12-15 10:41:00.757980700 -0700
++++ /tmp/dpep.Eu8Nvo/util-linux/disk-utils/Makefile	2004-12-15 11:00:55.733111453 -0700
+@@ -50,6 +50,8 @@
+ 
+ fsck.minix.o mkfs.minix.o: bitops.h minix.h
+ 
++mkfs.minix mkfs.bfs mkswap: $(LIB)/get_blocks.o
++
+ install: all
+ 	$(INSTALLDIR) $(SBINDIR) $(USRBINDIR) $(ETCDIR)
+ 	$(INSTALLBIN) $(SBIN) $(SBINDIR)
+diff -urNad util-linux/disk-utils/mkfs.bfs.c /tmp/dpep.Eu8Nvo/util-linux/disk-utils/mkfs.bfs.c
+--- util-linux/disk-utils/mkfs.bfs.c	2004-12-15 10:41:00.758980485 -0700
++++ /tmp/dpep.Eu8Nvo/util-linux/disk-utils/mkfs.bfs.c	2004-12-15 11:00:55.733111453 -0700
+@@ -10,17 +10,12 @@
+ #include <stdarg.h>
+ #include <sys/types.h>
+ #include <sys/stat.h>
+-#include <sys/ioctl.h>
+ #include <fcntl.h>
+ #include <errno.h>
+ #include <string.h>
+ #include <time.h>
+ #include "nls.h"
+-
+-/* cannot include <linux/fs.h> */
+-#ifndef BLKGETSIZE
+-#define BLKGETSIZE _IO(0x12,96)    /* return device size */
+-#endif
++#include "get_blocks.h"
+ 
+ #define BFS_ROOT_INO		2
+ #define BFS_NAMELEN		14
+@@ -181,13 +176,9 @@
+ 	else if (optind != argc)
+ 		usage();
+ 
+-	if (ioctl(fd, BLKGETSIZE, &total_blocks) == -1) {
+-		if (!user_specified_total_blocks) {
+-			perror("BLKGETSIZE");
+-			fatal(_("cannot get size of %s"), device);
+-		}
+-		total_blocks = user_specified_total_blocks;
+-	} else if (user_specified_total_blocks) {
++	total_blocks = get_blocks(fd);
++
++	if (user_specified_total_blocks) {
+ 		if (user_specified_total_blocks > total_blocks)
+ 			fatal(_("blocks argument too large, max is %lu"),
+ 			      total_blocks);
+diff -urNad util-linux/disk-utils/mkfs.minix.c /tmp/dpep.Eu8Nvo/util-linux/disk-utils/mkfs.minix.c
+--- util-linux/disk-utils/mkfs.minix.c	2004-12-15 10:41:00.758980485 -0700
++++ /tmp/dpep.Eu8Nvo/util-linux/disk-utils/mkfs.minix.c	2004-12-15 11:00:55.734111238 -0700
+@@ -68,16 +68,12 @@
+ #include <stdlib.h>
+ #include <termios.h>
+ #include <sys/stat.h>
+-#include <sys/ioctl.h>
+ #include <mntent.h>
+ #include <getopt.h>
+ 
+ #include "minix.h"
+ #include "nls.h"
+-
+-#ifndef BLKGETSIZE
+-#define BLKGETSIZE _IO(0x12,96)    /* return device size */
+-#endif
++#include "get_blocks.h"
+ 
+ #ifndef __GNUC__
+ #error "needs gcc for the bitop-__asm__'s"
+@@ -188,37 +184,6 @@
+ }
+ 
+ static long
+-valid_offset (int fd, int offset) {
+-	char ch;
+-
+-	if (lseek (fd, offset, 0) < 0)
+-		return 0;
+-	if (read (fd, &ch, 1) < 1)
+-		return 0;
+-	return 1;
+-}
+-
+-static int
+-count_blocks (int fd) {
+-	int high, low;
+-
+-	low = 0;
+-	for (high = 1; valid_offset (fd, high); high *= 2)
+-		low = high;
+-	while (low < high - 1)
+-	{
+-		const int mid = (low + high) / 2;
+-
+-		if (valid_offset (fd, mid))
+-			low = mid;
+-		else
+-			high = mid;
+-	}
+-	valid_offset (fd, 0);
+-	return (low + 1);
+-}
+-
+-static int
+ get_size(const char  *file) {
+ 	int	fd;
+ 	long	size;
+@@ -228,12 +193,8 @@
+ 		perror(file);
+ 		exit(1);
+ 	}
+-	if (ioctl(fd, BLKGETSIZE, &size) >= 0) {
+-		close(fd);
+-		return (size * 512);
+-	}
+-		
+-	size = count_blocks(fd);
++	size = get_blocks(fd);
++
+ 	close(fd);
+ 	return size;
+ }
+@@ -676,8 +637,10 @@
+      }
+   }
+ 
+-  if (device_name && !BLOCKS)
+-    BLOCKS = get_size (device_name) / 1024;
++  if (device_name && !BLOCKS) {
++    int sectors_per_block = 1024 / 512;
++    BLOCKS = get_size (device_name) / sectors_per_block;
++  }
+   if (!device_name || BLOCKS<10) {
+     usage();
+   }
+diff -urNad util-linux/disk-utils/mkswap.c /tmp/dpep.Eu8Nvo/util-linux/disk-utils/mkswap.c
+--- util-linux/disk-utils/mkswap.c	2004-12-15 10:41:00.760980055 -0700
++++ /tmp/dpep.Eu8Nvo/util-linux/disk-utils/mkswap.c	2004-12-15 11:00:55.734111238 -0700
+@@ -36,10 +36,10 @@
+ #include <string.h>
+ #include <fcntl.h>
+ #include <stdlib.h>
+-#include <sys/ioctl.h>		/* for _IO */
+ #include <sys/utsname.h>
+ #include <sys/stat.h>
+ #include "nls.h"
++#include "get_blocks.h"
+ 
+ /* Try to get PAGE_SIZE from libc or kernel includes */
+ #ifdef HAVE_sys_user_h
+@@ -52,14 +52,6 @@
+ #endif
+ #endif
+ 
+-#ifndef _IO
+-/* pre-1.3.45 */
+-#define BLKGETSIZE 0x1260
+-#else
+-/* same on i386, m68k, arm; different on alpha, mips, sparc, ppc */
+-#define BLKGETSIZE _IO(0x12,96)
+-#endif
+-
+ static char * program_name = "mkswap";
+ static char * device_name = NULL;
+ static int DEV = -1;
+@@ -382,39 +374,11 @@
+ 		printf(_("%lu bad pages\n"), badpages);
+ }
+ 
+-static long
+-valid_offset (int fd, off_t offset) {
+-	char ch;
+-
+-	if (lseek (fd, offset, 0) < 0)
+-		return 0;
+-	if (read (fd, &ch, 1) < 1)
+-		return 0;
+-	return 1;
+-}
+-
+-static off_t
+-find_size (int fd) {
+-	off_t high, low;
+-
+-	low = 0;
+-	for (high = 1; high > 0 && valid_offset (fd, high); high *= 2)
+-		low = high;
+-	while (low < high - 1) {
+-		const off_t mid = (low + high) / 2;
+-
+-		if (valid_offset (fd, mid))
+-			low = mid;
+-		else
+-			high = mid;
+-	}
+-	return (low + 1);
+-}
+-
+ /* return size in pages, to avoid integer overflow */
+ static unsigned long
+ get_size(const char  *file) {
+ 	int	fd;
++	int	sectors_per_page = pagesize / 512;
+ 	unsigned long	size;
+ 
+ 	fd = open(file, O_RDONLY);
+@@ -422,14 +386,10 @@
+ 		perror(file);
+ 		exit(1);
+ 	}
+-	if (ioctl(fd, BLKGETSIZE, &size) >= 0) {
+-		int sectors_per_page = pagesize/512;
+-		size /= sectors_per_page;
+-	} else {
+-		size = find_size(fd) / pagesize;
+-	}
++	size = get_blocks(fd);
++
+ 	close(fd);
+-	return size;
++	return (size / sectors_per_page);
+ }
+ 
+ static int
+@@ -554,8 +514,11 @@
+ 		maxpages = PAGES;
+ 	else if (linux_version_code() >= MAKE_VERSION(2,2,1))
+ 		maxpages = V1_MAX_PAGES;
+-	else
++	else {
+ 		maxpages = V1_OLD_MAX_PAGES;
++		if (maxpages > V1_MAX_PAGES)
++			maxpages = V1_MAX_PAGES;
++	}
+ 
+ 	if (PAGES > maxpages) {
+ 		PAGES = maxpages;
+diff -urNad util-linux/fdisk/cfdisk.c /tmp/dpep.Eu8Nvo/util-linux/fdisk/cfdisk.c
+--- util-linux/fdisk/cfdisk.c	2004-12-15 10:41:00.762979625 -0700
++++ /tmp/dpep.Eu8Nvo/util-linux/fdisk/cfdisk.c	2004-12-15 11:00:55.735111023 -0700
+@@ -80,6 +80,7 @@
+ 
+ #include "nls.h"
+ #include "xstrncpy.h"
++#include "get_blocks.h"
+ #include "common.h"
+ 
+ extern long long ext2_llseek(unsigned int fd, long long offset,
+diff -urNad util-linux/fdisk/fdisk.c /tmp/dpep.Eu8Nvo/util-linux/fdisk/fdisk.c
+--- util-linux/fdisk/fdisk.c	2004-12-15 10:41:00.764979195 -0700
++++ /tmp/dpep.Eu8Nvo/util-linux/fdisk/fdisk.c	2004-12-15 11:00:55.736110808 -0700
+@@ -21,6 +21,7 @@
+ 
+ #include "nls.h"
+ #include "common.h"
++#include "get_blocks.h"
+ #include "fdisk.h"
+ 
+ #include "fdisksunlabel.h"
+diff -urNad util-linux/fdisk/sfdisk.c /tmp/dpep.Eu8Nvo/util-linux/fdisk/sfdisk.c
+--- util-linux/fdisk/sfdisk.c	2004-12-15 10:41:00.765978980 -0700
++++ /tmp/dpep.Eu8Nvo/util-linux/fdisk/sfdisk.c	2004-12-15 11:00:55.738110378 -0700
+@@ -51,6 +51,7 @@
+ #include <linux/unistd.h>	/* _syscall */
+ #include "nls.h"
+ #include "common.h"
++#include "get_blocks.h"
+ 
+ #define SIZE(a)	(sizeof(a)/sizeof(a[0]))
+ 
+diff -urNad util-linux/lib/Makefile /tmp/dpep.Eu8Nvo/util-linux/lib/Makefile
+--- util-linux/lib/Makefile	2004-12-15 10:41:00.766978765 -0700
++++ /tmp/dpep.Eu8Nvo/util-linux/lib/Makefile	2004-12-15 11:00:55.738110378 -0700
+@@ -9,6 +9,8 @@
+ 
+ env.o: env.h
+ 
++get_blocks.o: get_blocks.h
++
+ setproctitle.o: setproctitle.h
+ 
+ carefulputc.o: carefulputc.h
+diff -urNad util-linux/lib/get_blocks.c /tmp/dpep.Eu8Nvo/util-linux/lib/get_blocks.c
+--- util-linux/lib/get_blocks.c	1969-12-31 17:00:00.000000000 -0700
++++ /tmp/dpep.Eu8Nvo/util-linux/lib/get_blocks.c	2004-12-15 11:00:55.738110378 -0700
+@@ -0,0 +1,117 @@
++/*
++ * unsigned long get_blocks(int fd)
++ *
++ * 	returns the number of 512-byte blocks of fd
++ *
++ * Most code ripped from:
++ * 
++ * 	mkswap.c
++ * 	mkfs.bfs.c
++ * 	mkfs.minix.c
++ *
++ * by Guillem Jover <guillem.jover@menta.net>
++ * 
++ */
++
++#include "../defines.h"
++#include "get_blocks.h"
++#include <sys/types.h>
++#include <sys/stat.h>
++#include <unistd.h>
++
++#include <sys/ioctl.h>
++
++/* can't #include <linux/fs.h>, because it uses u64... */
++#ifndef BLKGETSIZE
++/* return device size */
++#ifndef _IO
++/* pre-1.3.45 */
++#define BLKGETSIZE 0x1260
++#else
++/* same on i386, m68k, arm; different on alpha, mips, sparc, ppc */
++#define BLKGETSIZE _IO(0x12,96)
++#define BLKGETSIZE64 _IOR(0x12,114,long long)
++#endif
++#endif
++
++static int
++valid_offset (int fd, off_t offset)
++{
++	char	ch;
++
++	if (lseek (fd, offset, 0) < 0)
++		return 0;
++	if (read (fd, &ch, 1) < 1)
++		return 0;
++	return 1;
++}
++
++static off_t 
++count_blocks (int fd)
++{
++	off_t	high, low, blocks;
++
++	low = 0;
++	for (high = 1; high > 0 && valid_offset (fd, high); high *= 2)
++		low = high;
++	while (low < high - 1)
++	{
++		const off_t	mid = (low + high) / 2;
++
++		if (valid_offset (fd, mid))
++			low = mid;
++		else
++			high = mid;
++	}
++	blocks = (low + 1) / 512;
++	return blocks;
++}
++
++unsigned long
++get_blocks (int fd)
++{
++	struct stat	st;
++
++	{
++		unsigned long longsectors;
++		unsigned long long bytes;	/* really u64 */
++		unsigned long long total_number_of_sectors;
++
++		/* stat fd to see if it is a regular file or a block device */
++		if ( fstat(fd, &st) != 0 )
++			return 0;
++			
++		/* fd is a regular file */
++		if (S_ISREG(st.st_mode)) 
++		{
++			bytes = st.st_size;
++		}
++		/* fd is a block device */
++		else if (S_ISBLK(st.st_mode))
++		{
++			if (ioctl(fd, BLKGETSIZE, &longsectors))
++				longsectors = 0;
++			if (ioctl(fd, BLKGETSIZE64, &bytes))
++				bytes = 0;
++
++			/*
++			 * If BLKGETSIZE64 was unknown or broken, use longsectors.
++			 * (Kernels 2.4.15-2.4.17 had a broken BLKGETSIZE64
++			 * that returns sectors instead of bytes.)
++			 */
++			if (bytes == 0 || bytes == longsectors)
++				bytes = ((unsigned long long) longsectors) << 9;
++		}
++		else /* fd is neither a regalar file nor a block device */
++			return 0;
++
++		total_number_of_sectors = (bytes >> 9);
++		return total_number_of_sectors;
++	}
++
++	if (fstat(fd, &st) == 0)
++		return st.st_size / 512;
++
++	return count_blocks(fd);
++}
++
+diff -urNad util-linux/lib/get_blocks.h /tmp/dpep.Eu8Nvo/util-linux/lib/get_blocks.h
+--- util-linux/lib/get_blocks.h	1969-12-31 17:00:00.000000000 -0700
++++ /tmp/dpep.Eu8Nvo/util-linux/lib/get_blocks.h	2004-12-15 11:00:55.738110378 -0700
+@@ -0,0 +1,7 @@
++#ifndef GET_BLOCKS_H
++#define GET_BLOCKS_H
++
++extern unsigned long get_blocks (int fd);
++
++#endif
++
+diff -urNad util-linux/disk-utils/mkfs.c /tmp/dpep.q8UfTz/util-linux/disk-utils/mkfs.c
+--- util-linux/disk-utils/mkfs.c	2004-09-06 11:06:21.000000000 -0600
++++ /tmp/dpep.q8UfTz/util-linux/disk-utils/mkfs.c	2004-12-15 07:34:37.480762459 -0700
+@@ -36,7 +36,7 @@
+ 
+ int main(int argc, char *argv[])
+ {
+-  char progname[NAME_MAX];
++  char *progname;
+   char *fstype = NULL;
+   int i, more = 0, verbose = 0;
+   char *oldpath, *newpath;
+@@ -92,7 +92,12 @@
+   }
+   sprintf(newpath, "%s:%s\n", SEARCH_PATH, oldpath);
+   putenv(newpath);
+-  snprintf(progname, sizeof(progname), PROGNAME, fstype);
++  progname = (char *) malloc(sizeof(PROGNAME) + strlen(fstype) + 1);
++  if (!progname) {
++    fprintf(stderr, _("%s: Out of memory!\n"), "mkfs");
++    exit(1);
++  }
++  sprintf(progname, PROGNAME, fstype);
+   argv[--optind] = progname;
+ 
+   if (verbose) {
+diff -urNad util-linux/misc-utils/namei.c /tmp/dpep.q8UfTz/util-linux/misc-utils/namei.c
+--- util-linux/misc-utils/namei.c	2004-09-06 15:06:47.000000000 -0600
++++ /tmp/dpep.q8UfTz/util-linux/misc-utils/namei.c	2004-12-15 07:34:15.484428834 -0700
+@@ -73,7 +73,8 @@
+ main(int argc, char **argv) {
+     extern int optind;
+     int c;
+-    char curdir[MAXPATHLEN];
++    int curdir_size;
++    char *curdir;
+ 
+     setlocale(LC_ALL, "");
+     bindtextdomain(PACKAGE, LOCALEDIR);
+@@ -98,13 +99,28 @@
+ 	}
+     }
+ 
+-    if(getcwd(curdir, sizeof(curdir)) == NULL){
+-	(void)fprintf(stderr,
+-		      _("namei: unable to get current directory - %s\n"),
+-		      curdir);
++    curdir_size = 1024;
++    curdir = malloc(curdir_size);
++    if (curdir==NULL){
++	(void)fprintf(stderr, _("namei: out of memory\n"));
+ 	exit(1);
+     }
+ 
++    while (getcwd(curdir, curdir_size) == NULL){
++	if (errno!=ERANGE){
++	    (void)fprintf(stderr,
++			  _("namei: unable to get current directory - %s\n"),
++			  curdir);
++	    exit(1);
++	}
++	curdir_size *= 2;
++	realloc(curdir, curdir_size);
++	if (curdir==NULL){
++	    (void)fprintf(stderr, _("namei: out of memory\n"));
++	    exit(1);
++	}
++    }
++
+ 
+     for(; optind < argc; optind++){
+ 	(void)printf("f: %s\n", argv[optind]);
+diff -urNad util-linux/fdisk/fdiskbsdlabel.c /tmp/dpep.lVXZel/util-linux/fdisk/fdiskbsdlabel.c
+--- util-linux/fdisk/fdiskbsdlabel.c	2003-07-13 15:12:47.000000000 -0600
++++ /tmp/dpep.lVXZel/util-linux/fdisk/fdiskbsdlabel.c	2004-12-15 08:26:47.880009777 -0700
+@@ -515,7 +514,7 @@
+ xbsd_write_bootstrap (void)
+ {
+   char *bootdir = BSD_LINUX_BOOTDIR;
+-  char path[MAXPATHLEN];
++  char *path;
+   char *dkbasename;
+   struct xbsd_disklabel dl;
+   char *d, *p, *e;
+@@ -532,9 +531,15 @@
+     line_ptr[strlen (line_ptr)-1] = '\0';
+     dkbasename = line_ptr;
+   }
+-  snprintf (path, sizeof(path), "%s/%sboot", bootdir, dkbasename);
+-  if (!xbsd_get_bootstrap (path, disklabelbuffer, (int) xbsd_dlabel.d_secsize))
++  path = (char *) malloc (sizeof("/boot") + 1 + strlen (bootdir) +
++			  strlen (dkbasename));
++  if (!path)
++    fatal (out_of_memory);
++  sprintf (path, "%s/%sboot", bootdir, dkbasename);
++  if (!xbsd_get_bootstrap (path, disklabelbuffer, (int) xbsd_dlabel.d_secsize)) {
++    free (path);
+     return;
++  }
+ 
+   /* We need a backup of the disklabel (xbsd_dlabel might have changed). */
+   d = &disklabelbuffer[BSD_LABELSECTOR * SECTOR_SIZE];
+@@ -543,10 +548,13 @@
+   /* The disklabel will be overwritten by 0's from bootxx anyway */
+   bzero (d, sizeof (struct xbsd_disklabel));
+ 
++  sprintf (path, "%s/boot%s", bootdir, dkbasename);
+   snprintf (path, sizeof(path), "%s/boot%s", bootdir, dkbasename);
+   if (!xbsd_get_bootstrap (path, &disklabelbuffer[xbsd_dlabel.d_secsize],
+-			  (int) xbsd_dlabel.d_bbsize - xbsd_dlabel.d_secsize))
++			  (int) xbsd_dlabel.d_bbsize - xbsd_dlabel.d_secsize)) {
++    free(path);
+     return;
++  }
+ 
+   e = d + sizeof (struct xbsd_disklabel);
+   for (p=d; p < e; p++)
+@@ -579,6 +587,8 @@
+ #endif
+ 
+   sync_disks ();
++
++  free(path);
+ }
+ 
+ static void
+diff -urNad util-linux/MCONFIG /tmp/dpep.lVXZel/util-linux/MCONFIG
+--- util-linux/MCONFIG	2004-12-15 08:26:36.601434195 -0700
++++ /tmp/dpep.lVXZel/util-linux/MCONFIG	2004-12-15 08:26:47.875010852 -0700
+@@ -17,7 +17,8 @@
+ # Select for CPU i386 if the binaries must be able to run on an intel 386
+ # (by default i486 code is generated, see below)
+ CPU=$(shell uname -m)
+-ARCH=$(shell echo $(CPU) | sed 's/i.86/intel/;s/arm.*/arm/')
++ARCH=$(shell echo $(CPU) | sed 's/i.86.*/intel/;s/arm.*/arm/')
++OS=$(shell uname -s | tr '[:upper:]' '[:lower:]')
+ 
+ # If HAVE_PAM is set to "yes", then login, chfn, chsh, and newgrp
+ # will use PAM for authentication. Additionally, passwd will not be
+diff -urNad util-linux/configure /tmp/dpep.lVXZel/util-linux/configure
+--- util-linux/configure	2004-12-12 12:36:03.000000000 -0700
++++ /tmp/dpep.lVXZel/util-linux/configure	2004-12-15 08:26:47.875010852 -0700
+@@ -304,6 +304,7 @@
+ 
+ #
+ # F6. For agetty.c: is updwtmp() available?
++# F7. For mcookie.c: is gettimeofday() available?
+ #
+ echo '
+ #include <string.h>
+@@ -504,7 +505,7 @@
+ #include <libintl.h>
+ int main(int a, char **v){
+   if (a == -1)  /* false */
+-        gettext("There is no gettext man page\n");
++        gettext("There is no gettext man page");
+   exit(0);
+ }
+ ' > conftest.c
+@@ -520,6 +521,28 @@
+ fi
+ rm -f conftest conftest.c
+ 
++#
++# F7. For mcookie.c: is gettimeofday() available?
++#
++echo '
++#include <sys/time.h>
++#include <unistd.h>
++main(int a, char **v){
++  struct timeval    tv;
++  struct timezone   tz;
++  gettimeofday( &tv, &tz );
++  exit(0);
++}
++' > conftest.c
++eval $compile
++if test -s conftest && ./conftest 2>/dev/null; then
++        echo "#define HAVE_gettimeofday" >> defines.h
++        echo "You have gettimeofday()"
++else
++        echo "You don't have gettimeofday()"
++fi
++rm -f conftest conftest.c
++
+ 
+ #
+ # 7. Does xgettext exist and take the option --foreign-user?
+diff -urNad util-linux/disk-utils/Makefile /tmp/dpep.lVXZel/util-linux/disk-utils/Makefile
+--- util-linux/disk-utils/Makefile	2004-12-15 08:26:36.633427318 -0700
++++ /tmp/dpep.lVXZel/util-linux/disk-utils/Makefile	2004-12-15 08:26:47.876010637 -0700
+@@ -8,24 +8,34 @@
+ 
+ # Where to put man pages?
+ 
+-MAN8= 	blockdev.8 fdformat.8 isosize.8 mkfs.8 mkswap.8 elvtune.8 \
+-	fsck.minix.8 mkfs.minix.8 mkfs.bfs.8
++MAN8= 	isosize.8 mkfs.8 mkswap.8 fsck.minix.8 mkfs.minix.8 mkfs.bfs.8
++ifeq "$(OS)" "linux"
++MAN8:=$(MAN8) fdformat.8 blockdev.8 elvtune.8
++endif
+ 
+ # Where to put binaries?
+ # See the "install" rule for the links. . .
+ 
+-SBIN= 	mkfs mkswap blockdev elvtune fsck.minix mkfs.minix mkfs.bfs
++SBIN= 	mkfs mkswap fsck.minix mkfs.minix mkfs.bfs
++ifeq "$(OS)" "linux"
++SBIN:=$(SBIN) blockdev elvtune
++endif
+ 
+-USRBIN=	fdformat isosize
++USRBIN=	isosize
++ifeq "$(OS)" "linux"
++USRBIN:=$(USRBIN) fdformat
++endif
+ 
+ ETC=	fdprm
+ 
+ MAYBE=  setfdprm raw fsck.cramfs mkfs.cramfs
+ 
++ifeq "$(OS)" "linux"
+ ifneq "$(HAVE_FDUTILS)" "yes"
+ USRBIN:=$(USRBIN) setfdprm
+ MAN8:=$(MAN8) setfdprm.8
+ endif
++endif
+ 
+ ifeq "$(HAVE_RAW_H)" "yes"
+ USRBIN:=$(USRBIN) raw
+@@ -56,9 +66,11 @@
+ 	$(INSTALLDIR) $(SBINDIR) $(USRBINDIR) $(ETCDIR)
+ 	$(INSTALLBIN) $(SBIN) $(SBINDIR)
+ 	$(INSTALLBIN) $(USRBIN) $(USRBINDIR)
++ifeq "$(OS)" "linux"
+ ifneq "$(HAVE_FDUTILS)" "yes"
+ 	$(INSTALLDAT) $(ETC) $(ETCDIR)
+ endif
++endif
+ 	$(INSTALLDIR) $(MAN8DIR)
+ 	$(INSTALLMAN) $(MAN8) $(MAN8DIR)
+ 
+diff -urNad util-linux/disk-utils/mkswap.c /tmp/dpep.lVXZel/util-linux/disk-utils/mkswap.c
+--- util-linux/disk-utils/mkswap.c	2004-12-15 08:26:36.635426888 -0700
++++ /tmp/dpep.lVXZel/util-linux/disk-utils/mkswap.c	2004-12-15 08:26:47.876010637 -0700
+@@ -36,7 +36,9 @@
+ #include <string.h>
+ #include <fcntl.h>
+ #include <stdlib.h>
++#ifdef __linux__
+ #include <sys/utsname.h>
++#endif /* __linux__ */
+ #include <sys/stat.h>
+ #include "nls.h"
+ #include "get_blocks.h"
+@@ -60,6 +62,7 @@
+ static int check = 0;
+ static int version = -1;
+ 
++#ifdef __linux__
+ #define MAKE_VERSION(p,q,r)	(65536*(p) + 256*(q) + (r))
+ 
+ static int
+@@ -75,6 +78,7 @@
+ 	}
+ 	return 0;
+ }
++#endif /* __linux__ */
+ 
+ #ifdef __sparc__
+ # ifdef __arch64__
+@@ -488,8 +492,10 @@
+ 		/* use version 1 as default, if possible */
+ 		if (PAGES <= V0_MAX_PAGES && PAGES > V1_MAX_PAGES)
+ 			version = 0;
++#ifdef __linux__
+ 		else if (linux_version_code() < MAKE_VERSION(2,1,117))
+ 			version = 0;
++#endif
+ 		else if (pagesize < 2048)
+ 			version = 0;
+ 		else
+@@ -510,10 +516,12 @@
+ 
+ 	if (version == 0)
+ 		maxpages = V0_MAX_PAGES;
++#ifdef __linux__
+ 	else if (linux_version_code() >= MAKE_VERSION(2,3,4))
+ 		maxpages = PAGES;
+ 	else if (linux_version_code() >= MAKE_VERSION(2,2,1))
+ 		maxpages = V1_MAX_PAGES;
++#endif
+ 	else {
+ 		maxpages = V1_OLD_MAX_PAGES;
+ 		if (maxpages > V1_MAX_PAGES)
+diff -urNad util-linux/fdisk/cfdisk.c /tmp/dpep.lVXZel/util-linux/fdisk/cfdisk.c
+--- util-linux/fdisk/cfdisk.c	2004-12-15 08:26:36.636426673 -0700
++++ /tmp/dpep.lVXZel/util-linux/fdisk/cfdisk.c	2004-12-15 08:26:47.878010207 -0700
+@@ -75,8 +75,10 @@
+ #include <math.h>
+ #include <string.h>
+ #include <sys/stat.h>
++#ifdef __linux__
+ #include <sys/ioctl.h>
+ #include <linux/types.h>
++#endif
+ 
+ #include "nls.h"
+ #include "xstrncpy.h"
+@@ -88,8 +90,16 @@
+ 
+ #define VERSION UTIL_LINUX_VERSION
+ 
++#ifdef __GNU__
++#define DEFAULT_DEVICE "/dev/hd0"
++#define ALTERNATE_DEVICE "/dev/sd0"
++#elif defined(__FreeBSD__)
++#define DEFAULT_DEVICE "/dev/ad0"
++#define ALTERNATE_DEVICE "/dev/da0"
++#else
+ #define DEFAULT_DEVICE "/dev/hda"
+ #define ALTERNATE_DEVICE "/dev/sda"
++#endif
+ 
+ /* With K=1024 we have `binary' megabytes, gigabytes, etc.
+    Some misguided hackers like that.
+@@ -1616,6 +1626,7 @@
+ 	 opentype = O_RDWR;
+     opened = TRUE;
+ 
++#ifdef __linux__
+     /* Blocks are visible in more than one way:
+        e.g. as block on /dev/hda and as block on /dev/hda3
+        By a bug in the Linux buffer cache, we will see the old
+@@ -1625,6 +1636,7 @@
+        so this only plays a role if we want to show volume labels. */
+     ioctl(fd, BLKFLSBUF);	/* ignore errors */
+ 				/* e.g. Permission Denied */
++#endif
+ 
+     if (disksize(fd, &llsectors))
+ 	    fatal(_("Cannot get disk size"), 3);
+@@ -1834,12 +1846,14 @@
+ 	}
+ 
+     if (is_bdev) {
++#ifdef __linux__
+ 	 sync();
+ 	 sleep(2);
+ 	 if (!ioctl(fd,BLKRRPART))
+ 	      changed = TRUE;
+ 	 sync();
+ 	 sleep(4);
++#endif
+ 
+ 	 clear_warning();
+ 	 if (changed)
+@@ -2936,6 +2950,19 @@
+ 	disk_device = ALTERNATE_DEVICE;
+     else close(fd);
+ 
++#ifndef __linux__
++    /* XXX Temporal hack to force user or partition table to supply
++     * what the system cannot
++     */
++    if (!use_partition_table_geometry
++	&& (!user_cylinders || !user_heads || !user_sectors)) {
++	fprintf(stderr, "%s: %s\n", argv[0],
++		_("Geometry must be supplied, by the user (-c -h -s) or\n"
++		  "by the existing partition table (-g)\n"));
++    	exit(1);
++    }
++#endif
++
+     if (print_only) {
+ 	fill_p_info();
+ 	if (print_only & PRINT_RAW_TABLE)
+diff -urNad util-linux/fdisk/fdisk.c /tmp/dpep.lVXZel/util-linux/fdisk/fdisk.c
+--- util-linux/fdisk/fdisk.c	2004-12-15 08:26:36.638426243 -0700
++++ /tmp/dpep.lVXZel/util-linux/fdisk/fdisk.c	2004-12-15 08:26:47.879009992 -0700
+@@ -734,6 +734,7 @@
+ 	get_boot(create_empty_dos);
+ }
+ 
++#ifdef __linux__
+ #include <sys/utsname.h>
+ #define MAKE_VERSION(p,q,r)     (65536*(p) + 256*(q) + (r))
+ 
+@@ -751,10 +752,11 @@
+         }
+         return kernel_version;
+ }
++#endif
+ 
+ static void
+ get_sectorsize(int fd) {
+-#if defined(BLKSSZGET)
++#if defined(BLKSSZGET) && defined(__linux__)
+ 	if (!user_set_sector_size &&
+ 	    linux_version_code() >= MAKE_VERSION(2,3,3)) {
+ 		int arg;
+@@ -2160,6 +2162,7 @@
+ 	int error = 0;
+ 	int i;
+ 
++#ifdef __linux__
+ 	printf(_("Calling ioctl() to re-read partition table.\n"));
+ 	sync();
+ 	sleep(2);
+@@ -2174,6 +2177,10 @@
+                 if ((i = ioctl(fd, BLKRRPART)) != 0)
+                         error = errno;
+         }
++#else
++	error = ENOSYS;
++	i = 1;
++#endif
+ 
+ 	if (i) {
+ 		printf(_("\nWARNING: Re-reading the partition table "
+diff -urNad util-linux/fdisk/fdiskaixlabel.h /tmp/dpep.lVXZel/util-linux/fdisk/fdiskaixlabel.h
+--- util-linux/fdisk/fdiskaixlabel.h	2003-07-13 08:10:55.000000000 -0600
++++ /tmp/dpep.lVXZel/util-linux/fdisk/fdiskaixlabel.h	2004-12-15 08:26:47.879009992 -0700
+@@ -1,4 +1,3 @@
+-#include <linux/types.h>   /* for __u32 etc */
+ /*
+  * Copyright (C) Andreas Neuper, Sep 1998.
+  *	This file may be redistributed under
+diff -urNad util-linux/fdisk/fdiskbsdlabel.c /tmp/dpep.Eu8Nvo/util-linux/fdisk/fdiskbsdlabel.c
+--- util-linux/fdisk/fdiskbsdlabel.c	2004-12-15 08:32:52.962532435 -0700
++++ /tmp/dpep.Eu8Nvo/util-linux/fdisk/fdiskbsdlabel.c	2004-12-15 11:01:49.655520409 -0700
+@@ -52,7 +52,6 @@
+ #include <errno.h>
+ #include "nls.h"
+ 
+-#include <sys/ioctl.h>
+ #include <sys/param.h>
+ 
+ #include "common.h"
+diff -urNad util-linux/fdisk/fdiskbsdlabel.h /tmp/dpep.lVXZel/util-linux/fdisk/fdiskbsdlabel.h
+--- util-linux/fdisk/fdiskbsdlabel.h	2002-10-31 06:45:34.000000000 -0700
++++ /tmp/dpep.lVXZel/util-linux/fdisk/fdiskbsdlabel.h	2004-12-15 08:26:47.881009562 -0700
+@@ -31,10 +31,10 @@
+  * SUCH DAMAGE.
+  */
+ 
+-#include <linux/types.h>	/* for __u32, __u16, __u8, __s16 */
++#include <stdint.h>	/* for uint32_t, uint16_t, uint8_t, int16_t */
+ 
+ #ifndef BSD_DISKMAGIC
+-#define BSD_DISKMAGIC     ((__u32) 0x82564557)
++#define BSD_DISKMAGIC     ((uint32_t) 0x82564557)
+ #endif
+ 
+ #ifndef BSD_MAXPARTITIONS
+@@ -60,31 +60,31 @@
+ #define	BSD_SBSIZE        8192		/* max size of fs superblock */
+ 
+ struct xbsd_disklabel {
+-	__u32	d_magic;		/* the magic number */
+-	__s16	d_type;			/* drive type */
+-	__s16	d_subtype;		/* controller/d_type specific */
+-	char	d_typename[16];		/* type name, e.g. "eagle" */
+-	char	d_packname[16];			/* pack identifier */ 
++	uint32_t	d_magic;		/* the magic number */
++	int16_t		d_type;			/* drive type */
++	int16_t		d_subtype;		/* controller/d_type specific */
++	char		d_typename[16];		/* type name, e.g. "eagle" */
++	char		d_packname[16];		/* pack identifier */ 
+ 			/* disk geometry: */
+-	__u32	d_secsize;		/* # of bytes per sector */
+-	__u32	d_nsectors;		/* # of data sectors per track */
+-	__u32	d_ntracks;		/* # of tracks per cylinder */
+-	__u32	d_ncylinders;		/* # of data cylinders per unit */
+-	__u32	d_secpercyl;		/* # of data sectors per cylinder */
+-	__u32	d_secperunit;		/* # of data sectors per unit */
++	uint32_t	d_secsize;		/* # of bytes per sector */
++	uint32_t	d_nsectors;		/* # of data sectors per track */
++	uint32_t	d_ntracks;		/* # of tracks per cylinder */
++	uint32_t	d_ncylinders;		/* # of data cylinders per unit */
++	uint32_t	d_secpercyl;		/* # of data sectors per cylinder */
++	uint32_t	d_secperunit;		/* # of data sectors per unit */
+ 	/*
+ 	 * Spares (bad sector replacements) below
+ 	 * are not counted in d_nsectors or d_secpercyl.
+ 	 * Spare sectors are assumed to be physical sectors
+ 	 * which occupy space at the end of each track and/or cylinder.
+ 	 */
+-	__u16	d_sparespertrack;	/* # of spare sectors per track */
+-	__u16	d_sparespercyl;		/* # of spare sectors per cylinder */
++	uint16_t	d_sparespertrack;	/* # of spare sectors per track */
++	uint16_t	d_sparespercyl;		/* # of spare sectors per cylinder */
+ 	/*
+ 	 * Alternate cylinders include maintenance, replacement,
+ 	 * configuration description areas, etc.
+ 	 */
+-	__u32	d_acylinders;		/* # of alt. cylinders per unit */
++	uint32_t	d_acylinders;		/* # of alt. cylinders per unit */
+ 
+ 			/* hardware characteristics: */
+ 	/*
+@@ -103,30 +103,30 @@
+ 	 * Finally, d_cylskew is the offset of sector 0 on cylinder N
+ 	 * relative to sector 0 on cylinder N-1.
+ 	 */
+-	__u16	d_rpm;			/* rotational speed */
+-	__u16	d_interleave;		/* hardware sector interleave */
+-	__u16	d_trackskew;		/* sector 0 skew, per track */
+-	__u16	d_cylskew;		/* sector 0 skew, per cylinder */
+-	__u32	d_headswitch;		/* head switch time, usec */
+-	__u32	d_trkseek;		/* track-to-track seek, usec */
+-	__u32	d_flags;		/* generic flags */
++	uint16_t	d_rpm;			/* rotational speed */
++	uint16_t	d_interleave;		/* hardware sector interleave */
++	uint16_t	d_trackskew;		/* sector 0 skew, per track */
++	uint16_t	d_cylskew;		/* sector 0 skew, per cylinder */
++	uint32_t	d_headswitch;		/* head switch time, usec */
++	uint32_t	d_trkseek;		/* track-to-track seek, usec */
++	uint32_t	d_flags;		/* generic flags */
+ #define NDDATA 5
+-	__u32	d_drivedata[NDDATA];	/* drive-type specific information */
++	uint32_t	d_drivedata[NDDATA];	/* drive-type specific information */
+ #define NSPARE 5
+-	__u32	d_spare[NSPARE];	/* reserved for future use */
+-	__u32	d_magic2;		/* the magic number (again) */
+-	__u16	d_checksum;		/* xor of data incl. partitions */
++	uint32_t	d_spare[NSPARE];	/* reserved for future use */
++	uint32_t	d_magic2;		/* the magic number (again) */
++	uint16_t	d_checksum;		/* xor of data incl. partitions */
+ 			/* filesystem and partition information: */
+-	__u16	d_npartitions;	        /* number of partitions in following */
+-	__u32	d_bbsize;	        /* size of boot area at sn0, bytes */
+-	__u32	d_sbsize;	        /* max size of fs superblock, bytes */
++	uint16_t	d_npartitions;	        /* number of partitions in following */
++	uint32_t	d_bbsize;	        /* size of boot area at sn0, bytes */
++	uint32_t	d_sbsize;	        /* max size of fs superblock, bytes */
+ 	struct xbsd_partition	 {	/* the partition table */
+-		__u32	p_size;	        /* number of sectors in partition */
+-		__u32	p_offset;       /* starting sector */
+-		__u32	p_fsize;        /* filesystem basic fragment size */
+-		__u8	p_fstype;       /* filesystem type, see below */
+-		__u8	p_frag;	        /* filesystem fragments per block */
+-		__u16	p_cpg;	        /* filesystem cylinders per group */
++		uint32_t	p_size;	        /* number of sectors in partition */
++		uint32_t	p_offset;       /* starting sector */
++		uint32_t	p_fsize;        /* filesystem basic fragment size */
++		uint8_t		p_fstype;       /* filesystem type, see below */
++		uint8_t		p_frag;	        /* filesystem fragments per block */
++		uint16_t	p_cpg;	        /* filesystem cylinders per group */
+ 	} d_partitions[BSD_MAXPARTITIONS]; /* actually may be more */
+ };
+ 
+diff -urNad util-linux/fdisk/fdisksgilabel.c /tmp/dpep.lVXZel/util-linux/fdisk/fdisksgilabel.c
+--- util-linux/fdisk/fdisksgilabel.c	2004-11-04 10:19:17.000000000 -0700
++++ /tmp/dpep.lVXZel/util-linux/fdisk/fdisksgilabel.c	2004-12-15 08:26:47.881009562 -0700
+@@ -16,13 +16,11 @@
+ #include <stdlib.h>		/* exit */
+ #include <string.h>             /* strstr */
+ #include <unistd.h>             /* write */
+-#include <sys/ioctl.h>          /* ioctl */
+ #include <sys/stat.h>           /* stat */
+ #include <assert.h>             /* assert */
+ 
+ #include <endian.h>
+ #include "nls.h"
+-#include <linux/major.h>        /* FLOPPY_MAJOR */
+ 
+ #include "common.h"
+ #include "fdisk.h"
+@@ -100,11 +98,11 @@
+ 
+ static inline unsigned short
+ __swap16(unsigned short x) {
+-        return (((__u16)(x) & 0xFF) << 8) | (((__u16)(x) & 0xFF00) >> 8);
++        return (((uint16_t)(x) & 0xFF) << 8) | (((uint16_t)(x) & 0xFF00) >> 8);
+ }
+ 
+-static inline __u32
+-__swap32(__u32 x) {
++static inline uint32_t
++__swap32(uint32_t x) {
+         return (((x & 0xFF) << 24) |
+ 		((x & 0xFF00) << 8) |
+ 		((x & 0xFF0000) >> 8) |
+@@ -220,8 +218,8 @@
+ 	       w + 1, _("Device"));
+ 	for (i = 0 ; i < partitions; i++) {
+ 		if (sgi_get_num_sectors(i) || debug) {
+-			__u32 start = sgi_get_start_sector(i);
+-			__u32 len = sgi_get_num_sectors(i);
++			uint32_t start = sgi_get_start_sector(i);
++			uint32_t len = sgi_get_num_sectors(i);
+ 			kpi++;		/* only count nonempty partitions */
+ 			printf(
+ 				"%2d: %s %4s %9ld %9ld %9ld  %2x  %s\n",
+@@ -242,8 +240,8 @@
+ 	       sgilabel->boot_file);
+ 	for (i = 0 ; i < volumes; i++) {
+ 		if (sgilabel->directory[i].vol_file_size) {
+-			__u32 start = SSWAP32(sgilabel->directory[i].vol_file_start);
+-			__u32 len = SSWAP32(sgilabel->directory[i].vol_file_size);
++			uint32_t start = SSWAP32(sgilabel->directory[i].vol_file_start);
++			uint32_t len = SSWAP32(sgilabel->directory[i].vol_file_size);
+ 			char *name = sgilabel->directory[i].vol_file_name;
+ 			printf(_("%2d: %-10s sector%5u size%8u\n"),
+ 			       i, name, (unsigned int) start,
+diff -urNad util-linux/fdisk/fdisksgilabel.h /tmp/dpep.lVXZel/util-linux/fdisk/fdisksgilabel.h
+--- util-linux/fdisk/fdisksgilabel.h	2003-07-13 08:11:41.000000000 -0600
++++ /tmp/dpep.lVXZel/util-linux/fdisk/fdisksgilabel.h	2004-12-15 08:26:47.881009562 -0700
+@@ -1,4 +1,4 @@
+-#include <linux/types.h>   /* for __u32 etc */
++#include <stdint.h>	/* for uint32_t, uint16_t, uint8_t, int16_t */
+ /*
+  * Copyright (C) Andreas Neuper, Sep 1998.
+  *	This file may be modified and redistributed under
+@@ -96,9 +96,9 @@
+ #define	SGI_INFO_MAGIC		0x00072959
+ #define	SGI_INFO_MAGIC_SWAPPED	0x59290700
+ #define SSWAP16(x) (other_endian ? __swap16(x) \
+-                                 : (__u16)(x))
++                                 : (uint16_t)(x))
+ #define SSWAP32(x) (other_endian ? __swap32(x) \
+-                                 : (__u32)(x))
++                                 : (uint32_t)(x))
+ 
+ /* fdisk.c */
+ #define sgilabel ((sgi_partition *)MBRbuffer)
+diff -urNad util-linux/fdisk/fdisksunlabel.c /tmp/dpep.lVXZel/util-linux/fdisk/fdisksunlabel.c
+--- util-linux/fdisk/fdisksunlabel.c	2003-07-13 08:11:55.000000000 -0600
++++ /tmp/dpep.lVXZel/util-linux/fdisk/fdisksunlabel.c	2004-12-15 08:26:47.882009347 -0700
+@@ -27,7 +27,9 @@
+ #include <scsi/scsi.h>		/* SCSI_IOCTL_GET_IDLUN */
+ #undef u_char
+ #endif
++#ifdef __linux__
+ #include <linux/major.h>	/* FLOPPY_MAJOR */
++#endif
+ 
+ #include "common.h"
+ #include "fdisk.h"
+@@ -60,10 +62,10 @@
+ };
+ 
+ static inline unsigned short __swap16(unsigned short x) {
+-        return (((__u16)(x) & 0xFF) << 8) | (((__u16)(x) & 0xFF00) >> 8);
++        return (((uint16_t)(x) & 0xFF) << 8) | (((uint16_t)(x) & 0xFF00) >> 8);
+ }
+-static inline __u32 __swap32(__u32 x) {
+-        return (((__u32)(x) & 0xFF) << 24) | (((__u32)(x) & 0xFF00) << 8) | (((__u32)(x) & 0xFF0000) >> 8) | (((__u32)(x) & 0xFF000000) >> 24);
++static inline uint32_t __swap32(uint32_t x) {
++        return (((uint32_t)(x) & 0xFF) << 24) | (((uint32_t)(x) & 0xFF00) << 8) | (((uint32_t)(x) & 0xFF0000) >> 8) | (((uint32_t)(x) & 0xFF000000) >> 24);
+ }
+ 
+ int
+@@ -71,18 +73,21 @@
+ 	return SSWAP32(p.num_sectors);
+ }
+ 
++#ifdef __linux__
+ #ifndef IDE0_MAJOR
+ #define IDE0_MAJOR 3
+ #endif
+ #ifndef IDE1_MAJOR
+ #define IDE1_MAJOR 22
+ #endif
++#endif
+ void guess_device_type(int fd) {
+ 	struct stat bootstat;
+ 
+ 	if (fstat (fd, &bootstat) < 0) {
+                 scsi_disk = 0;
+                 floppy = 0;
++#ifdef __linux__
+ 	} else if (S_ISBLK(bootstat.st_mode)
+ 		   && (major(bootstat.st_rdev) == IDE0_MAJOR ||
+ 		       major(bootstat.st_rdev) == IDE1_MAJOR)) {
+@@ -92,6 +97,7 @@
+ 		   && major(bootstat.st_rdev) == FLOPPY_MAJOR) {
+                 scsi_disk = 0;
+                 floppy = 1;
++#endif
+ 	} else {
+                 scsi_disk = 1;
+                 floppy = 0;
+@@ -674,8 +680,8 @@
+ 	       w + 1, _("Device"));
+ 	for (i = 0 ; i < partitions; i++) {
+ 		if (sunlabel->partitions[i].num_sectors) {
+-			__u32 start = SSWAP32(sunlabel->partitions[i].start_cylinder) * heads * sectors;
+-			__u32 len = SSWAP32(sunlabel->partitions[i].num_sectors);
++			uint32_t start = SSWAP32(sunlabel->partitions[i].start_cylinder) * heads * sectors;
++			uint32_t len = SSWAP32(sunlabel->partitions[i].num_sectors);
+ 			printf(
+ 			    "%s %c%c %9ld %9ld %9ld%c  %2x  %s\n",
+ /* device */		  partname(disk_device, i+1, w),
+diff -urNad util-linux/fdisk/fdisksunlabel.h /tmp/dpep.lVXZel/util-linux/fdisk/fdisksunlabel.h
+--- util-linux/fdisk/fdisksunlabel.h	2003-07-13 08:12:20.000000000 -0600
++++ /tmp/dpep.lVXZel/util-linux/fdisk/fdisksunlabel.h	2004-12-15 08:26:47.882009347 -0700
+@@ -1,4 +1,4 @@
+-#include <linux/types.h>   /* for __u16, __u32 */
++#include <stdint.h>	/* for uint32_t, uint16_t, uint8_t, int16_t */
+ 
+ typedef struct {
+ 	unsigned char info[128];   /* Informative text string */
+@@ -21,8 +21,8 @@
+ 	unsigned short nsect;      /* Sectors per track */
+ 	unsigned char spare3[4];   /* Even more magic... */
+ 	struct sun_partition {
+-		__u32 start_cylinder;
+-		__u32 num_sectors;
++		uint32_t start_cylinder;
++		uint32_t num_sectors;
+ 	} partitions[8];
+ 	unsigned short magic;      /* Magic number */
+ 	unsigned short csum;       /* Label xor'd checksum */
+@@ -32,9 +32,9 @@
+ #define SUN_LABEL_MAGIC_SWAPPED  0xBEDA
+ #define sunlabel ((sun_partition *)MBRbuffer)
+ #define SSWAP16(x) (other_endian ? __swap16(x) \
+-				 : (__u16)(x))
++				 : (uint16_t)(x))
+ #define SSWAP32(x) (other_endian ? __swap32(x) \
+-				 : (__u32)(x))
++				 : (uint32_t)(x))
+ 				 
+ /* fdisk.c */
+ extern char MBRbuffer[MAX_SECTOR_SIZE];
+diff -urNad util-linux/fdisk/sfdisk.c /tmp/dpep.lVXZel/util-linux/fdisk/sfdisk.c
+--- util-linux/fdisk/sfdisk.c	2004-12-15 08:26:36.639426028 -0700
++++ /tmp/dpep.lVXZel/util-linux/fdisk/sfdisk.c	2004-12-15 08:26:47.884008917 -0700
+@@ -48,7 +48,9 @@
+ #include <sys/ioctl.h>
+ #include <sys/stat.h>
+ #include <sys/utsname.h>
++#ifdef __linux__
+ #include <linux/unistd.h>	/* _syscall */
++#endif
+ #include "nls.h"
+ #include "common.h"
+ #include "get_blocks.h"
+@@ -448,11 +450,15 @@
+     unsigned long long sectors;
+     struct geometry R;
+ 
++#ifdef __linux__
+     if (ioctl(fd, HDIO_GETGEO, &g)) {
+ 	g.heads = g.sectors = g.cylinders = g.start = 0;
+ 	if (!silent)
+ 	    do_warn(_("Disk %s: cannot get geometry\n"), dev);
+     }
++#else
++    g.heads = g.sectors = g.cylinders = g.start = 0;
++#endif
+ 
+     R.start = g.start;
+     R.heads = g.heads;
+@@ -791,6 +797,7 @@
+ /* tell the kernel to reread the partition tables */
+ static int
+ reread_ioctl(int fd) {
++#ifdef __linux__
+     if (ioctl(fd, BLKRRPART)) {
+ 	perror("BLKRRPART");
+ 
+@@ -798,6 +805,7 @@
+ 	if (errno == EBUSY)
+ 		return -1;
+     }
++#endif
+     return 0;
+ }
+ 
+@@ -1501,6 +1509,7 @@
+ 	z->partno = pno;
+ }
+ 
++#ifdef __linux__
+ #define MAKE_VERSION(p,q,r)     (65536*(p) + 256*(q) + (r))
+ 
+ static int
+@@ -1516,6 +1525,7 @@
+         }
+         return 0;
+ }
++#endif
+ 
+ static int
+ msdos_partition(char *dev, int fd, unsigned long start, struct disk_desc *z) {
+@@ -1525,7 +1535,11 @@
+     struct sector *s;
+     struct part_desc *partitions = &(z->partitions[0]);
+     int pno = z->partno;
++#ifdef __linux__   
+     int bsd_later = (linux_version_code() >= MAKE_VERSION(2,3,40));
++#else
++    int bsd_later = 0;
++#endif
+ 
+     if (!(s = get_sector(dev, fd, start)))
+ 	return 0;
+diff -urNad util-linux/hwclock/Makefile /tmp/dpep.lVXZel/util-linux/hwclock/Makefile
+--- util-linux/hwclock/Makefile	2002-07-06 15:23:58.000000000 -0600
++++ /tmp/dpep.lVXZel/util-linux/hwclock/Makefile	2004-12-15 08:26:47.884008917 -0700
+@@ -3,6 +3,7 @@
+ include ../make_include
+ include ../MCONFIG
+ 
++ifeq "$(OS)" "linux"
+ # Where to put man pages?
+ 
+ MAN8= 		hwclock.8
+@@ -11,6 +12,7 @@
+ # See the "install" rule for the links. . .
+ 
+ SBIN= 		hwclock
++endif
+ 
+ 
+ all: $(SBIN)
+diff -urNad util-linux/lib/Makefile /tmp/dpep.lVXZel/util-linux/lib/Makefile
+--- util-linux/lib/Makefile	2004-12-15 08:26:36.801391213 -0700
++++ /tmp/dpep.lVXZel/util-linux/lib/Makefile	2004-12-15 08:26:47.884008917 -0700
+@@ -10,8 +10,6 @@
+ 
+ env.o: env.h
+ 
+-get_blocks.o: get_blocks.h
+-
+ setproctitle.o: setproctitle.h
+ 
+ carefulputc.o: carefulputc.h
+@@ -20,6 +18,8 @@
+ 
+ xgethostname.o: xgethostname.h
+ 
++get_blocks.o: get_blocks.h
++
+ md5.o: md5.c md5.h
+ 
+ .PHONY: clean
+diff -urNad util-linux/lib/get_blocks.c /tmp/dpep.lVXZel/util-linux/lib/get_blocks.c
+--- util-linux/lib/get_blocks.c	2004-12-15 08:26:36.640425813 -0700
++++ /tmp/dpep.lVXZel/util-linux/lib/get_blocks.c	2004-12-15 08:26:47.885008702 -0700
+@@ -19,6 +19,7 @@
+ #include <sys/stat.h>
+ #include <unistd.h>
+ 
++#ifdef __linux__
+ #include <sys/ioctl.h>
+ 
+ /* can't #include <linux/fs.h>, because it uses u64... */
+@@ -33,6 +34,7 @@
+ #define BLKGETSIZE64 _IOR(0x12,114,long long)
+ #endif
+ #endif
++#endif /* __linux__ */
+ 
+ static int
+ valid_offset (int fd, off_t offset)
+@@ -72,6 +74,7 @@
+ {
+ 	struct stat	st;
+ 
++#ifdef __linux__
+ 	{
+ 		unsigned long longsectors;
+ 		unsigned long long bytes;	/* really u64 */
+@@ -108,6 +111,7 @@
+ 		total_number_of_sectors = (bytes >> 9);
+ 		return total_number_of_sectors;
+ 	}
++#endif /*  __linux__ */
+ 
+ 	if (fstat(fd, &st) == 0)
+ 		return st.st_size / 512;
+diff -urNad util-linux/login-utils/Makefile /tmp/dpep.lVXZel/util-linux/login-utils/Makefile
+--- util-linux/login-utils/Makefile	2004-12-15 08:26:36.802390998 -0700
++++ /tmp/dpep.lVXZel/util-linux/login-utils/Makefile	2004-12-15 08:26:47.885008702 -0700
+@@ -18,8 +18,10 @@
+ 
+ MAN8.GETTY=	agetty.8
+ 
+-MAN8.INIT=	fastboot.8 fasthalt.8 halt.8 reboot.8 simpleinit.8 shutdown.8 \
+-		initctl.8
++MAN8.INIT=	simpleinit.8 initctl.8
++ifeq "$(OS)" "linux"
++MAN8.INIT:=	$(MAN8.INIT) fastboot.8 fasthalt.8 halt.8 reboot.8 shutdown.8
++endif
+ 
+ MAN8.PUTILS=	vipw.8 vigr.8
+ 
+@@ -28,7 +30,10 @@
+ 
+ SBIN.GETTY=	agetty
+ 
+-SBIN.INIT=	simpleinit shutdown initctl
++SBIN.INIT=	simpleinit initctl
++ifeq "$(OS)" "linux"
++SBIN.INIT:=	$(SBIN.INIT) shutdown
++endif
+ 
+ BIN.PUTILS=	login
+ 
+@@ -141,12 +146,14 @@
+ ifeq "$(USE_TTY_GROUP)" "yes"
+ 	LOGINFLAGS += -DUSE_TTY_GROUP
+ endif
++ifeq "$(OS)" "linux"
+ ifeq "$(ALLOW_VCS_USE)" "yes"
+ 	LOGINFLAGS += -DCHOWNVCS
+ endif
+ ifeq "$(DO_STAT_MAIL)" "yes"
+ 	LOGINFLAGS += -DDO_STAT_MAIL
+ endif
++endif
+ 
+ login.o: login.c $(LIB)/pathnames.h $(LIB)/setproctitle.c $(LIB)/setproctitle.h \
+ 		$(LIB)/xgethostname.h
+@@ -197,10 +204,12 @@
+ 	$(INSTALLDIR) $(MAN8DIR)
+ 	$(INSTALLMAN) $(MAN8.INIT) $(MAN8DIR)
+ 	# Make *relative* links for these
++ifeq "$(OS)" "linux"
+ 	(cd $(SHUTDOWNDIR); ln -sf shutdown reboot)
+ 	(cd $(SHUTDOWNDIR); ln -sf shutdown fastboot)
+ 	(cd $(SHUTDOWNDIR); ln -sf shutdown halt)
+ 	(cd $(SHUTDOWNDIR); ln -sf shutdown fasthalt)
++endif
+ 	(cd $(SHUTDOWNDIR); ln -sf initctl need)
+ 	(cd $(SHUTDOWNDIR); ln -sf initctl display-services)
+ 	(cd $(SHUTDOWNDIR); ln -sf initctl provide)
+diff -urNad util-linux/login-utils/agetty.c /tmp/dpep.lVXZel/util-linux/login-utils/agetty.c
+--- util-linux/login-utils/agetty.c	2004-12-15 08:26:36.803390783 -0700
++++ /tmp/dpep.lVXZel/util-linux/login-utils/agetty.c	2004-12-15 08:26:47.886008488 -0700
+@@ -32,10 +32,11 @@
+ #include <sys/ioctl.h>
+ #include <sys/vt.h>
+ #include <linux/tty.h>
++#include "xgethostname.h"
+ #include "xstrncpy.h"
+ #include "nls.h"
+ 
+-#ifdef __linux__
++#if defined(unix)
+ #include "pathnames.h"
+ #include <sys/param.h>
+ #define USE_SYSLOG
+@@ -280,7 +281,7 @@
+ 
+     parse_args(argc, argv, &options);
+ 
+-#ifdef __linux__
++#if defined(unix)
+ 	setsid();
+ #endif
+ 	
+@@ -294,7 +295,7 @@
+     /* Open the tty as standard { input, output, error }. */
+     open_tty(options.tty, &termios, options.flags & F_LOCAL);
+ 
+-#ifdef __linux__
++#if defined(unix)
+ 	{
+ 		int iv;
+ 		
+@@ -789,7 +790,7 @@
+      * reads will be done in raw mode anyway. Errors will be dealt with
+      * lateron.
+      */
+-#ifdef __linux__
++#if defined(unix)
+     /* flush input and output queues, important for modems! */
+     (void) tcflush(0, TCIOFLUSH);
+ #endif
+@@ -800,7 +801,9 @@
+     }
+ 
+     tp->c_iflag = tp->c_lflag = tp->c_oflag = 0;
++#if defined(__linux__)
+     tp->c_line = 0;
++#endif
+     tp->c_cc[VMIN] = 1;
+     tp->c_cc[VTIME] = 0;
+ 
+@@ -1017,7 +1020,7 @@
+ 	(void) fclose(fd);
+     }
+ #endif
+-#ifdef __linux__
++#ifdef unix
+ 	{
+ 		char *hn;
+ 
+diff -urNad util-linux/login-utils/checktty.c /tmp/dpep.lVXZel/util-linux/login-utils/checktty.c
+--- util-linux/login-utils/checktty.c	2001-05-19 15:53:18.000000000 -0600
++++ /tmp/dpep.lVXZel/util-linux/login-utils/checktty.c	2004-12-15 08:26:47.886008488 -0700
+@@ -138,7 +138,9 @@
+ isapty(const char *tty)
+ {
+     char devname[100];
++#if defined(__linux__)
+     struct stat stb;
++#endif
+ 
+     /* avoid snprintf - old systems do not have it */
+     if (strlen(tty) + 6 > sizeof(devname))
+diff -urNad util-linux/login-utils/login.c /tmp/dpep.lVXZel/util-linux/login-utils/login.c
+--- util-linux/login-utils/login.c	2004-12-04 19:37:12.000000000 -0700
++++ /tmp/dpep.lVXZel/util-linux/login-utils/login.c	2004-12-15 08:26:47.887008273 -0700
+@@ -149,7 +150,7 @@
+ }
+ #endif
+ 
+-#ifndef __linux__
++#if !defined(__linux__) && !defined(__GNU__)
+ #  include <tzfile.h>
+ #endif
+ #include <lastlog.h>
+@@ -202,18 +203,14 @@
+ 
+ #define	TTYGRPNAME	"tty"		/* name of group to own ttys */
+ 
+-#ifndef MAXPATHLEN
+-#  define MAXPATHLEN 1024
+-#endif
+-
+ /*
+  * This bounds the time given to login.  Not a define so it can
+  * be patched on machines where it's too small.
+  */
+-#ifndef __linux__
+-int	timeout = 300;
++#if defined(__linux__) || defined(__GNU__)
++int	timeout = 60;		/* used in cryptocard.c */
+ #else
+-int     timeout = 60;		/* used in cryptocard.c */
++int	timeout = 300;
+ #endif
+ 
+ struct	passwd *pwd;		/* used in cryptocard.c */
+@@ -223,7 +220,7 @@
+ char    hostaddress[4];		/* used in checktty.c */
+ char	*hostname;		/* idem */
+ static char	*username, *tty_name, *tty_number;
+-static char	thishost[100];
++static char	*thishost;
+ static int	failures = 1;
+ static pid_t	pid;
+ 
+@@ -288,6 +285,7 @@
+ 	}
+ }
+ 
++#ifdef CHOWNVCS
+ /* true if the filedescriptor fd is a console tty, very Linux specific */
+ static int
+ consoletty(int fd) {
+@@ -302,6 +300,7 @@
+ #endif
+     return 0;
+ }
++#endif
+ 
+ #if USE_PAM
+ /*
+@@ -861,23 +862,21 @@
+        having the BSD setreuid() */
+     
+     {
+-	char tmpstr[MAXPATHLEN];
++	char *tmpstr;
+ 	uid_t ruid = getuid();
+ 	gid_t egid = getegid();
+ 
+ 	/* avoid snprintf - old systems do not have it, or worse,
+ 	   have a libc in which snprintf is the same as sprintf */
+-	if (strlen(pwd->pw_dir) + sizeof(_PATH_HUSHLOGIN) + 2 > MAXPATHLEN)
+-		quietlog = 0;
+-	else {
+-		sprintf(tmpstr, "%s/%s", pwd->pw_dir, _PATH_HUSHLOGIN);
+-		setregid(-1, pwd->pw_gid);
+-		setreuid(0, pwd->pw_uid);
+-		quietlog = (access(tmpstr, R_OK) == 0);
+-		setuid(0); /* setreuid doesn't do it alone! */
+-		setreuid(ruid, 0);
+-		setregid(-1, egid);
+-	}
++	tmpstr = malloc(strlen(pwd->pw_dir) + sizeof(_PATH_HUSHLOGIN) + 2);
++	sprintf(tmpstr, "%s/%s", pwd->pw_dir, _PATH_HUSHLOGIN);
++	setregid(-1, pwd->pw_gid);
++	setreuid(0, pwd->pw_uid);
++	quietlog = (access(tmpstr, R_OK) == 0);
++	setuid(0); /* setreuid doesn't do it alone! */
++	setreuid(ruid, 0);
++	setregid(-1, egid);
++	free(tmpstr);
+     }
+     
+     /* for linux, write entries in utmp and wtmp */
+@@ -1028,12 +1027,13 @@
+     
+     /* mailx will give a funny error msg if you forget this one */
+     {
+-      char tmp[MAXPATHLEN];
++      char *tmp;
++
+       /* avoid snprintf */
+-      if (sizeof(_PATH_MAILDIR) + strlen(pwd->pw_name) + 1 < MAXPATHLEN) {
+-	      sprintf(tmp, "%s/%s", _PATH_MAILDIR, pwd->pw_name);
+-	      setenv("MAIL",tmp,0);
+-      }
++      tmp = malloc(sizeof(_PATH_MAILDIR) + strlen(pwd->pw_name) + 2);
++      sprintf(tmp, "%s/%s", _PATH_MAILDIR, pwd->pw_name);
++      setenv("MAIL", tmp, 0);
++      free(tmp);
+     }
+     
+     /* LOGNAME is not documented in login(1) but
+@@ -1191,13 +1191,15 @@
+ 	childArgv[childArgc++] = "-c";
+ 	childArgv[childArgc++] = buff;
+     } else {
+-	tbuf[0] = '-';
+-	xstrncpy(tbuf + 1, ((p = rindex(pwd->pw_shell, '/')) ?
+-			   p + 1 : pwd->pw_shell),
+-		sizeof(tbuf)-1);
++	char *tbuf, *shell_cmd;
++
++	tbuf = ((p = rindex(pwd->pw_shell, '/')) ? p + 1 : pwd->pw_shell);
++	shell_cmd = malloc(strlen(tbuf));
++	shell_cmd[0] = '-';
++	xstrncpy(shell_cmd + 1, tbuf, strlen(tbuf)-1);
+ 	
+ 	childArgv[childArgc++] = pwd->pw_shell;
+-	childArgv[childArgc++] = tbuf;
++	childArgv[childArgc++] = shell_cmd;
+     }
+ 
+     childArgv[childArgc++] = NULL;
+diff -urNad util-linux/login-utils/simpleinit.h /tmp/dpep.lVXZel/util-linux/login-utils/simpleinit.h
+--- util-linux/login-utils/simpleinit.h	2000-11-05 05:41:35.000000000 -0700
++++ /tmp/dpep.lVXZel/util-linux/login-utils/simpleinit.h	2004-12-15 08:26:47.888008058 -0700
+@@ -3,7 +3,7 @@
+ 
+ 
+ #define ERRSTRING strerror (errno)
+-#define COMMAND_SIZE  (PIPE_BUF - 4)
++#define COMMAND_SIZE  (_POSIX_PIPE_BUF - 4)
+ 
+ 
+ #define COMMAND_TEST       0  /*  No wait, signal                            */
+diff -urNad util-linux/misc-utils/mcookie.c /tmp/dpep.lVXZel/util-linux/misc-utils/mcookie.c
+--- util-linux/misc-utils/mcookie.c	2002-03-08 16:00:52.000000000 -0700
++++ /tmp/dpep.lVXZel/util-linux/misc-utils/mcookie.c	2004-12-15 08:26:47.888008058 -0700
+@@ -20,18 +20,16 @@
+  *
+  */
+ 
+-#ifdef __linux__
+-#define HAVE_GETTIMEOFDAY 1
+-#endif
+-
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <fcntl.h>
+ #include "md5.h"
+-#if HAVE_GETTIMEOFDAY
++#include "../defines.h"
++#ifdef HAVE_gettimeofday
+ #include <sys/time.h>
+-#include <unistd.h>
+ #endif
++#include <time.h>
++#include <unistd.h>
+ #include "nls.h"
+ 
+ #define BUFFERSIZE 4096
+@@ -79,7 +77,7 @@
+    pid_t             pid;
+    char              *file = NULL;
+    int               r;
+-#if HAVE_GETTIMEOFDAY
++#ifdef HAVE_gettimeofday
+    struct timeval    tv;
+    struct timezone   tz;
+ #else
+@@ -98,7 +96,7 @@
+ 
+    MD5Init( &ctx );
+    
+-#if HAVE_GETTIMEOFDAY
++#ifdef HAVE_gettimeofday
+    gettimeofday( &tv, &tz );
+    MD5Update( &ctx, (unsigned char *)&tv, sizeof( tv ) );
+ #else
+diff -urNad util-linux/misc-utils/script.c /tmp/dpep.lVXZel/util-linux/misc-utils/script.c
+--- util-linux/misc-utils/script.c	2004-03-26 10:07:16.000000000 -0700
++++ /tmp/dpep.lVXZel/util-linux/misc-utils/script.c	2004-12-15 08:26:47.888008058 -0700
+@@ -54,10 +54,8 @@
+ #include <sys/signal.h>
+ #include "nls.h"
+ 
+-#ifdef __linux__
+ #include <unistd.h>
+ #include <string.h>
+-#endif
+ 
+ #include "../defines.h"
+ #ifdef HAVE_openpty
+diff -urNad util-linux/misc-utils/setterm.c /tmp/dpep.lVXZel/util-linux/misc-utils/setterm.c
+--- util-linux/misc-utils/setterm.c	2003-10-17 10:17:51.000000000 -0600
++++ /tmp/dpep.lVXZel/util-linux/misc-utils/setterm.c	2004-12-15 08:26:47.889007843 -0700
+@@ -107,16 +107,14 @@
+ #else
+ #include <curses.h>
+ #endif
++#ifdef __linux__
+ #include <sys/param.h>		/* for MAXPATHLEN */
++#endif
+ #include <sys/ioctl.h>
+ #include <sys/time.h>
+ #include "nls.h"
+ 
+-#ifndef TCGETS
+-/* TCGETS is either defined in termios.h, or here: */
+-#include <asm/ioctls.h>
+-#endif
+-
++#ifdef __linux__
+ #if __GNU_LIBRARY__ < 5
+ #ifndef __alpha__
+ # include <linux/unistd.h>
+@@ -127,6 +125,7 @@
+ #endif
+ #endif
+ extern int klogctl(int type, char *buf, int len);
++#endif /* __linux__ */
+ 
+ /* Constants. */
+ 
+@@ -165,19 +164,24 @@
+ int opt_term, opt_reset, opt_initialize, opt_cursor;
+ int opt_linewrap, opt_snow, opt_softscroll, opt_default, opt_foreground;
+ int opt_background, opt_bold, opt_blink, opt_reverse, opt_underline;
+-int opt_store, opt_clear, opt_blank, opt_snap, opt_snapfile, opt_standout;
+-int opt_append, opt_ulcolor, opt_hbcolor, opt_halfbright, opt_repeat;
++int opt_store, opt_clear, opt_blank, opt_standout;
++int opt_ulcolor, opt_hbcolor, opt_halfbright, opt_repeat;
+ int opt_tabs, opt_clrtabs, opt_regtabs, opt_appcursorkeys, opt_inversescreen;
+-int opt_msg, opt_msglevel, opt_powersave, opt_powerdown;
++int opt_powerdown;
+ int opt_blength, opt_bfreq;
++#ifdef __linux__
++int opt_append, opt_snap, opt_snapfile;
++int opt_powersave;
++int opt_msg, opt_msglevel;
++#endif /* __linux__ */
+ 
+ /* Option controls.  The variable names have been contracted to ensure
+  * uniqueness.
+  */
+ char *opt_te_terminal_name;	/* Terminal name. */
+-int opt_cu_on, opt_li_on, opt_sn_on, opt_so_on, opt_bo_on, opt_hb_on, opt_bl_on;
+-int opt_re_on, opt_un_on, opt_rep_on, opt_appck_on, opt_invsc_on;
+-int opt_msg_on;			/* Boolean switches. */
++int opt_cu_on, opt_li_on, opt_sn_on, opt_so_on, opt_bo_on, opt_hb_on;
++int opt_bl_on, opt_re_on, opt_un_on, opt_rep_on, opt_appck_on;
++int opt_invsc_on;		/* Boolean switches. */
+ int opt_ke_type;		/* Keyboard type. */
+ int opt_fo_color, opt_ba_color;	/* Colors. */
+ int opt_ul_color, opt_hb_color;
+@@ -185,16 +189,20 @@
+ int opt_bl_min;			/* Blank screen. */
+ int opt_blength_l;
+ int opt_bfreq_f;
+-int opt_sn_num;			/* Snap screen. */
+ int opt_st_attr;
+ int opt_rt_len;			/* regular tab length */
+ int opt_tb_array[161];		/* Array for tab list */
+-int opt_msglevel_num;
+ int opt_ps_mode, opt_pd_min;	/* powersave mode/powerdown time */
+ 
++#ifdef __linux__
++int opt_msg_on;
++int opt_msglevel_num;
++
++int opt_sn_num;			/* Snap screen. */
+ char opt_sn_name[200] = "screen.dump";
+ 
+ static void screendump(int vcnum, FILE *F);
++#endif /* __linux__ */
+ 
+ /* Command line parsing routines.
+  *
+@@ -402,6 +410,7 @@
+ 	}
+ }
+ 
++#ifdef __linux__
+ static void
+ parse_powersave(int argc, char **argv, int *option, int *opt_mode, int *bad_arg) {
+ 	/* argc: Number of arguments for this option. */
+@@ -432,6 +441,7 @@
+ 		*opt_mode = 0;
+ 	}
+ }
++#endif /* __linux__ */
+ 
+ #if 0
+ static void
+@@ -454,6 +464,7 @@
+ }
+ #endif
+ 
++#ifdef __linux__
+ static void
+ parse_msglevel(int argc, char **argv, int *option, int *opt_all, int *bad_arg) {
+ 	/* argc: Number of arguments for this option. */
+@@ -512,6 +523,7 @@
+ 	if (argc == 1)
+ 		strcpy((char *)opt_all, argv[0]);
+ }
++#endif /* __linux__ */
+ 
+ static void
+ parse_tabs(int argc, char **argv, int *option, int *tab_array, int *bad_arg) {
+@@ -709,6 +721,7 @@
+ 		parse_regtabs(argc, argv, &opt_regtabs, &opt_rt_len, bad_arg);
+ 	else if (STRCMP(option, "blank") == 0)
+ 		parse_blank(argc, argv, &opt_blank, &opt_bl_min, bad_arg);
++#ifdef __linux__
+ 	else if (STRCMP(option, "dump") == 0)
+ 		parse_snap(argc, argv, &opt_snap, &opt_sn_num, bad_arg);
+ 	else if (STRCMP(option, "append") == 0)
+@@ -721,6 +734,7 @@
+ 		parse_msglevel(argc, argv, &opt_msglevel, &opt_msglevel_num, bad_arg);
+ 	else if (STRCMP(option, "powersave") == 0)
+ 		parse_powersave(argc, argv, &opt_powersave, &opt_ps_mode, bad_arg);
++#endif /* __linux__ */
+ 	else if (STRCMP(option, "powerdown") == 0)
+ 		parse_blank(argc, argv, &opt_powerdown, &opt_pd_min, bad_arg);
+ 	else if (STRCMP(option, "blength") == 0)
+@@ -783,12 +797,14 @@
+ 	fprintf(stderr, _("  [ -clrtabs [ tab1 tab2 tab3 ... ] ]   (tabn = 1-160)\n"));
+ 	fprintf(stderr, _("  [ -regtabs [1-160] ]\n"));
+ 	fprintf(stderr, _("  [ -blank [0-60] ]\n"));
++#ifdef __linux__
+ 	fprintf(stderr, _("  [ -dump   [1-NR_CONSOLES] ]\n"));
+ 	fprintf(stderr, _("  [ -append [1-NR_CONSOLES] ]\n"));
+ 	fprintf(stderr, _("  [ -file dumpfilename ]\n"));
+ 	fprintf(stderr, _("  [ -msg [on|off] ]\n"));
+ 	fprintf(stderr, _("  [ -msglevel [0-8] ]\n"));
+ 	fprintf(stderr, _("  [ -powersave [on|vsync|hsync|powerdown|off] ]\n"));
++#endif /* __linux__ */
+ 	fprintf(stderr, _("  [ -powerdown [0-60] ]\n"));
+ 	fprintf(stderr, _("  [ -blength [0-2000] ]\n"));
+ 	fprintf(stderr, _("  [ -bfreq freqnumber ]\n"));
+@@ -811,8 +827,9 @@
+ static void
+ perform_sequence(int vcterm) {
+ 	/* vcterm: Set if terminal is a virtual console. */
+-
++#ifdef __linux__
+ 	int result;
++#endif
+ /* Perform the selected options. */
+ 
+ 	/* -reset. */
+@@ -1039,7 +1056,8 @@
+ 	/* -blank [0-60]. */
+ 	if (opt_blank && vcterm) 
+ 		printf("\033[9;%d]", opt_bl_min);
+-    
++
++#ifdef __linux__
+ 	/* -powersave [on|vsync|hsync|powerdown|off] (console) */
+ 	if (opt_powersave) {
+ 		char ioctlarg[2];
+@@ -1048,6 +1066,7 @@
+ 		if (ioctl(0,TIOCLINUX,ioctlarg))
+ 			fprintf(stderr,_("cannot (un)set powersave mode\n"));
+ 	}
++#endif /* __linux__ */
+ 
+ 	/* -powerdown [0-60]. */
+ 	if (opt_powerdown) {
+@@ -1060,6 +1079,7 @@
+ 		/* nothing */;
+ #endif
+ 
++#ifdef __linux__
+ 	/* -snap [1-NR_CONS]. */
+ 	if (opt_snap || opt_append) {
+ 		FILE *F;
+@@ -1095,6 +1115,7 @@
+ 		if (result != 0)
+ 			printf(_("klogctl error: %s\n"), strerror(errno));
+ 	}
++#endif /* __linux__ */
+ 
+ 	/* -blength [0-2000] */
+ 	if (opt_blength && vcterm) {
+@@ -1108,6 +1129,7 @@
+ 
+ }
+ 
++#ifdef __linux__
+ static void
+ screendump(int vcnum, FILE *F) {
+     char infile[MAXPATHLEN];
+@@ -1193,6 +1215,7 @@
+ 	}
+     }
+ }
++#endif /* __linux__ */
+ 
+ int
+ main(int argc, char **argv) {
+diff -urNad util-linux/mount/Makefile /tmp/dpep.lVXZel/util-linux/mount/Makefile
+--- util-linux/mount/Makefile	2004-12-15 08:26:36.704412059 -0700
++++ /tmp/dpep.lVXZel/util-linux/mount/Makefile	2004-12-15 08:26:47.890007628 -0700
+@@ -10,10 +10,12 @@
+ COMPILE = $(CC) -c $(CFLAGS) $(DEFINES)
+ LINK = $(CC) $(LDFLAGS)
+ 
++ifeq "$(OS)" "linux"
+ SUID_PROGS = mount umount
+ NOSUID_PROGS = swapon losetup
+ MAN5 = fstab.5 nfs.5
+ MAN8 = mount.8 swapoff.8 swapon.8 umount.8 losetup.8
++endif
+ 
+ ifeq "$(HAVE_PIVOT_ROOT)" "yes"
+ NOSUID_PROGS := $(NOSUID_PROGS) pivot_root
+diff -urNad util-linux/sys-utils/Makefile /tmp/dpep.lVXZel/util-linux/sys-utils/Makefile
+--- util-linux/sys-utils/Makefile	2004-11-15 10:47:47.000000000 -0700
++++ /tmp/dpep.lVXZel/util-linux/sys-utils/Makefile	2004-12-15 08:26:47.890007628 -0700
+@@ -10,20 +10,30 @@
+ 
+ MAN1=		arch.1 flock.1 readprofile.1
+ 
+-MAN8= 		ctrlaltdel.8 cytune.8 dmesg.8 \
+-		ipcrm.8 ipcs.8 renice.8 \
+-		setsid.8 sln.8 tunelp.8
++MAN8= 		ipcrm.8 ipcs.8 renice.8 \
++		setsid.8 sln.8
++
++ifeq "$(OS)" "linux"
++MAN1:= $(MAN1) readprofile.1
++MAN8:= $(MAN8) ctrlaltdel.8 cytune.8 dmesg.8 tunelp.8
++endif
+ 
+ # Where to put binaries?
+ # See the "install" rule for the links. . .
+ 
+-BIN=            arch dmesg
++BIN=            arch
++
++ifeq "$(OS)" "linux"
++BIN:= $(BIN) dmesg
++endif
+ 
+ USRBIN=		cytune flock ipcrm ipcs renice setsid
+ 
++ifeq "$(OS)" "linux"
++USRBIN:= $(USRBIN) cytune
+ USRSBIN=	readprofile tunelp
+-
+ SBIN= 		ctrlaltdel
++endif
+ 
+ NOTMADE=
+ 
+@@ -37,10 +47,12 @@
+ endif
+ endif
+ 
++ifeq "$(OS)" "linux"
+ ifeq "$(ARCH)" "intel"
+ MAN8:=$(MAN8) rdev.8 ramsize.8 rootflags.8 vidmode.8
+ USRSBIN:=$(USRSBIN) rdev
+ endif
++endif
+ 
+ # Where to put datebase files?
+ 
+@@ -87,11 +99,13 @@
+ 	$(INSTALLBIN) $(BIN) $(BINDIR)
+ 	$(INSTALLBIN) $(USRBIN) $(USRBINDIR)
+ 	$(INSTALLBIN) $(USRSBIN) $(USRSBINDIR)
++ifeq "$(OS)" "linux"
+ ifeq "$(ARCH)" "intel"
+ 	(cd $(USRSBINDIR); ln -sf rdev ramsize)
+ 	(cd $(USRSBINDIR); ln -sf rdev vidmode)
+ 	(cd $(USRSBINDIR); ln -sf rdev rootflags)
+ endif
++endif
+ 	$(INSTALLDIR) $(MAN1DIR) $(MAN8DIR) $(INFODIR)
+ 	$(INSTALLMAN) $(MAN1) $(MAN1DIR)
+ 	$(INSTALLMAN) $(MAN8) $(MAN8DIR)
+diff -urNad util-linux/sys-utils/ipcrm.c /tmp/dpep.lVXZel/util-linux/sys-utils/ipcrm.c
+--- util-linux/sys-utils/ipcrm.c	2002-04-24 08:42:54.000000000 -0600
++++ /tmp/dpep.lVXZel/util-linux/sys-utils/ipcrm.c	2004-12-15 08:26:47.890007628 -0700
+@@ -26,7 +26,7 @@
+ /* for tolower and isupper */
+ #include <ctype.h>
+ 
+-#if defined (__GNU_LIBRARY__) && !defined(_SEM_SEMUN_UNDEFINED)
++#if defined (__GLIBC__) && !defined(_SEM_SEMUN_UNDEFINED)
+ /* union semun is defined by including <sys/sem.h> */
+ #else
+ /* according to X/OPEN we have to define it ourselves */
+diff -urNad util-linux/sys-utils/ipcs.c /tmp/dpep.lVXZel/util-linux/sys-utils/ipcs.c
+--- util-linux/sys-utils/ipcs.c	2004-03-04 12:28:42.000000000 -0700
++++ /tmp/dpep.lVXZel/util-linux/sys-utils/ipcs.c	2004-12-15 08:26:47.891007413 -0700
+@@ -78,7 +78,7 @@
+ /* The last arg of semctl is a union semun, but where is it defined?
+    X/OPEN tells us to define it ourselves, but until recently
+    Linux include files would also define it. */
+-#if defined (__GNU_LIBRARY__) && !defined(_SEM_SEMUN_UNDEFINED)
++#if defined (__GLIBC__) && !defined(_SEM_SEMUN_UNDEFINED)
+ /* union semun is defined by including <sys/sem.h> */
+ #else
+ /* according to X/OPEN we have to define it ourselves */
+@@ -95,7 +95,7 @@
+    <linux/ipc.h>, which defines a struct ipc_perm with such fields.
+    glibc-1.09 has no support for sysv ipc.
+    glibc 2 uses __key, __seq */
+-#if defined (__GNU_LIBRARY__) && __GNU_LIBRARY__ > 1
++#if defined (__GLIBC__) && __GLIBC__ > 1
+ #define KEY __key
+ #else
+ #define KEY key
+diff -urNad util-linux/text-utils/more.c /tmp/dpep.lVXZel/util-linux/text-utils/more.c
+--- util-linux/text-utils/more.c	2004-12-05 09:57:57.000000000 -0700
++++ /tmp/dpep.lVXZel/util-linux/text-utils/more.c	2004-12-15 08:26:47.892007198 -0700
+@@ -76,6 +76,14 @@
+ 
+ #define stty(fd,argp)  tcsetattr(fd,TCSANOW,argp)
+ 
++/* TAB3 and TABDLY are in XPG3 and up */
++#if !defined(TABDLY) && defined(TBDELAY)
++#define TABDLY		TBDELAY
++#endif
++#if !defined(TAB3) && defined(XTABS)
++#define TAB3		XTABS
++#endif
++
+ /* some function declarations */
+ void initterm(void);
+ void kill_line(void);
+@@ -1561,7 +1569,7 @@
+     }
+     if (feof (file)) {
+ 	if (!no_intty) {
+-#ifndef __linux__
++#ifdef STDIO_S_EOF_SEEN
+ 				/* No longer in libc 4.5.8. . . */
+ 	    file->_flags &= ~STDIO_S_EOF_SEEN; /* why doesn't fseek do this ??!!??! */
+ #endif
+@@ -1805,8 +1813,8 @@
+     no_intty = tcgetattr(fileno(stdin), &otty);
+     tcgetattr(fileno(stderr), &otty);
+     savetty0 = otty;
+-    slow_tty = (otty.c_cflag & CBAUD) < B1200;
+-    hardtabs = (otty.c_oflag & TABDLY) != XTABS;
++    slow_tty = cfgetospeed(&otty) < B1200;
++    hardtabs = (otty.c_oflag & TABDLY) != TAB3;
+     if (!no_tty) {
+ 	otty.c_lflag &= ~(ICANON|ECHO);
+ 	otty.c_cc[VMIN] = 1;
--- util-linux-2.12r.orig/debian/patches/60_opt_O1.dpatch
+++ util-linux-2.12r/debian/patches/60_opt_O1.dpatch
@@ -0,0 +1,37 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 60_opt_O1.dpatch by  <martin.pitt@ubuntu.com>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: Build with -O1 to work around cfdisk segfault
+
+@DPATCH@
+diff -urNad util-linux-2.12p/configure /tmp/dpep.54ETBp/util-linux-2.12p/configure
+--- util-linux-2.12p/configure	2004-12-20 23:20:35.000000000 +0100
++++ /tmp/dpep.54ETBp/util-linux-2.12p/configure	2005-08-15 15:13:57.000000000 +0200
+@@ -58,7 +58,7 @@
+ echo >> defines.h
+ 
+ CC=${CC-cc}
+-CFLAGS=${CFLAGS-"-O2"}
++CFLAGS=${CFLAGS-"-O1"}
+ LDFLAGS=${LDFLAGS-"-s"}
+ echo CC=$CC >> make_include
+ echo CFLAGS=$CFLAGS >> make_include
+diff -urNad util-linux-2.12p/MCONFIG /tmp/dpep.54ETBp/util-linux-2.12p/MCONFIG
+--- util-linux-2.12p/MCONFIG	2005-08-15 15:12:29.000000000 +0200
++++ /tmp/dpep.54ETBp/util-linux-2.12p/MCONFIG	2005-08-15 15:13:49.000000000 +0200
+@@ -138,12 +138,12 @@
+     CPUTAIL=486
+   endif
+   CPUOPT= $(CPUHEAD)$(CPUTAIL)
+-  OPT=          -pipe -O2 $(CPUOPT) -fomit-frame-pointer
++  OPT=          -pipe -O1 $(CPUOPT) -fomit-frame-pointer
+ else 
+   ifeq "$(ARCH)" "arm"
+     OPT=	-pipe -O2 -fsigned-char -fomit-frame-pointer
+   else
+-    OPT=	-O2 -fomit-frame-pointer
++    OPT=	-O1 -fomit-frame-pointer
+   endif
+ endif
+ 
--- util-linux-2.12r.orig/debian/patches/65_llseek-syscall.dpatch
+++ util-linux-2.12r/debian/patches/65_llseek-syscall.dpatch
@@ -0,0 +1,41 @@
+#! /bin/sh /usr/share/dpatch/dpatch-run
+## 65_llseek-syscall.dpatch by Scott James Remnant <scott@netsplit.com>
+##
+## All lines beginning with `## DP:' are a description of the patch.
+## DP: No description.
+
+@DPATCH@
+diff -urNad util-linux-2.12r~/fdisk/llseek.c util-linux-2.12r/fdisk/llseek.c
+--- util-linux-2.12r~/fdisk/llseek.c	2006-08-21 16:26:32.000000000 +0200
++++ util-linux-2.12r/fdisk/llseek.c	2006-08-21 16:26:40.000000000 +0200
+@@ -31,9 +31,11 @@
+ 
+ #ifdef __NR__llseek
+ 
+-static _syscall5(int,_llseek,unsigned int,fd,unsigned long,offset_high,
+-		 unsigned long, offset_low,long long *,result,
+-		 unsigned int, origin)
++static int _llseek (unsigned int fd, unsigned long oh,
++		    unsigned long ol, long long *result,
++		    unsigned int origin) {
++	return syscall (__NR__llseek, fd, oh, ol, result, origin);
++}
+ 
+ #else
+ 
+diff -urNad util-linux-2.12r~/fdisk/sfdisk.c util-linux-2.12r/fdisk/sfdisk.c
+--- util-linux-2.12r~/fdisk/sfdisk.c	2005-01-04 23:31:57.000000000 +0100
++++ util-linux-2.12r/fdisk/sfdisk.c	2006-08-21 16:27:54.000000000 +0200
+@@ -178,8 +178,10 @@
+ 
+ #ifndef use_lseek
+ static __attribute__used
+-_syscall5(int,  _llseek,  unsigned int,  fd, ulong, hi, ulong, lo,
+-       loff_t *, res, unsigned int, wh);
++int _llseek (unsigned int fd, ulong hi, ulong lo,
++       loff_t *res, unsigned int wh) {
++	return syscall (__NR__llseek, fd, hi, lo, res, wh);
++}
+ #endif
+ 
+ static int
--- util-linux-2.12r.orig/debian/postinst
+++ util-linux-2.12r/debian/postinst
@@ -0,0 +1,41 @@
+#! /bin/sh
+
+umask 022
+set -e
+
+install-info --quiet --section "Development" "Development" \
+  --description="System V interprocess communication facilities" \
+  /usr/share/info/ipc.info.gz
+update-alternatives --install /usr/bin/pager pager /bin/more 50 \
+  --slave /usr/share/man/man1/pager.1.gz pager.1.gz /usr/share/man/man1/more.1.gz
+update-alternatives --install /usr/bin/pager pager /usr/bin/pg 10 \
+  --slave /usr/share/man/man1/pager.1.gz pager.1.gz /usr/share/man/man1/pg.1.gz
+
+#
+#	Check if links to hwclock.sh are present in runlevel "6".
+#	If not, remove the ones from runlevel "S" so that
+#	update-rc.d will do it's job.
+#
+if [ ! -f /etc/rc6.d/???hwclock.sh ] && [ ! -f /etc/rc0.d/???hwclock.sh ]
+then
+	rm -f /etc/rcS.d/???hwclock.sh
+fi
+
+# hwclock works on all Linux architectures, except s390 (and s390x, of course).
+if [ "$(uname -s)" = "Linux" ]; then
+    model=$(uname -m)
+    if [ ${model%x} != "s390" ]; then
+        update-rc.d -f hwclock.sh remove 2>/dev/null > /dev/null
+        update-rc.d hwclock.sh start 50 S . stop 25 0 6 . > /dev/null
+        update-rc.d -f hwclockfirst.sh remove 2>/dev/null > /dev/null
+        #update-rc.d hwclockfirst.sh start 18 S . > /dev/null
+    fi
+fi
+
+if [ -x /usr/sbin/update-mime ]; then
+	update-mime
+fi
+
+if [ -L /usr/doc/util-linux ] ; then
+    rm -f /usr/doc/util-linux
+fi
--- util-linux-2.12r.orig/debian/postrm
+++ util-linux-2.12r/debian/postrm
@@ -0,0 +1,17 @@
+#!/bin/sh
+
+case "$1" in
+	remove)
+		;;
+        purge)
+                update-rc.d hwclock.sh remove >/dev/null
+		update-rc.d hwclockfirst.sh remove >/dev/null
+                ;;
+	*)
+		;;
+esac
+
+if [ -x /usr/sbin/update-mime ]; then
+	update-mime
+fi
+
--- util-linux-2.12r.orig/debian/preinst
+++ util-linux-2.12r/debian/preinst
@@ -0,0 +1,13 @@
+#!/bin/sh
+set -e
+dpkg --assert-support-predepends ||
+  ( echo -e "\nPlease upgrade to a newer version of dpkg\n"; exit 1 )
+
+#cat <<EOF
+#
+#  The package manager might ask you if you want to install new versions
+#  of the /etc/init.d/whatever files. This is generally a good idea
+#  (so reply with \`\`y'') unless you really changed any of these files.
+#
+#EOF
+
--- util-linux-2.12r.orig/debian/prerm
+++ util-linux-2.12r/debian/prerm
@@ -0,0 +1,15 @@
+#! /bin/sh
+
+set -e
+
+install-info --quiet --remove ipc
+
+case "$1" in
+	remove)
+		update-alternatives --remove pager /bin/more
+		update-alternatives --remove pager /usr/bin/pg
+		;;
+	upgrade|failed-upgrade|deconfigure)
+		;;
+esac
+
--- util-linux-2.12r.orig/debian/rejected-upstream
+++ util-linux-2.12r/debian/rejected-upstream
@@ -0,0 +1,76 @@
+Date: Sun, 1 Jul 2001 18:19:00 +0200 (CEST)
+From: Adrian Bunk <bunk@fs.tum.de>
+To: util-linux@math.uio.no
+Subject: [patch] setterm -{dump,append} don't work on current virtual console
+
+Hi Andries,
+
+Colin Watson <cjw44@cam.ac.uk> reported the following Problem:
+
+<--  snip  -->
+
+When 'setterm -dump' or 'setterm -append' is called without further
+arguments, it tries to dump the current virtual console, using
+/dev/vcsa0. Unfortunately, according to the Linux Device List, the
+current virtual console text/attribute contents are on /dev/vcsa.
+
+<--  snip  -->
+
+He sent the following patch:
+
+--- util-linux-2.11g.orig/misc-utils/setterm.c
++++ util-linux-2.11g/misc-utils/setterm.c
+@@ -1115,7 +1115,10 @@
+     int fd, i, j;
+     char *inbuf, *outbuf, *p, *q;
+
+-    sprintf(infile, "/dev/vcsa%d", vcnum);
++    if (vcnum > 0)
++       sprintf(infile, "/dev/vcsa%d", vcnum);
++    else
++       sprintf(infile, "/dev/vcsa");
+     fd = open(infile, 0);
+     if (fd < 0 || read(fd, header, 4) != 4)
+       goto try_ioctl;
+
+cu
+Adrian
+
+-- 
+A "No" uttered from deepest conviction is better and greater than a
+"Yes" merely uttered to please, or what is worse, to avoid trouble.
+                -- Mahatma Ghandi
+
+
+
+
+Date: Sun, 1 Jul 2001 20:31:21 +0200 (MET DST)
+From: Andries.Brouwer@cwi.nl
+To: bunk@fs.tum.de, util-linux@math.uio.no
+Cc: cjw44@cam.ac.uk, hpa@transmeta.com
+Subject: Re: [util-linux] [patch] setterm -{dump,
+    append} don't work on current virtual console
+
+    From: Adrian Bunk <bunk@fs.tum.de>
+
+    Colin Watson <cjw44@cam.ac.uk> reported the following Problem:
+
+    When 'setterm -dump' or 'setterm -append' is called without further
+    arguments, it tries to dump the current virtual console, using
+    /dev/vcsa0. Unfortunately, according to the Linux Device List, the
+    current virtual console text/attribute contents are on /dev/vcsa.
+
+I don't think I'll make this change.
+
+There are several machines here with /dev/vcsa0 and without /dev/vcsa.
+So making this change would certainly give slight problems.
+
+One could test both, but I prefer to leave the code as it is.
+I consider the Linux Device List broken in this respect -
+the vcs naming is exactly analogous to the tty naming, with tty0
+on the same major as tty1, and there was no need to change anything.
+
+Andries
+
+[Let me cc hpa]
+[A distribution should make both nodes, just to be on the safe side.]
--- util-linux-2.12r.orig/debian/rules
+++ util-linux-2.12r/debian/rules
@@ -0,0 +1,359 @@
+#! /usr/bin/make -f
+include /usr/share/dpatch/dpatch.make
+
+SHELL = bash
+PACKAGE = util-linux
+
+ifndef DEB_HOST_ARCH
+DEB_BUILD_ARCH := $(shell dpkg --print-installation-architecture)
+DEB_HOST_ARCH = $(DEB_BUILD_ARCH)
+endif
+
+ifndef DEB_HOST_GNU_SYSTEM
+DEB_HOST_GNU_SYSTEM := $(shell dpkg-architecture -qDEB_HOST_GNU_SYSTEM)
+endif
+
+ifeq ($(DEB_HOST_GNU_SYSTEM),linux)
+# Take account of old dpkg-architecture output.
+DEB_HOST_GNU_SYSTEM := linux-gnu
+endif
+
+export arch = $(DEB_HOST_ARCH)
+version := $(shell sed -e '1{;s|^util-linux (\(.*\))\ .*|\1|;q;}' debian/changelog)
+
+fdisk_arch = $(findstring $(arch),alpha i386 powerpc ppc64 arm mips mipsel hppa ia64 hurd-i386 amd64 s390)
+sparc = $(findstring $(arch),sparc sparc64)
+nohwclock = $(findstring $(arch),s390)
+
+SUBDIRS=po lib getopt disk-utils login-utils misc-utils mount sys-utils text-utils
+ifeq ($(arch),$(fdisk_arch))
+SUBDIRS += fdisk
+endif
+ifeq ($(arch),$(sparc))
+SUBDIRS += fdisk
+endif
+ifeq ($(DEB_HOST_GNU_SYSTEM),linux-gnu)
+ifneq ($(arch),$(nohwclock))
+SUBDIRS += hwclock 
+endif
+endif
+
+ifneq ($(DEB_HOST_GNU_SYSTEM),linux-gnu)
+util-linux_Conflicts = getty
+endif
+
+CFDISK_PO_DIR=cfdisk-po
+CFDISK_POT=$(CFDISK_PO_DIR)/cfdisk.pot
+
+build: patch
+	$(checkdir)
+	./configure
+	$(MAKE) all CPU=$(arch) arch=$(arch) SUBDIRS="${SUBDIRS}"
+	# $(MAKE) disk-utils/raw - this is done above if linux/raw.h exists
+	touch build
+
+clean: unpatch
+	$(checkdir)
+	rm -f build sys-utils/rdev
+	touch make_include
+	$(MAKE) distclean
+	find . -name '*~' -print0 | xargs -0r rm
+	find . -name '*.orig' -print0 | xargs -0r rm
+	find . -name '*.rej' -print0 | xargs -0r rm
+	rm -rf debian/tmp* debian/files* debian/substvars po/messages
+	rm -f debian/hwclockfirst.sh
+	rm -rf $(CFDISK_PO_DIR)
+
+# Architecture independant stuff
+
+SUIDFILES = debian/tmp-mount/bin/{u,}mount
+BINFILES  = sys-utils/arch text-utils/more
+UBINFILES = sys-utils/{ipcs,ipcrm,setsid} \
+	misc-utils/{namei,setterm,mcookie,whereis,ddate} \
+	getopt/getopt text-utils/{rev,line,pg}
+SBINFILES = disk-utils/mkswap
+
+ifeq ($(DEB_HOST_GNU_SYSTEM),linux-gnu)
+ifneq ($(arch),$(nohwclock))
+INITFILES = debian/hwclock.sh # debian/hwclockfirst.sh
+SBINFILES += hwclock/hwclock
+endif
+BINFILES  += sys-utils/dmesg
+SBINFILES += disk-utils/{blockdev,raw,isosize} mount/pivot_root login-utils/agetty
+UBINFILES += disk-utils/fdformat
+USBINFILES = sys-utils/readprofile disk-utils/elvtune # disk-utils/setfdprm
+endif
+
+UBINFILES2= misc-utils/chkdupexe # debian/fdformat # don't strip these
+
+ifeq ($(DEB_HOST_GNU_SYSTEM),linux-gnu)
+MOUNTBINFILES  = mount/mount mount/umount
+MOUNTSBINFILES = mount/swapon mount/losetup
+endif
+
+#BSDBINFILES = # misc-utils/kill
+BSDUBINFILES = misc-utils/script misc-utils/logger sys-utils/renice \
+               login-utils/wall
+               # misc-utils/scriptreplay is handled seperately
+BSDMAN1FILES = login-utils/wall.1 misc-utils/script.1 \
+               misc-utils/logger.1 misc-utils/scriptreplay.1 # misc-utils/kill.1
+BSDMAN8FILES = sys-utils/renice.8
+BSDDOCFILES = debian/README.script
+
+# Architecture independant docs
+
+MAN1FILES = text-utils/{pg,more,line,rev}.1 misc-utils/{namei.1,mcookie.1} \
+            misc-utils/{chkdupexe.1,setterm.1,whereis.1,ddate.1} \
+	    sys-utils/arch.1 getopt/getopt.1
+MAN8FILES = sys-utils/{ipcrm.8,ipcs.8,setsid.8} disk-utils/mkswap.8
+ifeq ($(DEB_HOST_GNU_SYSTEM),linux-gnu)
+ifneq ($(arch),$(nohwclock))
+MAN8FILES += hwclock/hwclock.8
+endif
+MAN1FILES += sys-utils/readprofile.1
+MAN8FILES += login-utils/agetty.8 disk-utils/{blockdev.8,elvtune.8,isosize.8} \
+	     sys-utils/dmesg.8 mount/pivot_root.8 \
+	     disk-utils/fdformat.8 disk-utils/raw.8 # disk-utils/setfdprm.8
+endif
+
+
+EXAMPLES = fdisk/sfdisk.examples getopt/getopt-{test,parse}.{ba,tc}sh
+ifeq ($(DEB_HOST_GNU_SYSTEM),linux-gnu)
+EXAMPLES += debian/fstab.example2
+endif
+
+INFOFILES = sys-utils/ipc.info
+ifeq ($(DEB_HOST_GNU_SYSTEM),linux-gnu)
+DOCFILES  = login-utils/{README.getty,README.modems-with-agetty,README.poeigl}
+ifneq ($(arch),$(nohwclock))
+DOCFILES += debian/README.Debian.hwclock
+endif
+endif
+
+ifeq ($(DEB_HOST_GNU_SYSTEM),linux-gnu)
+MOUNTMAN5FILES = mount/fstab.5 mount/nfs.5
+MOUNTMAN8FILES = mount/losetup.8 mount/swapoff.8 mount/umount.8 \
+		 mount/mount.8 mount/swapon.8
+MOUNTDOCFILES  = mount/README.mount
+endif
+
+ifneq ($(arch),$(sparc))
+SBINFILES := $(SBINFILES) disk-utils/{{fsck,mkfs}.{minix,cramfs},mkfs}
+MAN8FILES := $(MAN8FILES) disk-utils/{{fsck,mkfs}.minix.8,mkfs.8}	# no cramfs man
+endif
+ifeq ($(arch),$(fdisk_arch))
+SBINFILES := $(SBINFILES) fdisk/{cfdisk,fdisk,sfdisk}
+MAN8FILES := $(MAN8FILES) fdisk/{cfdisk.8,fdisk.8,sfdisk.8}
+DOCFILES  := $(DOCFILES) fdisk/README.{c,}fdisk
+ifeq ($(DEB_HOST_GNU_SYSTEM),linux-gnu)
+USBINFILES:= $(USBINFILES) sys-utils/{tunelp,cytune}
+MAN8FILES := $(MAN8FILES) sys-utils/{tunelp.8,cytune.8}
+endif
+endif
+ifeq ($(arch),$(sparc))
+SBINFILES := $(SBINFILES) fdisk/fdisk
+MAN8FILES := $(MAN8FILES) fdisk/fdisk.8
+DOCFILES  := $(DOCFILES) fdisk/README.fdisk
+endif
+ifeq ($(arch),i386)
+USBINFILES:= $(USBINFILES) sys-utils/rdev
+MAN8FILES := $(MAN8FILES) sys-utils/{rdev.8,vidmode.8} \
+		sys-utils/{ramsize.8,rootflags.8}
+endif
+
+install:
+
+debian/hwclockfirst.sh: debian/hwclock.sh
+	sed '/^FIRST/s/no/yes/; s/hwclock\.sh/hwclockfirst.sh/g' debian/hwclock.sh > debian/hwclockfirst.sh
+
+binary-indep:	checkroot build binary-arch
+	$(checkdir)
+	# This assumes non-native, and only one hyphen in the version number.
+	dpkg-gencontrol -isp -putil-linux-locales -Pdebian/tmp-util-linux-locales -VUpstream=$$(sed 's/^.*(\(.*\)-.*).*/\1/; q' debian/changelog)
+	dpkg --build debian/tmp-util-linux-locales ..
+
+binary-arch:	checkroot build $(INITFILES)
+	rm -rf debian/tmp*
+	install -d debian/tmp/{DEBIAN,bin,sbin,etc/init.d,usr/{bin,sbin,lib/mime/packages,share/{locale/{ca,cs,da,de,es,et,fi,fr,it,ja,nl,pt_BR,sl,sv,tr}/LC_MESSAGES,man/{man1,man8},info,$(PACKAGE),doc/$(PACKAGE)/examples,lintian/overrides}}}
+
+	install -s $(BINFILES)  debian/tmp/bin
+	install -s $(SBINFILES) debian/tmp/sbin
+	install -s $(UBINFILES) debian/tmp/usr/bin
+	install    $(UBINFILES2) debian/tmp/usr/bin
+ifneq ($(USBINFILES),)
+	install -s $(USBINFILES) debian/tmp/usr/sbin
+ifeq ($(arch), i386)
+	ln -s rdev debian/tmp/usr/sbin/ramsize
+	ln -s rdev debian/tmp/usr/sbin/vidmode
+	ln -s rdev debian/tmp/usr/sbin/rootflags
+endif
+endif
+ifneq ($(INITFILES),)
+	install -m 755 $(INITFILES) debian/tmp/etc/init.d
+endif
+	install -m 644 $(MAN1FILES) debian/tmp/usr/share/man/man1
+	install -m 644 $(MAN8FILES) debian/tmp/usr/share/man/man8
+	install -m 644 $(INFOFILES) debian/tmp/usr/share/info
+	install -m 644 debian/lintian-override debian/tmp/usr/share/lintian/overrides/$(PACKAGE)
+	cd po && make install DESTDIR=../debian/tmp
+ifneq ($(DOCFILES),)
+	install -m 644 $(DOCFILES)  debian/tmp/usr/share/doc/$(PACKAGE)
+endif
+	install -m 644 $(EXAMPLES)  debian/tmp/usr/share/doc/$(PACKAGE)/examples
+ifeq ($(arch),$(findstring $(arch),powerpc ppc64))
+	mv -f debian/tmp/sbin/fdisk debian/tmp/sbin/ddisk
+	mv -f debian/tmp/usr/share/man/man8/fdisk.8 debian/tmp/usr/share/man/man8/ddisk.8
+endif
+ifeq ($(DEB_HOST_GNU_SYSTEM),gnu)
+	(cd debian/tmp/sbin ; mv mkswap mkswap.linux)
+	(cd debian/tmp/usr/share/man/man8 ; mv mkswap.8 mkswap.linux.8)
+endif
+ifeq ($(DEB_HOST_GNU_SYSTEM),linux-gnu)
+	(cd debian/tmp/sbin ; mv agetty getty)
+	(cd debian/tmp/usr/share/man/man8 ; mv agetty.8 getty.8)
+ifneq ($(arch), $(nohwclock))
+ifneq ($(arch),$(findstring $(arch),powerpc ppc64))
+	(cd debian/tmp/usr/share/man/man8 && ln -s hwclock.8.gz clock.8.gz)
+endif
+endif
+	(cd debian/tmp/usr/share/doc/$(PACKAGE) ; mv README.modems-with-agetty README.modems-with-getty )
+	perl -pi.bak -e 's/agetty/getty/g' debian/tmp/usr/share/man/man8/getty.8 \
+	debian/tmp/usr/share/doc/$(PACKAGE)/README.getty \
+	debian/tmp/usr/share/doc/$(PACKAGE)/README.modems-with-getty
+	rm `find debian/tmp/usr -name \*.bak`
+endif
+	install -m 644 debian/changelog \
+	  debian/tmp/usr/share/doc/$(PACKAGE)/changelog.Debian
+	install -m 644 HISTORY debian/tmp/usr/share/doc/$(PACKAGE)/changelog
+	find debian/tmp/usr/share/{info,doc,man} -type f | xargs gzip -9
+	install -m 644 debian/mime.$(PACKAGE) debian/tmp/usr/lib/mime/packages/$(PACKAGE)
+	install -m 644 debian/copyright debian/tmp/usr/share/doc/$(PACKAGE)/copyright
+	install debian/{preinst,postinst,prerm,postrm} debian/tmp/DEBIAN/
+ifeq ($(DEB_HOST_GNU_SYSTEM),linux-gnu)
+ifneq ($(arch),$(nohwclock))
+	install -m 644 debian/conffiles debian/tmp/DEBIAN/
+endif
+endif
+	ls debian/tmp/{bin,sbin,usr/{bin,sbin}}/* | xargs dpkg-shlibdeps -putil-linux
+	install -d debian/tmp-util-linux-locales/usr/share/doc/util-linux-locales
+	install -d debian/tmp-util-linux-locales/DEBIAN
+	install -m 755 debian/util-linux-locales.postinst debian/tmp-util-linux-locales/DEBIAN/postinst
+	install -m 755 debian/util-linux-locales.prerm debian/tmp-util-linux-locales/DEBIAN/prerm
+	mv debian/tmp/usr/share/locale debian/tmp-util-linux-locales/usr/share/
+	install -m 644 HISTORY debian/tmp-util-linux-locales/usr/share/doc/util-linux-locales/changelog
+	install -m 644 debian/changelog debian/tmp-util-linux-locales/usr/share/doc/util-linux-locales/changelog.Debian
+	find debian/tmp-util-linux-locales/usr/share/doc -type f | xargs gzip -9
+	install -m 644 debian/copyright debian/tmp-util-linux-locales/usr/share/doc/util-linux-locales/copyright
+	dpkg-gencontrol -isp -putil-linux -Vutil-linux:Conflicts="$(util-linux_Conflicts)"
+	dpkg --build debian/tmp ..
+
+ifeq ($(arch),$(fdisk_arch))
+# Do the udeb
+	install -d debian/tmp-{c,}fdisk-udeb/usr/sbin
+	install -d debian/tmp-{c,}fdisk-udeb/DEBIAN
+	install -m 755 fdisk/cfdisk debian/tmp-cfdisk-udeb/usr/sbin
+	install -m 755 fdisk/fdisk fdisk/sfdisk debian/tmp-fdisk-udeb/usr/sbin
+	strip --remove-section=.comment --remove-section=.note \
+			debian/tmp-{c,}fdisk-udeb/usr/sbin/*
+
+	# Generate a po translations needed for cfdisk
+	mkdir $(CFDISK_PO_DIR)
+	xgettext --default-domain=util-linux -C --keyword=_ --keyword=N_ -o $(CFDISK_POT) fdisk/*.c
+	for po in po/*.po ; do  \
+		LANG=`basename $$po | cut -f1 -d.` ; \
+		msgmerge $$po $(CFDISK_POT)  > $(CFDISK_PO_DIR)/$$LANG.po ; \
+		msgfmt $(CFDISK_PO_DIR)/$$LANG.po -o $(CFDISK_PO_DIR)/$$LANG.gmo ; \
+		mkdir -p debian/tmp-cfdisk-udeb/usr/share/locale/$$LANG/LC_MESSAGES ; \
+		cp $(CFDISK_PO_DIR)/$$LANG.gmo debian/tmp-cfdisk-udeb/usr/share/locale/$$LANG/LC_MESSAGES/util-linux.mo ; \
+	done
+
+	ls debian/tmp-fdisk-udeb/usr/sbin/* | xargs dpkg-shlibdeps -pfdisk-udeb -tudeb
+	dpkg-gencontrol -isp -pfdisk-udeb -Pdebian/tmp-fdisk-udeb -fdebian/files~
+	dpkg-distaddfile fdisk-udeb_$(shell dpkg-parsechangelog | grep ^Version: | cut -d ' ' -f 2)_$(arch).udeb debian-installer extra
+	dpkg --build debian/tmp-fdisk-udeb ../fdisk-udeb_$(shell dpkg-parsechangelog | grep ^Version: | cut -d ' ' -f 2)_$(arch).udeb
+
+	ls debian/tmp-cfdisk-udeb/usr/sbin/* | xargs dpkg-shlibdeps -pcfdisk-udeb -tudeb
+	dpkg-gencontrol -isp -pcfdisk-udeb -Pdebian/tmp-cfdisk-udeb -fdebian/files~
+	dpkg-distaddfile cfdisk-udeb_$(shell dpkg-parsechangelog | grep ^Version: | cut -d ' ' -f 2)_$(arch).udeb debian-installer extra
+	dpkg --build debian/tmp-cfdisk-udeb ../cfdisk-udeb_$(shell dpkg-parsechangelog | grep ^Version: | cut -d ' ' -f 2)_$(arch).udeb
+endif
+ifeq ($(arch),$(sparc))
+# Do the udeb
+	install -d debian/tmp-fdisk-udeb/usr/sbin
+	install -d debian/tmp-fdisk-udeb/DEBIAN
+	install -m 755 fdisk/fdisk debian/tmp-fdisk-udeb/usr/sbin
+	strip --remove-section=.comment --remove-section=.note \
+			debian/tmp-fdisk-udeb/usr/sbin/*
+
+	ls debian/tmp-fdisk-udeb/usr/sbin/* | xargs dpkg-shlibdeps -pfdisk-udeb
+	dpkg-gencontrol -isp -pfdisk-udeb -Pdebian/tmp-fdisk-udeb -fdebian/files~
+	dpkg-distaddfile fdisk-udeb_$(shell dpkg-parsechangelog | grep ^Version: | cut -d ' ' -f 2)_$(arch).udeb debian-installer extra
+	dpkg --build debian/tmp-fdisk-udeb ../fdisk-udeb_$(shell dpkg-parsechangelog | grep ^Version: | cut -d ' ' -f 2)_$(arch).udeb
+endif
+
+ifeq ($(DEB_HOST_GNU_SYSTEM),linux-gnu)
+	# Mount
+	install -d debian/tmp-mount/{DEBIAN,bin,sbin,usr/share/{man/{man8,man5},doc/mount/examples}}
+	install -m 4755 -o root -s $(MOUNTBINFILES) debian/tmp-mount/bin/.
+	install -m 755 -s $(MOUNTSBINFILES) debian/tmp-mount/sbin/.
+	install -m 644 $(MOUNTMAN8FILES) debian/tmp-mount/usr/share/man/man8
+	install -m 644 $(MOUNTMAN5FILES) debian/tmp-mount/usr/share/man/man5
+	install -m 644 $(MOUNTDOCFILES) debian/tmp-mount/usr/share/doc/mount
+	(cd debian/tmp-mount/sbin ; ln -s swapon swapoff)
+	install -m 644 debian/mount.fstab \
+	  debian/tmp-mount/usr/share/doc/mount/examples/fstab
+	install -m 644 debian/changelog \
+	  debian/tmp-mount/usr/share/doc/mount/changelog.Debian
+	install -m 644 debian/changelog.Debian-mount.old \
+	  debian/tmp-mount/usr/share/doc/mount/changelog.Debian-mount.old
+	install -m 644 HISTORY debian/tmp-mount/usr/share/doc/mount/changelog
+	find debian/tmp-mount/usr/share/{doc,man} -type f | xargs gzip -9
+	install -m 644 debian/copyright debian/tmp-mount/usr/share/doc/mount/copyright
+	install debian/mount.postinst debian/tmp-mount/DEBIAN/postinst
+	install debian/mount.prerm   debian/tmp-mount/DEBIAN/prerm
+	ls debian/tmp-mount/{bin,sbin}/* | xargs dpkg-shlibdeps -pmount
+	dpkg-gencontrol -isp -pmount -Pdebian/tmp-mount
+	dpkg --build debian/tmp-mount ..
+endif
+
+	# Bsdutils
+	install -d debian/tmp-bsd/{DEBIAN,bin,usr/{bin,share/man/{man8,man1},share/doc/bsdutils}}
+	# install -m 755 -o root -s $(BSDBINFILES) debian/tmp-bsd/bin/.
+	install -m 755 -s $(BSDUBINFILES) debian/tmp-bsd/usr/bin/.
+	cp misc-utils/scriptreplay.pl debian/tmp-bsd/usr/bin/scriptreplay
+	chmod 755 debian/tmp-bsd/usr/bin/scriptreplay
+	install -m 644 $(BSDMAN8FILES) debian/tmp-bsd/usr/share/man/man8
+	mv debian/tmp-bsd/usr/share/man/man8/renice.8 debian/tmp-bsd/usr/share/man/man1/renice.1
+	install -m 644 $(BSDMAN1FILES) debian/tmp-bsd/usr/share/man/man1
+	install -m 644 $(BSDDOCFILES) debian/tmp-bsd/usr/share/doc/bsdutils
+	chown root:tty debian/tmp-bsd/usr/bin/wall
+	chmod g+s debian/tmp-bsd/usr/bin/wall
+	install -m 644 debian/changelog \
+	  debian/tmp-bsd/usr/share/doc/bsdutils/changelog.Debian
+	install -m 644 HISTORY debian/tmp-bsd/usr/share/doc/bsdutils/changelog
+	find debian/tmp-bsd/usr/share/{doc,man} -type f | xargs gzip -9
+	install -m 644 debian/copyright debian/tmp-bsd/usr/share/doc/bsdutils/copyright
+	install debian/bsdutils.postinst debian/tmp-bsd/DEBIAN/postinst
+	install debian/bsdutils.prerm   debian/tmp-bsd/DEBIAN/prerm
+	ls debian/tmp-bsd/usr/bin/* | xargs dpkg-shlibdeps -pbsdutils
+	dpkg-gencontrol -isp -pbsdutils -Pdebian/tmp-bsd -v1:$(version)
+	dpkg --build debian/tmp-bsd ..
+
+define checkdir
+	test -f fdisk/fdisk.c -a -f debian/rules
+endef
+
+binary:		binary-indep binary-arch
+
+source diff:
+	@echo >&2 'source and diff are obsolete - use dpkg-source -b'; false
+
+checkroot:
+	$(checkdir)
+	test root = "`whoami`"
+
+.PHONY: binary binary-arch binary-indep clean checkroot
+
+# Local Variables:
+# mode:Makefile
+# End:
--- util-linux-2.12r.orig/debian/shlibs.local
+++ util-linux-2.12r/debian/shlibs.local
@@ -0,0 +1 @@
+libblkid 1 libblkid1 (>=1.37-1)
--- util-linux-2.12r.orig/debian/util-linux-locales.postinst
+++ util-linux-2.12r/debian/util-linux-locales.postinst
@@ -0,0 +1,5 @@
+#! /bin/sh -e
+
+if [ -L /usr/doc/util-linux-locales ] ; then
+    rm -f /usr/doc/util-linux-locales
+fi
--- util-linux-2.12r.orig/debian/util-linux-locales.prerm
+++ util-linux-2.12r/debian/util-linux-locales.prerm
@@ -0,0 +1,14 @@
+#! /bin/sh
+
+set -e
+
+case "$1" in
+	remove)
+		if [ -L /usr/doc/util-linux-locales ] ; then
+        		rm -f /usr/doc/util-linux-locales
+		fi
+		;;
+	upgrade|failed-upgrade|deconfigure)
+		;;
+esac
+
--- util-linux-2.12r.orig/debian/bzr-version
+++ util-linux-2.12r/debian/bzr-version
@@ -0,0 +1 @@
+
